<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:gpo="http://www.gpo.gov/xslt/functions" exclude-result-prefixes="xs gpo" version="2.0"> 
    
    <!--<xsl:output method="xml" indent="yes" encoding="ISO-8859-1"/>    -->    
    <xsl:output method="xml" indent="yes" encoding="utf-8" />                                   
    <xsl:param name="mEnforceUpsLogic" select="false()" /><xsl:param name="processTables" select="true()" as="xs:boolean" /><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl">
        <xd:desc>
            <xd:p>08-05-206 mharcourt - $baseXMLfile allows reporting of current XML file name in xsl:message. 
                Currently only used in calsTables.xsl. Cane be set using oXygen editor variables ${cfd}\${cfne}
                in the parameters tab of XSLT transformations.</xd:p>
        </xd:desc>
    </xd:doc><xsl:param name="baseXMLfile" as="xs:string" select="base-uri()" /><xsl:param name="debugState" select="0" as="xs:integer" /><xsl:param name="suppressDiagnosticMessages" select="1" as="xs:integer" /><xsl:variable name="uriBase" select="replace(replace(base-uri(.), '\.[xX][mM][lL]', ''), 'file:/', 'file:///')" /><xsl:variable name="lookupXml">
        <lookupfile>
            <!-- NB 8/22/2006 - New process created for Italic tag -->
            <entry>
                <name>italic</name>
                <process>attributePopulation</process>
                <keys>@headerInTextItalics</keys>
            </entry>
            <entry>
                <process>InlineHeaderItalics</process>
                <name>#default#</name>
                <style>#default#</style>
                <attributenames>vbattItalicFormatBegin;vbattItalicFormatEnd</attributenames>
                <attributevalues>G2;G1</attributevalues>
            </entry>
            <entry>
                <process>InlineHeaderItalics</process>
                <name />
                <style>#default#</style>
                <attributenames>vbattItalicFormatBegin;vbattItalicFormatEnd</attributenames>
                <attributevalues>T3;T1</attributevalues>
            </entry>
            <entry>
                <process>InlineHeaderItalics</process>
                <name>#default#</name>
                <name />
                <style>USC</style>
                <attributenames>vbattItalicFormatBegin;vbattItalicFormatEnd</attributenames>
                <attributevalues>G2;G1</attributevalues>
            </entry>
            <entry>
                <process>InlineHeaderItalics</process>
                <name>subchapter</name>
                <style>USC</style>
                <attributenames>vbattItalicFormatBegin;vbattItalicFormatEnd</attributenames>
                <attributevalues>T3;K</attributevalues>
            </entry>
            <entry>
                <process>InlineHeaderItalics</process>
                <name>title</name>
                <name>subtitle</name>
                <name>subchapter</name>
                <name>subpart</name>
                <style>traditional</style>
                <style>traditional-inline</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattItalicFormatBegin;vbattItalicFormatEnd</attributenames>
                <attributevalues>T3;K</attributevalues>
            </entry>
            <entry>
                <process>InlineHeaderItalics</process>
                <name>#default#</name>
                <name />
                <style>traditional</style>
                <style>traditional-inline</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattItalicFormatBegin;vbattItalicFormatEnd</attributenames>
                <attributevalues>G2;G1</attributevalues>
            </entry>
            <entry>
                <process>InlineHeaderItalics</process>
                <name>subsection</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattItalicFormatBegin;vbattItalicFormatEnd</attributenames>
                <attributevalues>T3;K</attributevalues>
            </entry>
            <!-- NB 8/22/2006 - end of new process created -->
            <!-- HEADER-IN-TEXT PROCESSES -->
            <entry>
                <name>header-in-text</name>
                <process>attributePopulation</process>
                <keys>@inlineheader</keys>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>#default#</name>
                <style>#default#</style>
                <attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
                <attributevalues>G2;T1;AllLower</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>#default#</name>
                <style>OLC</style>
                <attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
                <attributevalues>G2;T1;AllLower</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>parent=quote</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
                <attributevalues>G2;T1;AllLower</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>#default#</name>
                <style>USC</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>#default#</name>
                <style>traditional</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T4;AllLower</attributevalues>
            </entry>
            <!-- DIVISION PROCESSES -->
            <entry>
                <process>InlineHeader</process>
                <name>division</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;AllCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>division</name>
                <style>traditional</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>;AllCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>division</name>
                <style>traditional-inline</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;AllCaps</attributevalues>

                <process>InlineHeader</process>
                <name>division</name>
                <style>appropriations</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;AllCaps</attributevalues>
            </entry>

            <!-- APPROPRIATIONS -->
            <entry>
                <process>InlineHeader</process>
                <name>appropriations-major</name>
                <style>#default#</style>
                <attributenames>vbattMode</attributenames>
                <attributevalues>AllCaps</attributevalues>
            </entry>

            <entry>
                <process>InlineHeader</process>
                <name>appropriations-intermediate</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T5;InitialCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>appropriations-small</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;AllLower</attributevalues>
            </entry>



            <!-- SUBDIVISION PROCESSES -->
            <entry>
                <process>InlineHeader</process>
                <name>subdivision</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;AllCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subdivision</name>
                <style>traditional</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues> ;InitialCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subdivision</name>
                <style>traditional-inline</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;InitialCaps</attributevalues>
            </entry>

            <entry>
                <process>InlineHeader</process>
                <name>subdivision</name>
                <style>appropriations</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;InitialCaps</attributevalues>
            </entry>
            <!-- TITLE PROCESSES -->
            <entry>
                <name>title</name>
                <process>attributePopulation</process>
                <keys>@style</keys>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>title</name>
                <style>#default#</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I78</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>title</name>
                <style>archaic</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>title</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>title</name>
                <style>traditional-inline</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>title</name>
                <style>appropriations</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>title</name>
                <style>traditional</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>title</name>
                <style>education</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>title</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;AllCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>title</name>
                <style>traditional</style>
                <style>traditional-inline</style>
                <style>appropriations</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues> ;AllCaps</attributevalues>
            </entry>
            <!-- SUBTITLE PROCESSES -->
            <entry>
                <name>subtitle</name>
                <process>attributePopulation</process>
                <keys>@style</keys>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subtitle</name>
                <style>#default#</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I78</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subtitle</name>
                <style>archaic</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subtitle</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subtitle</name>
                <style>traditional-inline</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subtitle</name>
                <style>appropriations</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subtitle</name>
                <style>traditional</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subtitle</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;InitialCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subtitle</name>
                <style>traditional</style>
                <style>traditional-inline</style>
                <style>appropriations</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues> ;InitialCaps</attributevalues>
            </entry>
            <!-- CHAPTER PROCESSES -->
            <entry>
                <process>InlineHeader</process>
                <name>chapter</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;AllCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>chapter</name>
                <style>traditional-inline</style>
                <style>nuclear</style>
                <style>appropriations</style>
                <attributenames>vbattMode</attributenames>
                <attributevalues>AllCaps</attributevalues>
            </entry>

            <!-- SUBCHAPTER PROCESSES -->
            <entry>
                <name>subchapter</name>
                <process>attributePopulation</process>
                <keys>@style</keys>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subchapter</name>
                <style>#default#</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T2</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subchapter</name>
                <style>USC</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subchapter</name>
                <style>archaic</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subchapter</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subchapter</name>
                <style>traditional-inline</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subchapter</name>
                <style>appropriations</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subchapter</name>
                <style>traditional</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subchapter</name>
                <style>education</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I73</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subchapter</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;InitialCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subchapter</name>
                <style>USC</style>
                <style>traditional</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues> ;AllCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subchapter</name>
                <style>traditional-inline</style>
                <style>appropriations</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>;InitialCaps</attributevalues>
            </entry>

            <!-- PART PROCESSES -->
            <entry>
                <name>part</name>
                <process>attributePopulation</process>
                <keys>@style</keys>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>part</name>
                <style>#default#</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I73</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>part</name>
                <style>education</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>part</name>
                <style>archaic</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>part</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>part</name>
                <style>traditional-inline</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>part</name>
                <style>appropriations</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>part</name>
                <style>traditional</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <!--<entry>
		<process>InlineHeader</process>
		<name>part</name>
		<style>#default#</style>
		<attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
		<attributevalues>G2;T1;AllLower</attributevalues>
	</entry>-->
            <entry>
                <process>InlineHeader</process>
                <name>part</name>
                <style>#default#</style>
                <attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
                <attributevalues>@Grid;@Typeface;AllLower</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>part</name>
                <style>OLC</style>
                <attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
                <attributevalues>G2;T1;AllLower</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>part</name>
                <style>traditional</style>
                <style>traditional-inline</style>
                <style>appropriations</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T4;InitialCaps</attributevalues>
            </entry>
            <!-- SUBPART PROCESSES -->
            <entry>
                <process>LevelLocator</process>
                <name>subpart</name>
                <process>attributePopulation</process>
                <keys>@style</keys>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subpart</name>
                <style>#default#</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I73</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subpart</name>
                <style>education</style>
                <attributenames>vbattLocator</attributenames>
                <attributevalues>I74</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subpart</name>
                <style>archaic</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subpart</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subpart</name>
                <style>traditional-inline</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subpart</name>
                <style>appropriations</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>LevelLocator</process>
                <name>subpart</name>
                <style>traditional</style>
                <attributenames>vbattLocator;vbattFormat</attributenames>
                <attributevalues>I74;T1</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subpart</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T2;InitialCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subpart</name>
                <style>traditional</style>
                <style>traditional-inline</style>
                <style>appropriations</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues> ;InitialCaps</attributevalues>
            </entry>
            <!--entry>
		<process>InlineHeader</process>
		<name>subsection</name>		
		<style>archaic</style>
		<style>archaic-paragraph</style>
		<attributenames>vbattTypeface;vbattMode</attributenames>
		<attributevalues> ;InitialCaps</attributevalues>
	</entry-->
            <!-- PARAGRAPH PROCESSES -->
            <entry>
                <process>InlineHeader</process>
                <name>paragraph</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;@AllLower/FirstWord</attributevalues>
            </entry>

            <entry>
                <process>InlineHeader</process>
                <name>paragraph</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;AllLower</attributevalues>
            </entry>
            <!--<entry>
		<process>InlineHeader</process>
		<name>paragraph</name>
		<style>OLC</style>
		<style>tax</style>
		<style>education</style>		
		<attributenames>vbattTypeface;vbattMode</attributenames>
		<attributevalues>T#;FirstWord</attributevalues>
	</entry>
	<entry>
		<process>InlineHeader</process>
		<name>paragraph</name>
		<style>traditional</style>
		<style>traditional-inline</style>
		<style>archaic</style>
		<attributenames>vbattTypeface;vbattMode</attributenames>
		<attributevalues>T4;@AllLower/FirstWord</attributevalues>
	</entry>
	<entry>
		<process>InlineHeader</process>
		<name>paragraph</name>
		<style>OLC</style>
		<style>tax</style>
		<style>education</style>
		<style>USC</style>
		<style>traditional-inline</style>
		<style>traditional</style>
		<attributenames>vbattTypeface</attributenames>
		<attributevalues>T#</attributevalues>
	</entry>-->

            <!-- SUBPARAGRAPH PROCESSES -->
            <entry>
                <process>InlineHeader</process>
                <name>subparagraph</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;@AllLower/FirstWord</attributevalues>
            </entry>

            <entry>
                <process>InlineHeader</process>
                <name>subparagraph</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;AllLower</attributevalues>
            </entry>

            <!-- CLAUSE PROCESSES -->

            <entry>
                <process>InlineHeader</process>
                <name>clause</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;@AllLower/FirstWord</attributevalues>
            </entry>

            <entry>
                <process>InlineHeader</process>
                <name>clause</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;AllLower</attributevalues>
            </entry>



            <!-- SUBCLAUSE PROCESSES -->

            <entry>
                <process>InlineHeader</process>
                <name>subclause</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;@AllLower/FirstWord</attributevalues>
            </entry>

            <entry>
                <process>InlineHeader</process>
                <name>subclause</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;AllLower</attributevalues>
            </entry>


            <!-- ITEM PROCESSES -->

            <entry>
                <process>InlineHeader</process>
                <name>item</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;@AllLower/FirstWord</attributevalues>
            </entry>

            <entry>
                <process>InlineHeader</process>
                <name>item</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;AllLower</attributevalues>
            </entry>



            <!-- SUBITEM PROCESSES -->

            <entry>
                <process>InlineHeader</process>
                <name>subitem</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;@AllLower/FirstWord</attributevalues>
            </entry>

            <entry>
                <process>InlineHeader</process>
                <name>subitem</name>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;AllLower</attributevalues>
            </entry>


            <!-- SECTION PROCESSES 
		<entry>
		<process>InlineHeader</process>
		<name>section</name>
		<style>OLC</style>
		<attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
		<attributevalues>@OLCsection;@Typeface;AllLower</attributevalues>
		</entry>
	<entry>
		<process>InlineHeader</process>
		<name>section</name>
		<style>tax</style>
		<style>education</style>
		<attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
		<attributevalues>G2;T1;AllLower</attributevalues>
	</entry>
		-->
            <entry>
                <process>InlineHeader</process>
                <name>section</name>
                <style>#default#</style>
                <attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
                <attributevalues>@Grid;@Typeface;AllLower</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>section</name>
                <style>OLC</style>
                <attributenames>vbattGrid;vbattTypeface;vbattMode</attributenames>
                <attributevalues>G2;T1;AllLower</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>section</name>
                <style>USC</style>
                <attributenames>vbattTypeface</attributenames>
                <attributevalues>T2</attributevalues>
            </entry>

            <!--entry>
		<process>InlineHeader</process>
		<name>section</name>
		<style>traditional-inline</style>
		<style>appropriations</style>
		<style>archaic</style>
		<style>archaic-paragraph</style>
		<attributenames>vbattTypeface;vbattMode</attributenames>
		<attributevalues>@TraditionalSectionTypeface;AllLower</attributevalues>
	</entry-->
            <entry>
                <process>InlineHeader</process>
                <name>section</name>
                <style>appropriations</style>
                <style>archaic</style>
                <style>archaic-paragraph</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>@TraditionalSectionTypeface;AllLower</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>section</name>
                <style>traditional-inline</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T5;InitialCaps</attributevalues>
            </entry>

            <entry>
                <process>InlineHeader</process>
                <name>section</name>
                <style>traditional</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T#;AllLower</attributevalues>
            </entry>



            <!-- SUBSECTION PROCESSES -->
            <entry>
                <process>InlineHeader</process>
                <name>subsection</name>
                <style>#default#</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T5;InitialCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subsection</name>
                <style>archaic-paragraph</style>
                <style>archaic</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues> ;InitialCaps</attributevalues>
            </entry>
            <entry>
                <process>InlineHeader</process>
                <name>subsection</name>
                <style>traditional</style>
                <style>traditional-inline</style>
                <style>appropriations</style>
                <attributenames>vbattTypeface;vbattMode</attributenames>
                <attributevalues>T5;InitialCaps</attributevalues>
            </entry>

        </lookupfile>




    </xsl:variable><xsl:variable name="lookupElementNames" select="$lookupXml/lookupfile/entry[process = 'attributePopulation']/name" /><xsl:variable name="documentElement" select="/*" as="element()" /><xsl:variable name="stageForParentFormat" as="xs:string?">
        <xsl:sequence select="                 if ($documentElement/@bill-stage)                 then                     string($documentElement/@bill-stage)                 else                     if ($documentElement/@resolution-stage)                     then                         string($documentElement/@resolution-stage)                     else                         ''" />
    </xsl:variable><xsl:key name="committee" match="committee-name" use="@committee-id" /><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>Returns an XPath to a node and the base-uri where an exeption occured</desc>
        <param>The node.</param>
        <return>The pathe to the node and the base-uri of the node.</return>
    </doc><xsl:function name="gpo:genericExceptionHandler" as="item()*">

        <xsl:param name="node" as="node()?" />

        <xsl:variable name="names" as="xs:string*">
            <xsl:for-each select="$node/ancestor-or-self::*">
                <xsl:variable name="ancestor" select="." />
                <xsl:variable name="sibsOfSameName" select="$ancestor/../*[name() = name($ancestor)]" />
                <xsl:sequence select="                         concat(name($ancestor),                         if (count($sibsOfSameName) &lt;= 1)                         then                             ''                         else                             concat(                             '[', gpo:index-of-node($sibsOfSameName, $ancestor), ']'))" />
            </xsl:for-each>
        </xsl:variable>

        <!--xsl:sequence select="string-join($names,'/')"/-->

        <xsl:value-of select="concat('An exception occured at node with XPath: ', string-join($names, '/'), ' in document: ', base-uri($node))" />

        <!--xsl:message>An exception occured at node with XPath: <xsl:value-of
                select="string-join($names, '/')"/> in XML document: <xsl:value-of
                select="base-uri($node)"/></xsl:message-->

    </xsl:function><xsl:function name="gpo:index-of-node" as="xs:integer*">
        <xsl:param name="nodes" as="node()*" />
        <xsl:param name="nodeToFind" as="node()" />

        <xsl:sequence select="                 for $seq in (1 to count($nodes))                 return                     $seq[$nodes[$seq] is $nodeToFind]                 " />

    </xsl:function> 
    
    <xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="@* | node()" mode="modeUtil">
		<xsl:copy>
			<xsl:apply-templates select="@* | node()" mode="modeUtil" />
		</xsl:copy>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="table" mode="modeUtil">
		<xsl:choose>
			<xsl:when test="$processTables = false()" />
			<xsl:otherwise>
				<xsl:sequence select="." />
			</xsl:otherwise>
		</xsl:choose>
		
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="element()[@indent]" priority="24" mode="modeUtil">
		<xsl:copy>
			<xsl:call-template name="setIndent">
				<xsl:with-param name="elementNode" select="." />
			</xsl:call-template>
			<xsl:apply-templates select="@* except @indent | node()" mode="modeUtil" />
		</xsl:copy>

	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="setIndent" as="attribute()*">

		<xsl:param name="elementNode" as="element()" />


		<xsl:if test="normalize-space($elementNode/@indent) != ''">
			<xsl:variable name="newIndent">
				<xsl:analyze-string select="normalize-space($elementNode/@indent)" regex="^(up|down)(\d+)$">
					<xsl:matching-substring>
						<xsl:choose>
							<xsl:when test="regex-group(1) = 'up'">
								<xsl:value-of select="regex-group(2)" />
							</xsl:when>
							<xsl:when test="regex-group(1) = 'down'">
								<xsl:value-of select="concat('-', regex-group(2))" />
							</xsl:when>
						</xsl:choose>
					</xsl:matching-substring>
					<xsl:non-matching-substring>
						<xsl:value-of select="." />
					</xsl:non-matching-substring>
				</xsl:analyze-string>
			</xsl:variable>
			<xsl:attribute name="indent" select="$newIndent" />
		</xsl:if>




	</xsl:template>
                   
    <xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="@* | node()" mode="setIndentAttr">
		<xsl:copy>
			<xsl:apply-templates select="@* | node()" mode="setIndentAttr" />
		</xsl:copy>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="copy-all-attributes">
		<xsl:for-each select="attribute::*">
			<xsl:copy />
		</xsl:for-each>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="GetNearestAncestorStyleRecursive">
		<xsl:param name="node" />

		<xsl:choose>
			<xsl:when test="ancestor-or-self::quoted-block/@style">
				<xsl:choose>
					<xsl:when test="ancestor-or-self::quoted-block/@style = 'other'">
						<xsl:value-of select="ancestor-or-self::quoted-block/@other-style" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="ancestor-or-self::quoted-block/@style" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="self::resolution-body and not(@style)">
				<xsl:value-of select="OLC" />
				<xsl:text>OLC</xsl:text>
			</xsl:when>

			<xsl:when test="@style">
				<xsl:if test="@style = 'other'">
					<xsl:value-of select="@other-style" />
				</xsl:if>
				<xsl:if test="not(@style = 'other')">
					<xsl:value-of select="@style" />
				</xsl:if>
			</xsl:when>
			<xsl:when test="@bill-type">
				<xsl:if test="@bill-type = 'olc'">
					<xsl:text>OLC</xsl:text>
				</xsl:if>
				<xsl:if test="not(@bill-type = 'olc')">
					<xsl:value-of select="@bill-type" />
				</xsl:if>
			</xsl:when>
			<xsl:when test="@resolution-type">
				<xsl:if test="@resolution-type = 'olc'">
					<xsl:text>OLC</xsl:text>
				</xsl:if>
				<xsl:if test="not(@resolution-type = 'olc')">
					<xsl:value-of select="@resolution-type" />
				</xsl:if>
			</xsl:when>
			<xsl:otherwise>
				<xsl:for-each select="parent::node()">
					<xsl:call-template name="GetNearestAncestorStyleRecursive" />
				</xsl:for-each>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="GetAggregateLevel">
		<xsl:param name="node" />
		<xsl:param name="count" select="0" as="xs:double" />
		<xsl:variable name="style" as="xs:string*">
			<xsl:call-template name="GetNearestAncestorStyleRecursive">
				<xsl:with-param name="node" select="$node" />
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="newcount" as="xs:double">
			<xsl:choose>
				<!-- NB 11/8/2006 - added rules-item to node names to check -->
				<xsl:when test="      ($style != 'traditional' and $style != 'archaic' and (name(ancestor-or-self::node()[1])='section'))        and (descendant::continuation-text and       (($node[@display-inline = 'yes-display-inline'] or $node[@indent])       and (name($node) = 'section' or name($node) = 'subsection' or name($node) = 'paragraph' or name($node) = 'subparagraph'       or name($node) = 'rules-subparagraph' or name($node) = 'rules-subdivision' or name($node) = 'rules-paragraph' or name($node) = 'rules-item'       or name($node) = 'clause' or name($node) = 'subclause' or name($node) = 'item' or name($node) = 'subitem')))">
					<xsl:choose>
						<xsl:when test="$node[@indent] and contains($node[@indent], 'up')">
							<xsl:sequence select="$count + 1" />
						</xsl:when>
						<xsl:when test="$node[@indent] and contains($node[@indent], 'down')">
							<xsl:sequence select="$count - 1" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:sequence select="$count + 1" />
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<!-- NB 11/8/2006 - added rules-item to node names to check -->
				<xsl:when test="       $node[@indent] and (name($node) = 'section' or name($node) = 'subsection' or name($node) = 'paragraph'       or name($node) = 'subparagraph' or name($node) = 'rules-subparagraph' or name($node) = 'rules-subdivision' or name($node) = 'rules-paragraph' or name($node) = 'rules-item'       or name($node) = 'clause' or name($node) = 'subclause' or name($node) = 'item' or name($node) = 'subitem')">
					<xsl:sequence select="$count + number($node/@indent)" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:sequence select="$count" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:choose>
			<!-- NB 11/29/2006 - added subsection -->
			<xsl:when test="name($node) = 'section' or name($node) = 'subsection' or name($node) = 'quoted-block' or name($node) = 'legis-body' or name($node) = 'form' or name($node) = 'preamble' or name($node) = 'resolution-body' or name($node) = 'bill' or name($node) = 'resolution' or name($node) = 'amendment-doc' or not($node/..)">
				<xsl:sequence select="$newcount" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="GetAggregateLevel">
					<xsl:with-param name="node" select="$node/.." />
					<xsl:with-param name="count" select="$newcount" />
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section | subsection | paragraph | subparagraph | clause | subclause | item | subitem | rules-subparagraph | rules-subdivision | rules-paragraph | rules-item" mode="setIndentAttr">
		<xsl:variable name="level" as="xs:double">
			<xsl:call-template name="GetAggregateLevel">
				<xsl:with-param name="node" select="." />
			</xsl:call-template>
		</xsl:variable>
		<xsl:element name="{name()}">
			<xsl:call-template name="copy-all-attributes" />
			<xsl:if test="not(string(number($level)) = 'NaN')">
				<xsl:if test="not(number($level) = 0)">
					<xsl:attribute name="indent">
						<xsl:if test="number($level) &gt; 0">
							<xsl:text>up</xsl:text>
							<xsl:value-of select="$level" />
						</xsl:if>
						<xsl:if test="number($level) &lt; 0">
							<xsl:text>down</xsl:text>
							<xsl:value-of select="0 - number($level)" />
						</xsl:if>
					</xsl:attribute>
				</xsl:if>
			</xsl:if>
			<xsl:apply-templates mode="setIndentAttr" />
		</xsl:element>
	</xsl:template>                    

    <xsl:template match="@* | node()" mode="setStageAttr">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="setStageAttr" />
        </xsl:copy>
    </xsl:template><xsl:template match="element()" priority="24" mode="setStageAttr">
        <xsl:copy>
            <xsl:call-template name="setStageAttr">
                <xsl:with-param name="elementNode" select="." />
            </xsl:call-template>
            <xsl:apply-templates select="@* | node()" mode="setStageAttr" />
        </xsl:copy>

    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>' SM 12/04/06 Re-Enrolled-Bill is set to Enrolled-Bill 'since the output for both is
            the same.</desc>
        <param>An element node.</param>
        <return>An attribute node.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.Preprocess.PreProcess()</gpo:srcLxl>
    </doc><xsl:template name="setStageAttr" as="attribute()?">

        <xsl:param name="elementNode" as="element()" />

        <xsl:if test="$stageForParentFormat = 'Re-Enrolled-Bill'">
            <xsl:choose>
                <xsl:when test="name($documentElement) = 'bill'">
                    <xsl:attribute name="bill-stage" select="'Enrolled-Bill'" />
                </xsl:when>
                <xsl:when test="name($documentElement) = 'resolution'">
                    <xsl:attribute name="resolution-stage" select="'Enrolled-Bill'" />
                </xsl:when>
            </xsl:choose>

        </xsl:if>

    </xsl:template>

    <xsl:template match="@* | node()" mode="setCommitteeAddedDeletedDisplayStyleAttr">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="setCommitteeAddedDeletedDisplayStyleAttr" />
        </xsl:copy>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc> 'CAVEAT: The following section of code is based on an assumption for how
            'committee-ids work with added-display-style, deleted-display-style and 'other elements
            that have a changed attribute. This assumption has not yet 'been confirmed with the
            Senate or House. 'Whenever a committee-name element appears, the added-display-style and
            'deleted-display-style that are defined with that element should be used 'appropriately
            as the display styles for other elements that reference to this 'committee-name. The
            reference link is formed by the committee-id attribute that 'both committee-name has as
            well as any element that is wanting to use its styles. ' 'Therefore, anytime we find a
            committee-id attribute, it is either in a committee-name 'element (which means we should
            store the added- and deleted-display-style attributes) 'or we are not in a
            committee-name element (which means we need to let the XSLT know 'what the added- and
            deleted-display-style values are. To accomplish this we use a key. </desc>
        <param>An element node.</param>
        <return>An attribute node.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.Preprocess.PreProcess()</gpo:srcLxl>
    </doc>

    <xsl:template match="@* | node()" mode="setVbattParentFormatAttr">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="setVbattParentFormatAttr" />
        </xsl:copy>
    </xsl:template><xsl:template match="element()" priority="24" mode="setVbattParentFormatAttr">
        <xsl:copy>
            <xsl:call-template name="setVbattParentFormatAttr">
                <xsl:with-param name="elementNode" select="." />
            </xsl:call-template>
            <xsl:apply-templates select="@* | node()" mode="setVbattParentFormatAttr" />
        </xsl:copy>

    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>True() or false depending on whether the element name is contained in the list of
            element names that need parent format flag.</desc>
        <param>The element's name.</param>
        <return>True or false.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.Preprocess.PreProcess()</gpo:srcLxl>
    </doc><xsl:function name="gpo:needsParentFormatFlag" as="xs:boolean?">
        <xsl:param name="elementName" as="xs:string" />
        <xsl:variable name="elementsNeedFormatFlag" select="                 'toc',                 'legis-comment',                 'amendment-block',                 'quoted-block-continuation-text',                 'continuation-text',                 'list',                 'division',                 'subdivision',                 'chapter',                 'subchapter',                 'part',                 'subpart',                 'title',                 'subtitle',                 'section',                 'subsection',                 'paragraph',                 'subparagraph',                 'clause',                 'subclause',                 'item',                 'subitem',                 'list-item',                 'rule',                 'rules-clause',                 'rules-subparagraph',                 'rules-paragraph',                 'rules-subdivision',                 'rules-item',                 'rules-subitem',                 'rules-clause-header',                 'appropriations-major',                 'appropriations-intermediate',                 'appropriations-small'" />
        <xsl:sequence select="                 if ($elementName = $elementsNeedFormatFlag)                 then                     true()                 else                     false()" />
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>Addss attribute vbattParentFormat to element nodes.</desc>
        <desc>reported-display-style is only relevant when there is a populated changed attribute
            that is not set to "not-changed"</desc>
        <param>The element node.</param>
        <param>The @changed attribute of the element node.</param>
        <param>The @reported-display-style attribute element node.</param>
        <return>An attribute node.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.Preprocess.PreProcess()</gpo:srcLxl>
    </doc><xsl:template name="setVbattParentFormatAttr" as="attribute()?">
        <xsl:param name="elementNode" as="element()" />
        <xsl:variable name="attChanged" select="$elementNode/@changed" />
        <xsl:variable name="attStyle" select="$elementNode/@reported-display-style" />
        <xsl:variable name="inPreamble" select="                 if (name($elementNode) = 'preamble')                 then                     true()                 else                     false()" />

        <xsl:if test="gpo:needsParentFormatFlag(name($elementNode))">
            <xsl:choose>

                <xsl:when test="$inPreamble or ancestor::preamble">
                    <xsl:attribute name="vbattParentFormat">
                        <xsl:value-of select="'AddOrDelete'" />
                    </xsl:attribute>
                </xsl:when>

                <xsl:when test="$attChanged = 'not-changed'">
                    <xsl:attribute name="vbattParentFormat">
                        <xsl:value-of select="'AddOrDelete'" />
                    </xsl:attribute>
                </xsl:when>

                <xsl:when test="$attStyle and $attChanged != 'not-changed'">
                    <xsl:choose>
                        <xsl:when test="$attStyle = 'italic'">
                            <xsl:attribute name="vbattParentFormat">
                                <xsl:value-of select="'S6203'" />
                            </xsl:attribute>
                        </xsl:when>
                        <xsl:when test="$attStyle = 'strikethrough'">
                            <xsl:attribute name="vbattParentFormat">
                                <xsl:value-of select="'S6401'" />
                            </xsl:attribute>
                        </xsl:when>
                        <xsl:when test="$attStyle = 'boldface-roman'">
                            <xsl:attribute name="vbattParentFormat">
                                <xsl:value-of select="'S6202'" />
                            </xsl:attribute>
                        </xsl:when>
                        <xsl:when test="$attStyle = 'boldface-italic'">
                            <xsl:attribute name="vbattParentFormat">
                                <xsl:value-of select="'S6204'" />
                            </xsl:attribute>
                        </xsl:when>
                    </xsl:choose>
                </xsl:when>
                
                <!--

                <xsl:when test="starts-with($stageForParentFormat, 'Reported')">
                    <xsl:attribute name="vbattParentFormat">
                        <xsl:value-of select="'AddOrDelete'"/>
                    </xsl:attribute>
                </xsl:when>

                <xsl:when test="not($attChanged)">
                    <xsl:attribute name="vbattParentFormat">
                        <xsl:value-of select="'GetParentsFormat'"/>
                    </xsl:attribute>
                </xsl:when>
                
                -->

                <xsl:otherwise>
                    <xsl:attribute name="vbattParentFormat">
                        <xsl:value-of select="'AddOrDelete'" />
                    </xsl:attribute>
                </xsl:otherwise>
            </xsl:choose>

        </xsl:if>

    </xsl:template>    

    <xsl:template match="@* | node()" mode="setChangedForReportedAttr">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="setChangedForReportedAttr" />
        </xsl:copy>
    </xsl:template><xsl:template match="element()" priority="24" mode="setChangedForReportedAttr">
        <xsl:copy>
            <xsl:call-template name="setChangedForReportedAttr">
                <xsl:with-param name="elementNode" select="." />
            </xsl:call-template>
            <xsl:apply-templates select="@* | node()" mode="setChangedForReportedAttr" />
        </xsl:copy>

    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc> 'This section of preprocessing replaces a certain amount of navigating that used to
            be 'done by the XSLT named template "GetChangedForReported". </desc>
        <param>An element node.</param>
        <return>An attribute node.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.Preprocess.PreProcess()</gpo:srcLxl>
    </doc><xsl:template name="setChangedForReportedAttr" as="attribute()*">

        <xsl:param name="elementNode" as="element()" />

        <xsl:variable name="attChanged" select="                 if ($elementNode/@changed)                 then                     string($elementNode/@changed)                 else                     ()" />


        <xsl:choose>

            <xsl:when test="$attChanged">

                <xsl:choose>
                    <!-- changed 5/25/16 based on issue reported #78-->

                    <xsl:when test="$attChanged = 'changed'">
                        <xsl:attribute name="vbattDeletedDisplayStyle">
                            <xsl:value-of select="'strikethrough'" />
                        </xsl:attribute>
                    </xsl:when>
                    
                    <xsl:when test="$attChanged = 'deleted'">
                        <xsl:attribute name="vbattDeletedDisplayStyle">
                            <xsl:value-of select="'strikethrough'" />
                        </xsl:attribute>
                        <xsl:attribute name="vbattChangedForReported">
                            <xsl:value-of select="'strikethrough'" />
                        </xsl:attribute>
                    </xsl:when>
                    
                    <!-- end change -->


                    <xsl:when test="$attChanged = 'not-changed'">
                        <xsl:attribute name="vbattChangedForReported">
                            <xsl:value-of select="'not-changed'" />
                        </xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$elementNode/@reported-display-style">
                        <xsl:attribute name="vbattChangedForReported">
                            <xsl:value-of select="$elementNode/@reported-display-style" />
                        </xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="vbattChangedForReported">
                            <xsl:value-of select="''" />
                        </xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>

            </xsl:when>

            <xsl:when test="$elementNode/ancestor::element()[@changed]">

                <xsl:variable name="nearestAncestorWithAttChanged" select="($elementNode/ancestor::element()[@changed])[last()]" />

                <xsl:choose>
                    <xsl:when test="$nearestAncestorWithAttChanged/@changed = 'not-changed'">
                        <xsl:attribute name="vbattChangedForReported">
                            <xsl:value-of select="'not-changed'" />
                        </xsl:attribute>
                    </xsl:when>
                    <xsl:when test="$nearestAncestorWithAttChanged/@reported-display-style">
                        <xsl:attribute name="vbattChangedForReported">
                            <xsl:value-of select="$nearestAncestorWithAttChanged/@reported-display-style" />
                        </xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="vbattChangedForReported">
                            <xsl:value-of select="''" />
                        </xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>

            </xsl:when>

            <xsl:otherwise>
                <xsl:attribute name="vbattChangedForReported">
                    <xsl:value-of select="'not-changed'" />
                </xsl:attribute>
            </xsl:otherwise>

        </xsl:choose>

    </xsl:template>

    <xsl:template match="@* | node()" mode="setStyleAttr">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="setStyleAttr" />
        </xsl:copy>
    </xsl:template><xsl:template match="element()" priority="24" mode="setStyleAttr">
        <xsl:copy>
            <xsl:call-template name="setStyleAttr">
                <xsl:with-param name="elementNode" select="." />
            </xsl:call-template>
            <xsl:apply-templates select="@* | node()" mode="setStyleAttr" />
        </xsl:copy>

    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc> 'Preprocessing is responsible for making certain that the style/other-style
            attributes 'are populated on every element. The rule is that an element without a style
            gets the 'same style as its parent. The exception to this rule is if the element is has
            a 'quoted-block as its ancestor, in which case it should inherit the quoted-block's
            'style value(s). 'This portion of code is storing the style/other-style values in the
            lookupCopy for 'descendents to use. </desc>
        <desc>'The rule is, if the tag is within a quoted-block, it should use the qb's style (even
            if it has declared its own) 'othewise, the tag should use its own style. if it doesn't
            have one, then it should use its parents 'NB 7/12/2006 - wrapped this inside a check for
            mystyle - no need to overright if the thing has its own style</desc>
        <desc> 'If the style attribute is not populted, then it will be set either to the ancestor's
            'quoted-block style values or to the next nearest ancestor.</desc>
        <param>An element node.</param>
        <return>An attribute node.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.Preprocess.PreProcess()</gpo:srcLxl>
    </doc><xsl:template name="setStyleAttr" as="attribute()*">

        <xsl:param name="elementNode" as="element()" />

        <xsl:variable name="billStyle" as="xs:string?">
            <xsl:value-of select="/bill/@bill-type" />
        </xsl:variable>

        <xsl:choose>

            <xsl:when test="($elementNode/@style) and ($elementNode/@style != '')">
                <xsl:choose>
                    <xsl:when test="$elementNode/@style = 'order-of-business'">
                        <xsl:attribute name="style" select="'traditional'" />
                    </xsl:when>
                    <xsl:when test="$elementNode/@style != 'other'">
                        <xsl:attribute name="style" select="$elementNode/@style" />
                    </xsl:when>
                    <xsl:when test="$elementNode/@style = 'other'">
                        <xsl:attribute name="style" select="$elementNode/@other-style" />
                    </xsl:when>
                </xsl:choose>
            </xsl:when>

            <!-- This used to be first test 10/19/2015 -->
            <xsl:when test="($elementNode/ancestor::quoted-block/@style != '')">
                <xsl:sequence select="gpo:getNearestQuotedBlockAncestorStyle($elementNode)" />
            </xsl:when>


            <xsl:when test="($elementNode/ancestor::attestation) or ($elementNode/ancestor::endorsement) or ($elementNode/ancestor::official-title-amendment)">


                <xsl:choose>
                    <xsl:when test="/bill/legis-body[last()]/@style">
                        <xsl:attribute name="style" select="/bill/legis-body[last()]/@style" />
                    </xsl:when>
                    <xsl:when test="not($billStyle = '')">
                        <xsl:choose>

                            <xsl:when test="$billStyle = 'olc'">
                                <xsl:attribute name="style" select="'OLC'" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="style" select="$billStyle" />
                            </xsl:otherwise>
                        </xsl:choose>

                    </xsl:when>
                </xsl:choose>


                <!--xsl:if test="not($billStyle = '')">
                    <xsl:choose>

                        <xsl:when test="$billStyle = 'olc'">
                            <xsl:attribute name="style" select="'OLC'"/>
                        </xsl:when>
                        <xsl:when test="$billStyle = 'appropriations'">
                            <xsl:attribute name="style" select="'traditional-inline'"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="style" select="$billStyle"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>

                <xsl:if test="not($billStyle) or @billStyle = ''">
                    <xsl:if test="/bill/legis-body/@style">
                        <xsl:attribute name="style" select="/bill/legis-body/@style"/>
                    </xsl:if>
                </xsl:if-->

            </xsl:when>

            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$elementNode/ancestor::element()[@style != '']">
                        <xsl:attribute name="style" select="gpo:getNearestAncestorStyle($elementNode)" />
                    </xsl:when>
                    <xsl:otherwise>
                        <!-- No @style or @other-style found in ancestry -->
                        <xsl:if test="$elementNode/ancestor::legis-body">
                            <!-- Use default of OLC, but only if in legis-body -->
                            <xsl:if test="$billStyle = 'olc'">
                                <xsl:attribute name="style" select="'OLC'" />
                            </xsl:if>
                            <!--xsl:if
                                test="$elementNode/ancestor::subtitle[not(following-sibling::element())]">
                                <xsl:attribute name="style" select="'OLC'"/>
                            </xsl:if>
                            <xsl:if
                                test="$elementNode/ancestor::title[not(following-sibling::element())]">
                                <xsl:attribute name="style" select="'OLC'"/>
                            </xsl:if-->
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>
                <!--<xsl:if test="$elementNode/ancestor::element()[@style != '']">
                    <xsl:attribute name="style" select="gpo:getNearestAncestorStyle($elementNode)"/>
                </xsl:if>-->

            </xsl:otherwise>


        </xsl:choose>

    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>'If the style attribute is not populted, then it will be set either to the ancestor's
            'quoted-block style values or to the next nearest ancestor. </desc>
        <param>An element node.</param>
        <return>A string.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.Preprocess.PreProcess()</gpo:srcLxl>
    </doc><xsl:function name="gpo:getNearestQuotedBlockAncestorStyle" as="attribute()*">

        <xsl:param name="elementNode" as="element()" />

        <xsl:variable name="nearestQuotedBlockAncestor" select="($elementNode/ancestor::quoted-block)[last()]" />

        <xsl:choose>

            <xsl:when test="$nearestQuotedBlockAncestor/@style != ''">

                <xsl:if test="$nearestQuotedBlockAncestor/@style != 'other'">
                    <xsl:attribute name="style">
                        <xsl:sequence select="$nearestQuotedBlockAncestor/@style" />
                    </xsl:attribute>
                </xsl:if>

                <xsl:if test="$nearestQuotedBlockAncestor/@style = 'other'">
                    <xsl:attribute name="other-style">
                        <xsl:sequence select="$nearestQuotedBlockAncestor/@other-style" />
                    </xsl:attribute>
                    <xsl:attribute name="style">
                        <xsl:sequence select="$nearestQuotedBlockAncestor/@style" />
                    </xsl:attribute>
                </xsl:if>

            </xsl:when>
        </xsl:choose>

    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>'If the style attribute is not populted, then it will be set either to the ancestor's
            'quoted-block style values or to the next nearest ancestor. </desc>
        <param>An element node.</param>
        <return>A string.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.Preprocess.PreProcess()</gpo:srcLxl>
    </doc><xsl:function name="gpo:getNearestAncestorStyle" as="xs:string?">

        <xsl:param name="elementNode" as="element()" />

        <xsl:variable name="nearestAncestorWithStyle" select="($elementNode/ancestor::element()[@style != ''])[last()]" />

        <xsl:choose>

            <xsl:when test="$nearestAncestorWithStyle/@style != 'other'">
                <xsl:sequence select="$nearestAncestorWithStyle/@style" />
            </xsl:when>

            <xsl:when test="$nearestAncestorWithStyle/@style = 'other'">
                <xsl:sequence select="$nearestAncestorWithStyle/@other-style" />
            </xsl:when>
        </xsl:choose>

    </xsl:function>    

    <xsl:template match="@* | node()" mode="populateElementAttr">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="populateElementAttr" />
        </xsl:copy>
    </xsl:template><xsl:template match="element()" priority="24" mode="populateElementAttr">
        <xsl:copy>
            <xsl:call-template name="populateElementAttr">
                <xsl:with-param name="elementNode" select="." />
            </xsl:call-template>
            <xsl:apply-templates select="@* | node()" mode="populateElementAttr" />
        </xsl:copy>

    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>Add attributes to an element based on a lookup file. </desc>
        <param>An element node.</param>
        <return>One or more attribute nodes.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.ElementPopulator.PopulateElement()</gpo:srcLxl>
    </doc><xsl:template name="populateElementAttr" as="attribute()*">

        <xsl:param name="elementNode" as="element()" />
        <xsl:variable name="elementNodeName" select="name($elementNode)" />

        <!-- 
        Once we know the element needs handling, we need to find out what functions to do
            '         Sample from lookup.xml:
            '               <entry>
            '		            <name>italic</name>
            '		            <process>attributePopulation</process>
            '		            <keys>@headerInTextItalics</keys>
            '	            </entry>>
            '         We need to query the lookup file for the <keys> element when the 
            '         <name> element has the name of the element we are looking for (in this case, italic)
            '         and <process> has the string "attributePopulation"
        
        -->

        <xsl:if test="$elementNodeName = $lookupElementNames">

            <!-- 
            Once we've se the criteria, we need to find out what to do
            'This line now retrieves a string sequence from the lookup object. Each item in the sequence  
            'will be the contents from one <keys> element (which has siblings that match the above criteria)
            'Generally speaking, there should only be one, as multiple keys can be combined with semicolon
            'delimeters.
            -->


            <xsl:variable name="aKeys" select="$lookupXml//entry[process = 'attributePopulation' and name = $elementNodeName]/keys" />


            <!-- 
                    Now that we know what to do, we need to make the appropriate call
                     'All <keys> to date begin with a "@" symbol. 
              -->

            <xsl:for-each select="$aKeys">
                <xsl:sequence select="gpo:handleKeyFunction(., $elementNode)" />
            </xsl:for-each>

        </xsl:if>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>Adds attributes to element nodes. These attributes are used later in subsequent XSLT
            transforms.</desc>
        <param>The element node to be populated.</param>
        <return>A set of one or more attribute nodes.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.ElementPopulator.handleKeyFunction()</gpo:srcLxl>
    </doc><xsl:function name="gpo:handleKeyFunction" as="attribute()*">

        <!-- 
                'This method is called by populateElement when a <key> beginning with a "@" symbol has been found
        'Parameters:
        ' keys - a semicolon delimited string with the various functions to be performed
        ' node - the element to be modified
        -->

        <xsl:param name="keys" as="xs:string" />
        <xsl:param name="elementNode" as="element()" />

        <xsl:variable name="tokenizedKeys" select="tokenize($keys, ';')" />

        <xsl:for-each select="$tokenizedKeys">

            <!-- 
            'Each potential function gets a WHEN here and the node and lookup get passed to the 
            'key specific handle function.
            -->

            <xsl:choose>
                <xsl:when test=". = '@style'">
                    <xsl:sequence select="gpo:handleKeyFunction_Style($elementNode)" />
                </xsl:when>

                <xsl:when test=". = '@inlineheader'">
                    <xsl:sequence select="gpo:handleKeyFunction_InlineHeader($elementNode)" />
                </xsl:when>

                <xsl:when test=". = '@headerInTextItalics'">
                    <xsl:sequence select="gpo:handleKeyFunction_HeaderInTextItalics($elementNode)" />
                </xsl:when>

            </xsl:choose>
        </xsl:for-each>

    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>This method is called by handleKeyFunction to specifically handle the case where the
            keys 'value is @style</desc>
        <param>The element node to be populated.</param>
        <return>A set of one or more attribute nodes.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.ElementPopulator.handleKeyFunction_Style()</gpo:srcLxl>
    </doc><xsl:function name="gpo:handleKeyFunction_Style" as="attribute()*">

        <!-- 
        'This method is called by handleKeyFunction to specifically handle the case where the <keys>
        'value is @style
        'Parameters: 
        ' node - the element to be modified
        'Object:    to populate the vbattLocator and vbattFormat attributes. These
        '           attributes tell the XSLT what the bell codes are for the beginning of a level 
        '           tag (e.g., part, chapter, etc.)
        'Criteria:  Within a given <entry>, the following name/value pairs would be set
        '           1 - <process> = "LevelLocator"
        '           2 - <name> = the name of the element
        '           3 - <style> = the style or other-style (when style="other") of the <italic> element
        
        -->

        <xsl:param name="elementNode" as="element()" />
        <xsl:variable name="elementNodeName" select="name($elementNode)" />
        <xsl:variable name="myStyle" as="xs:string?">
            <xsl:choose>

                <xsl:when test="$elementNode/@style">

                    <xsl:if test="$elementNode/@style != 'other'">
                        <xsl:sequence select="$elementNode/@style" />
                    </xsl:if>

                    <xsl:if test="$elementNode/@style = 'other'">
                        <xsl:sequence select="$elementNode/@other-style" />
                    </xsl:if>
                </xsl:when>

            </xsl:choose>

        </xsl:variable>


        <xsl:variable name="levelLocatorLookupStyles" select="$lookupXml//entry[process = 'LevelLocator' and name = $elementNodeName]/style" />


        <xsl:variable name="myNewStyle" as="xs:string?">
            <xsl:choose>
                <xsl:when test="$myStyle = $levelLocatorLookupStyles">
                    <xsl:sequence select="$myStyle" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="'#default#'" />
                </xsl:otherwise>
            </xsl:choose>

        </xsl:variable>

        <xsl:variable name="levelLocatorCriteriaLookup" select="$lookupXml//entry[process = 'LevelLocator' and name = $elementNodeName and style = $myNewStyle]" />

        <xsl:sequence select="gpo:performLookup($elementNode, $levelLocatorCriteriaLookup)" />

    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>This method is called by handleKeyFunction to specifically handle the case where the
            keys 'value is @inlineHeader.</desc>
        <param>The element node to be populated.</param>
        <return>A set of one or more attribute nodes.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.ElementPopulator.handleKeyFunction_InlineHeader()</gpo:srcLxl>
    </doc><xsl:function name="gpo:handleKeyFunction_InlineHeader" as="attribute()*">

        <!-- 
        'This method is called by handleKeyFunction to specifically handle the case where the <keys>
        'value is @inlineHeader
        'Parameters: 
        ' node - the element to be modified
        'Object:    to populate the vbattGrid, vbattTypeface, and vbattMode attributes. These
        '           attributes help the XSLT know what the bell codes are for a <header-in-text>
        'Criteria:  Within a given <entry>, the following name/value pairs would be set
        '           1 - <process> = "InlineHeader"
        '           2 - <name> = the level attribute of the <header-in-text> element
        '           3 - <style> = the style or other-style (when style="other") of the <italic> element
        
        -->

        <xsl:param name="elementNode" as="element()" />
        <xsl:variable name="elementNodeName" select="name($elementNode)" />
        <xsl:variable name="myStyle" as="xs:string?">
            <xsl:choose>


                <xsl:when test="$elementNode/@style">

                    <xsl:if test="$elementNode/@style != 'other'">
                        <xsl:sequence select="$elementNode/@style" />
                    </xsl:if>

                    <xsl:if test="$elementNode/@style = 'other'">
                        <xsl:sequence select="$elementNode/@other-style" />
                    </xsl:if>
                </xsl:when>

            </xsl:choose>

        </xsl:variable>



        <xsl:variable name="myLevel" as="xs:string?">
            <xsl:choose>
                <xsl:when test="$elementNode/@level != ''">
                    <xsl:sequence select="$elementNode/@level" />
                </xsl:when>
                <xsl:when test="($elementNode/@level = '') and ($myStyle = 'archaic-paragraph')">
                    <xsl:if test="name($elementNode/parent::element()) = 'quote'">
                        <xsl:sequence select="'parent=quote'" />
                    </xsl:if>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="'section'" />
                </xsl:otherwise>
            </xsl:choose>



        </xsl:variable>


        <!--
        <entry>
		  <name>header-in-text</name>
		  <process>attributePopulation</process>
		  <keys>@inlineheader</keys>
	    </entry>
	
	-->


        <xsl:variable name="inlineHeaderLookupStyles" select="$lookupXml//entry[process = 'InlineHeader' and name = $myLevel]/style" />


        <xsl:variable name="myNewStyle" as="xs:string?">
            <xsl:choose>
                <xsl:when test="$myStyle = $inlineHeaderLookupStyles">
                    <xsl:sequence select="$myStyle" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="'#default#'" />
                </xsl:otherwise>
            </xsl:choose>

        </xsl:variable>

        <xsl:variable name="inlineHeaderCriteriaLookup" select="$lookupXml//entry[process = 'InlineHeader' and name = $myLevel and style = $myNewStyle]" />

        <xsl:sequence select="gpo:performLookup($elementNode, $inlineHeaderCriteriaLookup)" />

    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>This method is called by handleKeyFunction to specifically handle the case where the
            keys 'value is @headerInTextItalics.</desc>
        <param>The element node to be populated.</param>
        <return>A set of one or more attribute nodes.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.ElementPopulator.handleKeyFunction_HeaderInTextItalics()</gpo:srcLxl>
    </doc><xsl:function name="gpo:handleKeyFunction_HeaderInTextItalics" as="attribute()*">

        <!-- 
        'This method is called by handleKeyFunction to specifically handle the case where the <keys>
        'value is @headerInTextItalics
        'Parameters: 
        ' node - the element to be modified
        'Object:    to populate the vbattItalicFormatBegin and vbattItalicFormatEnd attributes. These
        '           attributes help the XSLT know what the begin/end bell codes are for <italic> appearing
        '           within a <header-in-text>
        'Criteria:  Within a given <entry>, the following name/value pairs would be set
        '           1 - <process> = "InlineHeaderItalics"
        '           2 - <name> = the level attribute of the <header-in-text> parent of the <italic> element
        '           3 - <style> = the style or other-style (when style="other") of the <italic> element
        
        -->

        <xsl:param name="elementNode" as="element()" />
        <xsl:variable name="elementNodeName" select="name($elementNode)" />
        <xsl:variable name="myStyle" as="xs:string?">
            <xsl:choose>

                <xsl:when test="$elementNode/@style">

                    <xsl:if test="$elementNode/@style != 'other'">
                        <xsl:sequence select="$elementNode/@style" />
                    </xsl:if>

                    <xsl:if test="$elementNode/@style = 'other'">
                        <xsl:sequence select="$elementNode/@other-style" />
                    </xsl:if>
                </xsl:when>

            </xsl:choose>

        </xsl:variable>




        <xsl:variable name="eParent" select="$elementNode/parent::element()" />

     

        <xsl:variable name="myLevel" select="                 if ($eParent/@level != '')                  then                     $eParent/@level                 else                     ''" />

        <xsl:variable name="inlineHeaderItalicsLookupStyles" select="$lookupXml//entry[process = 'InlineHeaderItalics' and name = $myLevel]/style" />

        <xsl:variable name="myNewStyle" as="xs:string?">
            <xsl:choose>
                <xsl:when test="$myStyle = $inlineHeaderItalicsLookupStyles">
                    <xsl:sequence select="$myStyle" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="'#default#'" />
                </xsl:otherwise>
            </xsl:choose>

        </xsl:variable>


        <xsl:variable name="InlineHeaderItalicsCriteriaLookup" select="$lookupXml//entry[process = 'InlineHeaderItalics' and name = $myLevel and style = $myNewStyle]" />

        <xsl:sequence select="gpo:performLookup($elementNode, $InlineHeaderItalicsCriteriaLookup)" />

    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>This method gets called by each of the specialized handleKeyFunction_XXXXX methods. At
            the 'time that it is called, it is assumed that the method calling this one has set the
            criteria 'on the xmlLookupFile and that the entry elements set by those criteria will
            all contain a 'attributenames child as well as a matching attributevalues child.</desc>
        <param>The element node to be populated.</param>
        <return>A set of one or more attribute nodes.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.ElementPopulator.performLookup()</gpo:srcLxl>
    </doc><xsl:function name="gpo:performLookup" as="attribute()*">

        <xsl:param name="elementNode" as="element()" />
        <xsl:param name="lookup" as="element()*" />

        <xsl:variable name="aResultNames" select="tokenize($lookup/attributenames, ';')" />

        <xsl:variable name="eResultNames" select="tokenize($lookup/attributevalues, ';')" />

        <!-- 
        
        'If there are no names or no values, then there is nothing to do, exit.
        
        'Since there are an equal number of names vs values (or it would have exited in the last IF),
        'iterate through the list and assign the value through updateAttributes
        
        -->

        <xsl:choose>
            <xsl:when test="count($aResultNames) eq count($eResultNames)">
                <xsl:sequence select="                         for $i in 1 to count($aResultNames)                         return                             gpo:updateAttributes($elementNode, $aResultNames[$i], $eResultNames[$i])" />
            </xsl:when>
            <xsl:otherwise> </xsl:otherwise>
        </xsl:choose>

    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>This method gets called by performLookup. Its job is to analyze the attribute names
            and 'values it has been passed and arrange for the appropriate value to be set to the
            attribute. 'Typically, the value is whatever string the attribute value is. Unless it
            begins with a "@", in 'which case the attribute value is a function indicating that
            special logic should be applied.</desc>
        <param>The element node to be populated.</param>
        <param>A semicolon delimited string with the attribute names to be set.</param>
        <param>A semicolon delimited string with the attribute values to be set.</param>
        <return>A set of one or more attribute nodes.</return>
        <gpo:srcLxl>GPO.Lexa.Transform.ElementPopulator.updateAttributes()</gpo:srcLxl>
    </doc><xsl:function name="gpo:updateAttributes" as="attribute()*">

        <xsl:param name="elementNode" as="element()" />
        <xsl:param name="attributeName" as="xs:string" />
        <xsl:param name="attributeValue" as="xs:string" />

        <xsl:variable name="newAttributeValue" as="xs:string?">
            <xsl:choose>
                <xsl:when test="$attributeName = 'vbattGrid' and $attributeValue = 'G2'">
                    <xsl:sequence select="                             if (lower-case($stageForParentFormat) = 'enrolled-bill')                             then                                 'G3'                             else                                 'G2'" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="$attributeValue" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="starts-with($attributeValue, '@')">
                <xsl:sequence select="gpo:handleAttributeValueFunction($elementNode, $attributeName, $attributeValue)" />
            </xsl:when>
            <xsl:otherwise>

                <xsl:call-template name="addAttribute">
                    <xsl:with-param name="elementNode" select="$elementNode" />
                    <xsl:with-param name="attributeName" select="$attributeName" />
                    <xsl:with-param name="attributeValue" select="$newAttributeValue" />
                </xsl:call-template>

            </xsl:otherwise>

        </xsl:choose>

    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>This function gets called by updateAttributes. Its job is to analyze the attribute
            value function 'specified and determine what the value of the attribute should be. This
            gets called when the 'attributevalues within an entry has an attribute value beginning
            with "@"</desc>
        <param>The attribute names to be set.</param>
        <return>The string beginning with a "@".</return>
        <gpo:srcLxl>GPO.Lexa.Transform.ElementPopulator.handleAttributeValueFunction()</gpo:srcLxl>
    </doc><xsl:function name="gpo:handleAttributeValueFunction" as="attribute()*">

        <xsl:param name="elementNode" as="element()" />
        <xsl:param name="attributeName" as="xs:string" />
        <xsl:param name="attributeValue" as="xs:string" />

        <xsl:choose>
            <xsl:when test="$attributeValue = '@AllLower/FirstWord'">
                <xsl:choose>
                    <xsl:when test="substring(normalize-space($elementNode), 1, 1) = lower-case(substring(normalize-space($elementNode), 1, 1))">

                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'AllLower'" />
                            <xsl:with-param name="attributeName" select="$attributeName" />
                        </xsl:call-template>

                    </xsl:when>
                    <xsl:otherwise>

                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'FirstWord'" />
                            <xsl:with-param name="attributeName" select="$attributeName" />
                        </xsl:call-template>

                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$attributeValue = '@TraditionalSectionTypeface'">
                <xsl:choose>
                    <xsl:when test="$documentElement/@amend-type = 'house-amendment'">

                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'G1'" />
                            <xsl:with-param name="attributeName" select="'vbattGrid'" />
                        </xsl:call-template>

                    </xsl:when>
                    <xsl:otherwise>

                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'T#'" />
                            <xsl:with-param name="attributeName" select="$attributeName" />
                        </xsl:call-template>

                    </xsl:otherwise>
                </xsl:choose>

            </xsl:when>
            <xsl:when test="$attributeValue = '@Grid'">
                <xsl:choose>
                    <xsl:when test="$documentElement/@bill-stage = 'Enrolled-Bill'">
                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'G3'" />
                            <xsl:with-param name="attributeName" select="'vbattGrid'" />
                        </xsl:call-template>
                    </xsl:when>

                    <xsl:when test="$documentElement/@amend-type = 'conference-report'">
                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'G4'" />
                            <xsl:with-param name="attributeName" select="'vbattGrid'" />
                        </xsl:call-template>
                    </xsl:when>

                    <xsl:when test="name($documentElement) = 'resolution'">
                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'G3'" />
                            <xsl:with-param name="attributeName" select="'vbattGrid'" />
                        </xsl:call-template>
                    </xsl:when>

                    <xsl:otherwise>

                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'G2'" />
                            <xsl:with-param name="attributeName" select="'vbattGrid'" />
                        </xsl:call-template>

                    </xsl:otherwise>
                </xsl:choose>

            </xsl:when>
            <xsl:when test="$attributeValue = '@Typeface'">
                <xsl:choose>
                    <xsl:when test="$documentElement/@amend-type = 'conference-report'">
                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'T2'" />
                            <xsl:with-param name="attributeName" select="'vbattTypeface'" />
                        </xsl:call-template>
                    </xsl:when>

                    <xsl:otherwise>

                        <xsl:call-template name="addAttribute">
                            <xsl:with-param name="elementNode" select="$elementNode" />
                            <xsl:with-param name="attributeValue" select="'T1'" />
                            <xsl:with-param name="attributeName" select="'vbattTypeface'" />
                        </xsl:call-template>

                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="addAttribute">
                    <xsl:with-param name="elementNode" select="$elementNode" />
                    <xsl:with-param name="attributeValue" select="$attributeValue" />
                    <xsl:with-param name="attributeName" select="$attributeName" />
                </xsl:call-template>

            </xsl:otherwise>

        </xsl:choose>

    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl">
        <desc>Adds attributes to element nodes. These attributes are used later in subsequent XSLT
            transforms.</desc>
        <param>The element node to be populated.</param>
        <return>A set of one or more attribute nodes.</return>
    </doc><xsl:template name="addAttribute" as="attribute()*">
        <xsl:param name="elementNode" as="element()" />
        <xsl:param name="attributeName" as="xs:string?" />
        <xsl:param name="attributeValue" as="xs:string?" />
        <xsl:for-each select="$elementNode">
            <xsl:attribute name="{$attributeName}" select="$attributeValue" />
        </xsl:for-each>
    </xsl:template>

    <xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov" scope="stylesheet">
        <xd:desc>
            <xd:p><xd:b>Created on:</xd:b> May 10, 2016</xd:p>
            <xd:p><xd:b>Author:</xd:b> mharcourt</xd:p>
            <xd:p />
        </xd:desc>
    </xd:doc><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="@* | node()" mode="calsTables">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="calsTables" />
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="a-v" />
        <xd:return />
    </xd:doc><xsl:function xmlns:gpo="http://www.gpo.gov" name="gpo:getActualWidth" as="xs:string">
        <xsl:param name="a-v" as="xs:string?" />
        <xsl:choose>
            <xsl:when test="$a-v='1' or $a-v='0'">
                <xsl:value-of select="$a-v" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>0</xsl:text>
            </xsl:otherwise>
        </xsl:choose>    
    </xsl:function><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="oldColnames" />
        <xd:param name="colname2compare" />
        <xd:return />
    </xd:doc><xsl:function xmlns:gpo="http://www.gpo.gov" name="gpo:getCnumByCname" as="xs:string">
        <xsl:param name="oldColnames" as="xs:string+" />
        <xsl:param name="colname2compare" as="xs:string" />
        <xsl:value-of select="index-of(tokenize($oldColnames,' '),$colname2compare)" />
    </xsl:function><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="tbl" />
        <xd:return />
    </xd:doc><xsl:function xmlns:gpo="http://www.gpo.gov" name="gpo:getColspecPIs" as="processing-instruction()*">
        <xsl:param name="tbl" as="element(table)" />
        <xsl:variable name="colspecPIs" as="processing-instruction()*">
            <xsl:choose>
                <xsl:when test="($tbl/@frame='all' and $tbl/@line-rules='all-gen' and                      $tbl/@rule-weights='4.4.4.4.0.0') or                      ($tbl/@frame='all' and $tbl/@line-rules='hor-ver' and                      $tbl/@rule-weights='4.4.4.4.0.0') or                      ($tbl/@frame='topbot' and $tbl/@line-rules='hor-ver' and                      $tbl/@rule-weights=('4.4.4.0.0.0','4.4.4.4.0.0','4.4.4.0.0.17')) or                      ($tbl/@frame='topbot' and $tbl/@line-rules='hor' and                      $tbl/@rule-weights='4.4.4.0.0.0') or                      ($tbl/@frame='none' and $tbl/@line-rules='no-gen' and                      $tbl/@rule-weights='0.0.0.0.0.0')">
                    <xsl:processing-instruction name="xpp">setrul;col</xsl:processing-instruction>
                </xsl:when>
                
                <xsl:when test="($tbl/@frame='topbot' and $tbl/@line-rules='no-gen' and                      $tbl/@rule-weights=('4.0.4.0.0.0','4.0.4.0.0.17')) or                      ($tbl/@frame='topbot' and $tbl/@line-rules='hor-ver' and                      $tbl/@rule-weights='4.0.4.0.0.17')">
                    <xsl:processing-instruction name="xpp">setrul;col</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">setrul;row</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">setbrul;allbox;0</xsl:processing-instruction>
                </xsl:when>
                
                <xsl:when test="($tbl/@frame='none' and $tbl/@line-rules='no-gen' and                      $tbl/@rule-weights=('4.4.4.0.0.0','4.4.4.4.0.0','0.0.0.4.0.17',                     '0.0.0.0.0.17','0.0.0.0.0.0','0.0.0.0.0.4'))">
                    <xsl:processing-instruction name="xpp">setrul;col</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">setrul;row</xsl:processing-instruction>
                </xsl:when>
                
                <xsl:when test="($tbl/@frame='none' and $tbl/@line-rules='no-gen' and                      $tbl/@rule-weights='0.0.0.4.0.0')">
                    <xsl:processing-instruction name="xpp">chgboth;xbrule</xsl:processing-instruction>
                </xsl:when>
                
                <xsl:when test="($tbl/@frame='none' and $tbl/@line-rules='hor' and                      $tbl/@rule-weights='0.1.0.0.0.4')">
                    <xsl:processing-instruction name="xpp">setrowh;1;urule;1</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('setrowh;',count($tbl/tgroup/colspec),';hrule;1')" /></xsl:processing-instruction>
                </xsl:when>
                
                <xsl:when test="($tbl/@frame='top' and $tbl/@line-rules='hor-ver' and                      $tbl/@rule-weights='4.4.0.0.0.17')">
                    <xsl:processing-instruction name="xpp">setbrul;allbox;0</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">setrul;row</xsl:processing-instruction>
                </xsl:when>
                
                <xsl:when test="(not($tbl/@frame) or $tbl/@frame='') and                      $tbl/@line-rules='no-gen' and                      $tbl/@rule-weights='4.4.4.4.4.17'">
                    <xsl:processing-instruction name="xpp">setrul;col</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">setrul;row</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">setbrul;allbox;0</xsl:processing-instruction>
                </xsl:when>
                
                <xsl:when test="(not($tbl/@frame) or $tbl/@frame='') and                      $tbl/@line-rules='all-gen' and                      $tbl/@rule-weights='4.4.4.4.4.17'">
                </xsl:when>
                
                <xsl:when test="(not($tbl/@frame) or $tbl/@frame='') and                      $tbl/@line-rules='no-gen' and                      $tbl/@rule-weights='0.0.0.4.0.0'">
                    <xsl:processing-instruction name="xpp">chgboth;xbrule</xsl:processing-instruction>
                </xsl:when>
                
                <xsl:when test="($tbl/@frame=('all') and $tbl/@line-rules='all-gen' and                      $tbl/@rule-weights=('4.4.4.4.4.0','4.4.4.4.4.17','4.4.4.0.4.0',                     '4.1.4.0.1.4','4.4.4.0.4.17','4.4.4.4.4.4')) or                      ($tbl/@frame='topbot' and $tbl/@line-rules='hor-ver' and                      $tbl/@rule-weights=('4.4.4.4.4.0','4.4.4.4.4.17',                     '4.4.4.0.4.0','4.4.4.0.4.17')) or                     ($tbl/@frame='none' and $tbl/@line-rules='hor-ver' and                      $tbl/@rule-weights=('0.0.0.0.4.17','0.0.0.4.4.0')) or                      ($tbl/@frame='none' and $tbl/@line-rules='no-gen' and                      $tbl/@rule-weights=('0.0.0.4.4.0','0.0.0.0.4.17'))">
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:sequence select="$colspecPIs" />
    </xsl:function><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="blb" />
        <xd:param name="stage" />
    </xd:doc><xsl:function xmlns:gpo="http://www.gpo.gov" name="gpo:getBlank-lines-before">
        <xsl:param name="blb" as="xs:string" />
        <xsl:param name="stage" as="xs:string" />
        <xsl:variable name="colspecPI" as="processing-instruction()*">
            <xsl:choose>
                <xsl:when test="$stage='Enrolled-Bill'">
                    <xsl:choose>
                        <xsl:when test="$blb='0'"><xsl:processing-instruction name="xpp">lp;&amp;7q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='1' or $blb=''"><xsl:processing-instruction name="xpp">lp;&amp;11q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='2'"><xsl:processing-instruction name="xpp">lp;&amp;15q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='3'"><xsl:processing-instruction name="xpp">lp;&amp;19q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='4'"><xsl:processing-instruction name="xpp">lp;&amp;23q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='5'"><xsl:processing-instruction name="xpp">lp;&amp;27q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='6'"><xsl:processing-instruction name="xpp">lp;&amp;31q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='7'"><xsl:processing-instruction name="xpp">lp;&amp;35q</xsl:processing-instruction></xsl:when>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:choose>
                        <xsl:when test="$blb='0'"><xsl:processing-instruction name="xpp">lp;&amp;-6q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='1' or $blb=''"><xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='2'"><xsl:processing-instruction name="xpp">lp;&amp;14q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='3'"><xsl:processing-instruction name="xpp">lp;&amp;24q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='4'"><xsl:processing-instruction name="xpp">lp;&amp;34q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='5'"><xsl:processing-instruction name="xpp">lp;&amp;44q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='6'"><xsl:processing-instruction name="xpp">lp;&amp;54q</xsl:processing-instruction></xsl:when>
                        <xsl:when test="$blb='7'"><xsl:processing-instruction name="xpp">lp;&amp;64q</xsl:processing-instruction></xsl:when>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:sequence select="$colspecPI" />
    </xsl:function><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="oldColspecNames" />
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="table" mode="calsTables">
        <!-- 03/10/2016 mharcourt Rewrote assignment to handle cases where 
            optional <colspec> node is omitted. -->
        <!-- 04/19/2016 mharcourt Added support for XSpec testing when @colname 
            is not specified in <colspec> tag per request by tanastasiou -->
        <xsl:param name="oldColspecNames" tunnel="yes" as="xs:string">
            <xsl:choose>
                <xsl:when test="tgroup/colspec">
                    <xsl:value-of select="for $i in (1 to count(tgroup/colspec)) return                         if(tgroup/colspec[$i]/@colname) then tgroup/colspec[$i]/@colname/string() else concat('column',$i)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:choose>
                        <xsl:when test="tgroup/tbody/row[1]/entry[1]/@colname">
                            <xsl:value-of select="for $i in (1 to count(tgroup/tbody/row[1]/entry)) return if(tgroup/tbody/row[1]/entry[$i]/@colname) then                                 tgroup/tbody/row[1]/entry[$i]/@colname/string()  else concat('column',$i)" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="for $i in (1 to xs:integer(tgroup/@cols)) return                                 concat('column',$i)" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:param> 
        
        <!-- 03/14/2016 mhacourt Added support to create tunnel variable 
            for colwidthPrefix parameter for use in colspec @colwidth -->
        <xsl:variable name="coldefValues" as="xs:string">
            <xsl:value-of select="for $i in (1 to count(tgroup/colspec)) return                 tgroup/colspec[$i]/@coldef/string()" />
        </xsl:variable>
        
        <xsl:variable name="modifyColwidth" as="xs:string">
            
            <xsl:choose>
                <xsl:when test="matches($coldefValues,'^(fig\s?)+$')">
                    <xsl:text>*+</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:variable name="inQuotedBlock" as="xs:integer">
            <xsl:choose>
                <xsl:when test="not(ancestor::quoted-block)"><xsl:value-of select="0" /></xsl:when>
                <xsl:when test="count(ancestor::quoted-block) = 1"><xsl:value-of select="1" /></xsl:when>
                <xsl:otherwise><xsl:value-of select="2" /></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:element name="{local-name()}">
            <xsl:variable name="frame">
                <xsl:choose>
                    <xsl:when test="((not(@frame) or @frame='') and @line-rules='no-gen' and @rule-weights='4.4.4.4.4.17') or                         ((not(@frame) or @frame='') and @line-rules='all-gen' and @rule-weights='4.4.4.4.4.17') or                         ((not(@frame) or @frame='') and @line-rules='no-gen' and @rule-weights='0.0.0.4.0.0')">
                        <xsl:text>all</xsl:text>
                    </xsl:when>
                    <xsl:when test="@frame">
                        <xsl:value-of select="@frame" />
                    </xsl:when>
                    <xsl:otherwise />
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="$frame != ''">
                <xsl:attribute name="frame" select="$frame" />
            </xsl:if>
            <!-- 02/16/2016 mharcourt Added @rowsep to create rowsep="0" when no @rowsep is specified -->
            <xsl:attribute name="rowsep">
                <xsl:choose>
                    <xsl:when test="not(normalize-space(@rowsep))">
                        <xsl:text>0</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="normalize-space(@rowsep)" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
            <xsl:copy-of select="@colsep, @* except (@frame, @colsep, @rowsep, @align-to-level,                  @blank-lines-after, @blank-lines-before, @changed, @charoff, @committee-id, @line-rules, @pgwide,                 @reported-display-style, @rule-weights, @subformat, @table-template-name, @table-type)" />
            <xsl:apply-templates select="*|node()" mode="calsTables">
                <xsl:with-param name="oldColspecNames" select="$oldColspecNames" tunnel="yes" />
                <xsl:with-param name="colwidthPrefix" select="$modifyColwidth" as="xs:string" tunnel="yes" /><!-- 03/14/2016 mhacourt Added colwidthPrefix parameter -->
                <xsl:with-param name="inQB" select="$inQuotedBlock" tunnel="yes" as="xs:integer" />
            </xsl:apply-templates>
        </xsl:element>
        <!-- 01/04/2016 mharcourt Added empty para node per email this date from Deb Galligan to have XPP put space below each table -->
        <!-- 03/17/2016 mharcourt - After discussion with rest of team, 
            commented this out and let process stage handle this -->
        <!-- <para format="6999" loc="20"/>-->
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="actualWidth" />
        <xd:param name="tfoot" />
        <xd:param name="thead-tbody-ldg-size" />
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="tgroup" mode="calsTables">
        <xsl:param name="actualWidth" as="xs:string?" select="gpo:getActualWidth(./normalize-space(@actual-width))" tunnel="yes" />
        
        <xsl:param name="tfoot" select="tfoot" as="element()?" tunnel="yes" />
        
        <!-- 01/07/2016 mharcourt - Supplied default values for non-specified attribute
            @thead-tbody-ldg-size to fix bug caused if null value is supplied as a 
            function parameter when the tunnel variable is evaluated in template 
            match="colspec". Per conversation with Joe Butrim this date: 
            1) Supply '8.8.0' if /bill/@bill-stage='Enrolled-Bill'
            2) Supply '10.10.2' for any other value of @bill-stage -->
        <!-- 04/13/2016 mharcourt - Expanded conditional to account 
            for other document types besides bills only. -->
        <!-- 04/15/2016 mharcourt - Changed coding to use xsl:choose so NAN 
            non-numeric value can be handled properly. -->
        <xsl:param name="thead-tbody-ldg-size" as="xs:string" tunnel="yes">
            <xsl:choose>
                <xsl:when test="normalize-space(@thead-tbody-ldg-size) != ''">
                    <xsl:variable name="thisValue" select="normalize-space(@thead-tbody-ldg-size)" as="xs:string" />
                    <xsl:variable name="secondValue" select="tokenize($thisValue,'\.')[2]" as="xs:string" />
                    <xsl:choose>
                        <!-- 04/18/2016 tanastasiou - Replaced count($thisValue[contains(., '.')]) = 2 with count(tokenize($thisValue, '\.'))-1 = 2 -->
                        <xsl:when test="count(tokenize($thisValue, '\.'))-1 = 2 and                              number($secondValue) = number($secondValue)"><!-- Whenever $secondValue cannot be used as a number, then number($secondValue) is NaN and NaN is not equal to any other value, even to itself. -->
                            <xsl:value-of select="$thisValue" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message>Markup Error: Unexpected non-numeric @thead-tbody-ldg-size value
                                supplied. Value must be numeric. Specified value was: <xsl:value-of select="$thisValue" />. 
                                Transformation will use a default value based on the 
                                document stage. Check the output and revise XML file as 
                                necessary to correct formatting for this table.</xsl:message>
                            <xsl:choose>
                                <xsl:when test="/bill/normalize-space(@bill-stage) = 'Enrolled-Bill' or                                      /resolution/normalize-space(@resolution-stage) = 'Enrolled-Bill' or                                      /amendment-doc/normalize-space(@amend-stage) = 'Enrolled-Bill'">
                                    <xsl:text>8.8.0</xsl:text>  
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:text>10.10.2</xsl:text>  
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:choose>
                        <xsl:when test="/bill/normalize-space(@bill-stage) = 'Enrolled-Bill' or                              /resolution/normalize-space(@resolution-stage) = 'Enrolled-Bill' or                              /amendment-doc/normalize-space(@amend-stage) = 'Enrolled-Bill'">
                          <xsl:text>8.8.0</xsl:text>  
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>10.10.2</xsl:text>  
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:param>
        
        <!-- mharcourt 04/14/2016 Revised this extensively -->
        <!-- mharcourt 05/12/2016 Added xsl:choose block for case when final row of revised 
            table is going to be in a tfoot element rather than in the tbody element -->
        <xsl:variable name="lastEntry" as="node()">
            <xsl:choose>
                <xsl:when test="count($tfoot[element()]) &gt; 0">
                    <xsl:value-of select="$tfoot/row[last()]/entry[last()]" /> 
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="tbody/row[last()]/entry[last()]" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="reversedStr" select="if (normalize-space(string-join($lastEntry,',')) != '')              then gpo:reverse(normalize-space(string-join($lastEntry,','))) else ''" as="xs:string" />
        <xsl:variable name="finalPunctuations" as="xs:string">
            <xsl:choose>
                <!-- Match on reversed string starting with one or 
                    more regex Punctuation character category characters 
                    (after subtracting "%" character from the match) -->
                <xsl:when test="matches($reversedStr,'^[\p{P}-[%]]+')">
                    <!-- tokenize() with the COMPLEMENT of the regex Punctuation 
                        character category characters (minus "%") on the 
                        reversed string and then reverse the resulting first 
                        sequence of characters -->
                    <xsl:value-of select="gpo:reverse(tokenize($reversedStr,'[\P{P}-[%]]+')[1])" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <!-- 02/16/2016 mharcourt Created new variable to save final punctuation characters
            and pass the variable as a tunnel parameter for use in <entry> -->
        <xsl:variable name="finalPunctuation" as="xs:string">
            <xsl:choose>
                <xsl:when test="colspec[last()]/normalize-space(@coldef)='fig' and                     string-length($finalPunctuations) &gt; 0">
                    <xsl:value-of select="$finalPunctuations" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <!-- 2/23/2016 mharcourt Fixed bugs reported this date by Betty Harvey -->
        <xsl:variable name="style" select="if (/bill/legis-body[last()]/@style) then /bill/legis-body[last()]/normalize-space(@style) else              if (/resolution/resolution-body[last()]/@style) then /resolution/resolution-body[last()]/normalize-space(@style) else              if (/amendment-doc[last()]/@style) then /amendment-doc[last()]/normalize-space(@style) else 'OLC'" as="xs:string" />
        <!-- 05/12/2016 mharcourt Removed unnecessary if() conditional because second item of 
            $thead-tbody-ldg-size was constrained to be be numeric when initialized -->
        <xsl:variable name="qValue" select="tokenize($thead-tbody-ldg-size,'\.')[2]" as="xs:string" />
        <xsl:variable name="contextElement" select="ancestor::table" as="element()" />
        
        <!-- 02/24/2016 mharcourt Fixed bug reported yesterday by Betty Harvey for empty 
            sequence not allowed for $allBoxGutterPIs variable by changing occurrence  
            indicator from + to * -->
        <xsl:variable name="allBoxGutterPIs" as="processing-instruction()*">
            <xsl:call-template name="getBoxGutterPIs">
                <xsl:with-param name="style" select="$style" as="xs:string" tunnel="yes" />
                <xsl:with-param name="qValue" select="$qValue" as="xs:string" tunnel="yes" />
                <xsl:with-param name="contextElement" select="$contextElement" as="element()" tunnel="yes" />
            </xsl:call-template>
        </xsl:variable>
        
        <xsl:variable name="l1" as="processing-instruction()?">
            <xsl:choose>
                <!-- 08/11/2016 mharcourt Fixed bug by comparing to value of '0' 
                    per items 102.4, 102.5, 102.6 and 102.7 -->
                <xsl:when test="$contextElement/tgroup/normalize-space(@rowsep) = '0' and                     $qValue != '-'">
                    <xsl:processing-instruction name="xpp">l1;(%lddesc+%ldextra)</xsl:processing-instruction>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:variable name="colspecAlignPIs" as="processing-instruction()*">
            <xsl:for-each select="colspec">
                <xsl:variable name="cNum" as="xs:string">
                    <xsl:number />
                </xsl:variable>
                <xsl:variable name="styleNum" as="xs:integer">
                    <xsl:value-of select="1 + count(preceding-sibling::colspec[normalize-space(@align) = 'char' and                          normalize-space(@char) != '' and                          normalize-space(@charoff) != '' and                          normalize-space(@coldef) = 'fig'])" />
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="normalize-space(@align) = 'left'" />
                    <xsl:when test="normalize-space(@align) = 'justify'">
                        <xsl:processing-instruction name="xpp">j</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="normalize-space(@align) = 'right'">
                        <xsl:processing-instruction name="xpp"><xsl:value-of select="concat($cNum,';xin')" /></xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="normalize-space(@align) = 'char' and                          normalize-space(@char) != '' and                          normalize-space(@charoff) != '' and                         normalize-space(@coldef) = 'fig'">
                        <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('setaln;',$styleNum,';;',normalize-space(@char))" /></xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('setcol;',$cNum,';align;',$styleNum)" /></xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('setcol;',$cNum,';hstyle;right')" /></xsl:processing-instruction>
                    </xsl:when>
                </xsl:choose>
            </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="numColspecs" select="count(../colspec)" as="xs:integer" />
        
        
        <xsl:element name="{local-name()}">
            <xsl:copy-of select="@block-style, @* except (@actual-width, @block-style, @align,                  @bearoff, @grid-typeface, @horizontal-justify, @ldr-align-top, @min-space,                  @no-carding, @no-hyph, @offset-from-left, @restrict-indent, @ttitle-size)" /><!-- 11/24/2015 mharcourt Added @grid-typeface, @horizontal-justify, @ldr-align-top, @min-space, @no-carding, @no-hyph, @offset-from-left, @restrict-indent -->
            <!-- 03/07/2016 mharcourt - Exclude descendant-or-self::tfoot elements from apply-templates -->
            <xsl:apply-templates select="*|node() except *[descendant-or-self::tfoot]" mode="calsTables">
                <xsl:with-param name="actualWidth" select="$actualWidth" tunnel="yes" />
                <xsl:with-param name="tfoot" select="$tfoot" tunnel="yes" />
                <xsl:with-param name="thead-tbody-ldg-size" select="$thead-tbody-ldg-size" tunnel="yes" />
                <xsl:with-param name="mwtPunctuation" select="$finalPunctuation" tunnel="yes" />
                <xsl:with-param name="boxGutterPIs" select="$allBoxGutterPIs" tunnel="yes" />
                <xsl:with-param name="L1" select="$l1" tunnel="yes" />
                <xsl:with-param name="alignPIs" select="$colspecAlignPIs" tunnel="yes" />
                <xsl:with-param name="numColspecs" select="count(colspec)" as="xs:integer" tunnel="yes" /><!-- 04/07/2016 mharcourt Moved tunnel parameter definition from colspec template to tgroup -->
                <!-- 08/01/2016 mharcourt Added number of columns tunnel parameter -->
                <xsl:with-param name="numCols" select="normalize-space(@cols)" as="xs:string" tunnel="yes" />
                <!-- 08/01/2016 mharcourt Added @block-style tunnel parameter -->
                <xsl:with-param name="blockStyle" as="xs:string" tunnel="yes">
                    <xsl:choose>
                        <xsl:when test="normalize-space(@block-style) != ''">
                            <xsl:value-of select="normalize-space(@block-style)" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>omitted</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:with-param>
            </xsl:apply-templates>
        </xsl:element>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="thead" mode="calsTables">
        <xsl:element name="{local-name()}">
            <xsl:copy-of select="@valign, @* except (@valign)" />
            <xsl:apply-templates select="*|node()" mode="calsTables" />
        </xsl:element>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="tfoot[local-name(preceding-sibling::*[1])!='tbody']" mode="calsTables" /><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="tfoot" />
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="tbody" mode="calsTables">
        <xsl:param name="tfoot" tunnel="yes" />
        
        <xsl:copy>
            <!-- 02/29/2016 mharcourt Added suppression of @stub-hierarchy according to 
                documentation and feedback by bharvey -->
            <xsl:copy-of select="@* except @stub-hierarchy" />
            <xsl:apply-templates mode="calsTables" />
        </xsl:copy>
        <xsl:if test="count($tfoot[element()]) &gt; 0">
            <tfoot>
                <xsl:for-each select="$tfoot/node()">
                    <xsl:apply-templates select="." mode="calsTables" />
                </xsl:for-each>
            </tfoot>
        </xsl:if>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="tbody" mode="Leaderwork">
        <xsl:copy>
            <xsl:apply-templates mode="Leaderwork">
                <xsl:with-param name="mwtChar" />
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="oldColspecNames" />
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry[ancestor::thead]" mode="calsTables">
        <xsl:param name="oldColspecNames" tunnel="yes" />
        
        <xsl:element name="{local-name()}">
            <xsl:attribute name="colname">                
                <xsl:choose>
                    <xsl:when test="./@colname">
                        <xsl:value-of select="concat('column',gpo:getCnumByCname($oldColspecNames,string(./@colname)))" />   
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="./@namest">
                                <xsl:value-of select="concat('column',gpo:getCnumByCname($oldColspecNames,string(./@namest)))" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="concat('column',string(count(preceding-sibling::entry)+1))" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
            <xsl:if test="./@namest">
                <xsl:attribute name="namest">
                    <xsl:value-of select="concat('column',gpo:getCnumByCname($oldColspecNames,string(./@namest)))" />
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="./@nameend">
                <xsl:attribute name="nameend">
                    <xsl:value-of select="concat('column',gpo:getCnumByCname($oldColspecNames,string(./@nameend)))" />
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="./@align and (./normalize-space(@align) != 'char' and ./normalize-space(@align) != 'justify')">
                <xsl:copy-of select="./@align" />
            </xsl:if>
            <xsl:copy-of select="@* except (@colname, @align, @justify, @namest, @nameend, @char, @charoff,                  @stub-definition, @stub-hierarchy, @rowsep-modify, @leader-modify, @entry-modify)" /><!-- 02/23/2016 mharcourt Allow @valign to be output per email reply by Deb Gallligan Tuesday, March 22, 2016 1:00 AM -->
            <xsl:apply-templates select="*|node()" mode="calsTables" />
        </xsl:element>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="row" mode="calsTables"><!-- Removed [parent::tbody or parent::thead] -->
        <xsl:variable name="numEntries" as="xs:integer" select="count(entry)" />
        
        <xsl:element name="{local-name()}">
            <xsl:copy-of select="@rowsep, @block-style, @valign, @* except (@rowsep, @valign, @rowsep-modify)" />
            <xsl:apply-templates select="*|node()" mode="calsTables">
                <xsl:with-param name="lastEntryNum" select="$numEntries" as="xs:integer" tunnel="yes" />
            </xsl:apply-templates>
        </xsl:element>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p><xd:b>XPATH:</xd:b> entry</xd:p>
            <xd:p><xd:b>Variable(s):</xd:b>
                <dl>
                    <di>
                        <dt>entryCount</dt>
                        <dd>Type xs:integer containing value of xsl:number command</dd>
                    </di>
                    <di>
                        <dt>lastRowLastEntryNode</dt>
                        <dd>Type node() containing Xpath ancestor::tgroup/tbody/row[last()]/entry[last()]</dd>
                    </di>
                    <di>
                        <dt>colspecNum</dt>
                        <dd>Type xs:string containing a string representation of the sequence number of a matching column name in $oldColspecNames as determined by the evaluation of an xsl:choose block</dd>
                    </di>
                    <di>
                        <dt>newEntryModify</dt>
                        <dd>Type xs:string that evaluates a complex xsl:choose block and returns a value that is used in later decisions that can affect modifications to the final entry node output by the template</dd>
                    </di>
                </dl>
            </xd:p>
            <xd:p><xd:b>Change history:</xd:b> None</xd:p>
            <xd:p><xd:b>Remarks:</xd:b> None</xd:p>
            <xd:p>This template uses five parameters (see below) to transform entry nodes and the elements and data they contain.</xd:p>
            <xd:p><xd:b>Content model for entry elements:</xd:b><br />
                ( #PCDATA | marker | added-phrase | deleted-phrase | internal-xref | 
                external-xref  | fraction | superscript | subscript | italic | quote | 
                inline-comment | act-name | formula | term | omitted-text | linebreak | 
                nobreak | pagebreak | bold )*</xd:p>
            <xd:p><xd:b>Attributes for entry elements:</xd:b>
                <dl>
                    <di>
                        <dt>align</dt>
                        <dd><xd:b>Type:</xd:b> (left|right|center|justify|char)<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>char</dt>
                        <dd><xd:b>Type:</xd:b> CDATA<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>charoff</dt>
                        <dd><xd:b>Type:</xd:b> NMTOKEN<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>colname</dt>
                        <dd><xd:b>Type:</xd:b> NMTOKEN<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>colsep</dt>
                        <dd><xd:b>Type:</xd:b> (0|1)<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>entry-modify</dt>
                        <dd><xd:b>Type:</xd:b> (force-ldr|force-ldr-bottom|ctr-variable|paragraph|fl-hang-hier-2|fl-hang-hier-3|fl-hang-hier-4|fl-hang-hier-5|fl-hang-hier-6|fl-hang-hier-7|fl-hang-hier-8|fl-hang-hier-9)<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>leader-modify</dt>
                        <dd><xd:b>Type:</xd:b> (force-ldr|clr-ldr|force-ldr-bottom)
                            <br /><xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>morerows</dt>
                        <dd><xd:b>Type:</xd:b> NMTOKEN<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>nameend</dt>
                        <dd><xd:b>Type:</xd:b> NMTOKEN<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>namest</dt>
                        <dd><xd:b>Type:</xd:b> NMTOKEN<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>rowsep</dt>
                        <dd><xd:b>Type:</xd:b> (0|1)<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>rowsep-modify</dt>
                        <dd><xd:b>Type:</xd:b> (double|bold)<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>stub-definition</dt>
                        <dd><xd:b>Type:</xd:b> (trace|fig|txt-clr|txt-ldr|txt-clr-start-end|txt-clr-2pts-larger|txt-ldr-start|txt-ldr-end|ctr-start|ctr-start-end|ctr-continues-start|ctr-on-table-start|table-fnote|fnote-bottom-page)<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>stub-hierarchy</dt>
                        <dd><xd:b>Type:</xd:b> CDATA<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>
                    <di>
                        <dt>valign</dt>
                        <dd><xd:b>Type:</xd:b> (top|middle|bottom)<br />
                            <xd:b> Mode:</xd:b> #IMPLIED)</dd>
                    </di>            	  
                </dl>
            </xd:p>
        </xd:desc>
        <xd:param name="oldColspecNames">
            <xd:p>A tunnel parameter of type xs:string set by the tgroup ancestor containing a sequence of strings of the colspec @name attributes, one for each colspec element. Example:  “col1”, “COLSPEC0”, “col2”</xd:p>
        </xd:param>
        <xd:param name="lastEntryNum">
            <xd:p>A tunnel parameter of type xs:integer set by the row parent that identifies the number of the last entry in the current row.</xd:p>
        </xd:param>
        <xd:param name="thead-tbody-ldg-size">
            <xd:p> A tunnel parameter of type xs:string set by the tgroup ancestor containing </xd:p>
        </xd:param>
        <xd:param name="mwtPunctuation">
            <xd:p />
        </xd:param>
        <xd:param name="L1">
            <xd:p>An optional tunnel parameter of type processing-instruction() set by tgroup when 
                test="not($contextElement/tgroup/normalize-space(@rowsep)) and $qValue != '-'" succeeds
                within the tgroup element. If set, it will have this value: l1;(%lddesc+%ldextra).</xd:p>
        </xd:param>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry" mode="calsTables">
        <xsl:param name="oldColspecNames" tunnel="yes" />
        <xsl:param name="lastEntryNum" as="xs:integer" tunnel="yes" />
        <xsl:param name="thead-tbody-ldg-size" as="xs:string" tunnel="yes" />
        <xsl:param name="mwtPunctuation" as="xs:string" tunnel="yes" />
        <xsl:param name="L1" as="processing-instruction()?" tunnel="yes" />
        <xsl:param name="blockStyle" as="xs:string" tunnel="yes" />
        <xsl:param name="numCols" as="xs:string" tunnel="yes" />
        
        <xsl:variable name="entryCount" as="xs:integer"><xsl:number /></xsl:variable>
        
        <!-- points to the node in the last entry in the last row of the table body.
            Use it to compare it with current entry node and do not insert the mwt PI
            if the current entry is the last one in the last row of the body -->
        <xsl:variable name="lastRowLastEntryNode" as="node()" select=" ancestor::tgroup/tbody/row[last()]/entry[last()]" />
        <xsl:variable name="colspecNum" as="xs:string">
            <!-- 03/02/2016 mharcourt Revised conditions to handle fatal errors when 
                XML is marked up incorrectly because either existing @colname or @namest 
                value was not defined by any <colspec> element. -->
            <xsl:variable name="joinedOldColspecNames" select="string-join($oldColspecNames,',')" />
            <xsl:choose>
                <xsl:when test="(./@colname and                      contains($joinedOldColspecNames,string(./@colname))) or                     (./@namest and                      contains($joinedOldColspecNames,string(./@namest)))">
                    <xsl:choose>
                        <xsl:when test="./@colname">
                            <xsl:value-of select="gpo:getCnumByCname($oldColspecNames,string(./@colname))" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="gpo:getCnumByCname($oldColspecNames,string(./@namest))" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="string(count(preceding-sibling::entry)+1)" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="newEntryModify">
            <xsl:variable name="oldEntryModify" select="normalize-space(@entry-modify)" />
            <xsl:choose>
                <xsl:when test="$oldEntryModify != ''">
                    <xsl:variable name="secondValue" as="xs:string">
                        <xsl:choose>
                            <xsl:when test="$thead-tbody-ldg-size!=''">
                                <xsl:value-of select="tokenize($thead-tbody-ldg-size,'\.')[2]" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:text />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:choose>
                        <xsl:when test="$oldEntryModify='ctr-variable'">
                            <xsl:choose>
                                <xsl:when test="$blockStyle != '1'">
                                    <xsl:text>center</xsl:text>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="$oldEntryModify" />
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="starts-with($oldEntryModify,'fl-hang-hier-')">
                            <xsl:variable name="heirValue" as="xs:string">
                                <xsl:value-of select="replace($oldEntryModify,'fl-hang-hier-','')" />
                            </xsl:variable>
                            <!-- 03/22/2016 mharcourt Expanded condition per CALS file named 
                                XSLT-directions_03-09-2016-tracking.docx -->
                            <!-- 04/05/2016 mharcourt - Removed amendment-doc condition due to no extant examples -->
                            <xsl:choose>
                                <xsl:when test="$secondValue != ''">
                                    <xsl:choose>
                                        <xsl:when test="$blockStyle != '1'">
                                            <xsl:value-of select="concat(                                                 string(xs:integer($heirValue) * xs:integer($secondValue)),                                                 ',',$secondValue)" />
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="string((xs:integer($heirValue) - 1) * xs:integer($secondValue))" />
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:when>
                                <xsl:otherwise><!-- i.e., thead-tbody-ldg-size="x.y.z" is NOT present -->
                                    <xsl:choose>
                                        <xsl:when test="$blockStyle != '1'">
                                            <xsl:choose>
                                                <!-- 04/13/2016 mharcourt - Expanded conditional to account 
                                                    for other document types besides bills only. -->
                                                <xsl:when test="(/bill/normalize-space(@bill-stage) = 'Enrolled-Bill' or                                                      /resolution/normalize-space(@resolution-stage) = 'Enrolled-Bill' or                                                      /amendment-doc/normalize-space(@amend-stage) = 'Enrolled-Bill')">
                                                    <xsl:value-of select="concat(string(xs:integer($heirValue) * 10),',10')" />
                                                </xsl:when>
                                                <xsl:otherwise>
                                                    <xsl:value-of select="concat(string(xs:integer($heirValue) * 8),',8')" />
                                                </xsl:otherwise>
                                            </xsl:choose>
                                        </xsl:when>
                                        <xsl:otherwise><!-- i.e., ancestor::tgroup/normalize-space(@blockstyle) = '1' -->
                                            <xsl:choose>
                                                <!-- 04/13/2016 mharcourt - Expanded conditional to account 
                                                    for other document types besides bills only. -->
                                                <xsl:when test="(/bill/normalize-space(@bill-stage) = 'Enrolled-Bill' or                                                      /resolution/normalize-space(@resolution-stage) = 'Enrolled-Bill' or                                                      /amendment-doc/normalize-space(@amend-stage) = 'Enrolled-Bill')">
                                                    <xsl:value-of select="string((xs:integer($heirValue) - 1) * 10)" />
                                                </xsl:when>
                                                <xsl:otherwise>
                                                    <xsl:value-of select="string((xs:integer($heirValue) - 1) * 8)" />
                                                </xsl:otherwise>
                                            </xsl:choose>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:otherwise>
                            </xsl:choose>
                            <!-- insert <?xpp xin?> before </entry> -->                            
                        </xsl:when>
                        <xsl:when test="$oldEntryModify='paragraph'">
                            <xsl:choose>
                                <xsl:when test="$blockStyle != '1'">
                                    <xsl:value-of select="$secondValue" />
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="$oldEntryModify" />
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="$oldEntryModify='force-ldr'">
                            <xsl:value-of select="$oldEntryModify" /><!-- 03/24/2016 mharcourt Removed condition "and ancestor::tgroup/normalize-space(@blockstyle) = '1'" per email this date from Deb Galligan -->
                        </xsl:when>
                        <xsl:when test="starts-with($oldEntryModify,'force-ldr-hier-')">
                            <xsl:variable name="heirValue" as="xs:string">
                                <xsl:value-of select="replace($oldEntryModify,'force-ldr-hier-','')" />
                            </xsl:variable>
                            <xsl:value-of select="string((xs:integer($heirValue) - 1) * xs:integer($secondValue))" />                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message>Unexpected value for @entry-modify: "<xsl:value-of select="$oldEntryModify" />"</xsl:message>
                            <xsl:value-of select="$oldEntryModify" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="leaderModify" as="xs:string">
            <xsl:choose>
                <xsl:when test="normalize-space(@leader-modify) != ''">
                    <xsl:value-of select="normalize-space(@leader-modify)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>omitted</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:element name="{local-name()}">
            <xsl:attribute name="colname">
                <xsl:choose>
                    <xsl:when test="./@colname">
                        <xsl:variable name="colNum" as="xs:string">
                            <xsl:value-of select="gpo:getCnumByCname($oldColspecNames,string(./@colname))" />
                        </xsl:variable>
                        <xsl:value-of select="concat('column',$colNum)" />   
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="./@namest">
                                <xsl:value-of select="concat('column',gpo:getCnumByCname($oldColspecNames,string(./@namest)))" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="concat('column',string(count(preceding-sibling::entry)+1))" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
            <xsl:if test="./@namest">
                <xsl:attribute name="namest">
                    <xsl:value-of select="concat('column',gpo:getCnumByCname($oldColspecNames,string(./@namest)))" />
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="./@nameend">
                <xsl:attribute name="nameend">
                    <xsl:value-of select="concat('column',gpo:getCnumByCname($oldColspecNames,string(./@nameend)))" />
                </xsl:attribute>
            </xsl:if>
            <!-- 08/11/2016 mharcourt Added xsl:if to fix bug reported by 
            Deb Galligan in implementing items 19.3 and 19.4 -->
            <xsl:if test="ancestor::tbody and                 ($newEntryModify = 'center' or                 (normalize-space(@align) = 'center' and                 normalize-space(@entry-modify) != 'ctr-variable') or                 (not(@align) and                 normalize-space(@entry-modify) = 'ctr-variable'))">
                <xsl:attribute name="align">center</xsl:attribute>
            </xsl:if>
            <xsl:copy-of select="@* except (@align, @colname, @namest, @nameend,                   @charoff, @colsep-modify, @entry-modify, @justify, @leader-modify,                  @rowsep-modify, @stub-definition, @stub-hierarchy, @valign)" />
            <!-- 06-27-2016 mharcourt Suppress @valign per change in CALS 
                specification document named XSLT-directions_06-21-2016-tracking.docx --><!-- 03/23/2016 mharcourt Allow @align to be 
                output per change in CALS specification document named XSLT-directions_03-22-2016-tracking.docx -->
            <!-- insert <?xpp l1;(%lddesc+%ldextra)?> directly after every 
                <entry … > beginning with the second <row> after <tbody>  -->
            <!-- 07-14-201 mharcourt Factored out <xsl:if test="ancestor::tbody" to support multiple new conditions received 
                related to LEADERS, LINEBREAKS, AND LEADER-MODIFY. -->
            <!-- 08/18/2016 mharcourt Changed xsl:value-of to xsl:copy-of to fix one bug 
            and count(parent::row) to ./parent::row/count(preceding-sibling::row) to
            fix another -->
            <xsl:if test="ancestor::tbody">
                <xsl:if test="not(empty($L1)) and                      ./parent::row/count(preceding-sibling::row) &gt; 0 and                     normalize-space(.) != '' and                     ancestor::tgroup/normalize-space(@rowsep) = '0'">
                    <xsl:copy-of select="$L1" />
                    <xsl:if test="$debugState = 1">
                        <xsl:message>102.4.2: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                    </xsl:if>
                </xsl:if>
                <!-- 07-14-2016 mharcourt Added multiple xsl:choose blocks to implement CALS specifications 66.1 through 66.6 inclusive -->
                <xsl:variable name="flbCount" select="if ($leaderModify = 'force-ldr-bottom')                      then count(preceding-sibling::entry/normalize-space(@leader-modify) = 'force-leader-bottom') + 1                      else 0" />
                <xsl:choose>
                    <!-- 66.1, 66.2, 66.3 -->
                    <xsl:when test="$leaderModify = ('force-ldr','omitted','clr-ldr','force-ldr-bottom') and                         ancestor::tgroup/colspec[$colspecNum]/normalize-space(@coldef) = ('txt','txt-no-spread')">
                        <xsl:if test="$leaderModify = 'force-ldr-bottom'">
                            <!-- 66.3.4a, 66.3.5a -->
                            <xsl:processing-instruction name="xpp">flb-b;<xsl:value-of select="$flbCount" /></xsl:processing-instruction><xsl:processing-instruction name="xpp">lnbrk-1</xsl:processing-instruction>
                            <xsl:if test="$debugState = 1">
                                <xsl:message>66.3.4a, 66.3.5a: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                            </xsl:if>
                        </xsl:if>

                        <!-- 66.1, 66.2, and normal 66.3 -->
                        <!-- If in the last column, nothing is inserted for anythhing in 66.1 through 66.3 -->
                        <xsl:if test="count(child::linebreak) &gt; 0 and                             xs:integer($colspecNum) != count(ancestor::tgroup/colspec)">
                            <xsl:choose>
                                <!-- $blockStyle was NOT specified or someone put in manually 
                                    block-style="0", which means the same thing according to 
                                    Joe Buttrim -->
                                <xsl:when test="$blockStyle = 'omitted' or $blockStyle = '0'">
                                    <!-- 66.1.4, 66.2.4 -->
                                    <xsl:processing-instruction name="xpp">lnbrk-1</xsl:processing-instruction>
                                    <xsl:if test="$debugState = 1">
                                        <xsl:message>66.1.4, 66.2.4: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                    </xsl:if>
                                </xsl:when>
                                <xsl:otherwise><!-- i.e., $blockStyle was specified rather than omitted -->
                                    <!-- 66.1.5, 66.2.5 -->
                                    <xsl:processing-instruction name="xpp">lnbrk-1-bs</xsl:processing-instruction>
                                    <xsl:if test="$debugState = 1">
                                        <xsl:message>66.1.5, 66.2.5: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                    </xsl:if>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:if>
                    </xsl:when>
                    <!-- 66.4 does not insert a PI following entry. It only changes linebreak elements -->
                    <!-- 66.5 -->
                    <xsl:when test="$leaderModify = 'force-ldr' and                         count(child::linebreak) &gt; 0 and                         ancestor::tgroup/colspec[$colspecNum]/normalize-space(@coldef) = ('txt-no-ldr-no-spread','txt-no-ldr')">
                        <xsl:choose>
                            <!-- 66.5.4a -->
                            <!-- $blockStyle was NOT specified or someone put in manually 
                                    block-style="0", which means the same thing according to 
                                    Joe Buttrim -->
                            <xsl:when test="$blockStyle = 'omitted' or $blockStyle = '0'">
                                <xsl:processing-instruction name="xpp">lnbrk-1</xsl:processing-instruction>
                                <xsl:if test="$debugState = 1">
                                    <xsl:message>66.5.4a: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                </xsl:if>
                            </xsl:when>
                            <!-- 66.5.5a -->
                            <xsl:otherwise><!-- i.e., $blockStyle was specified rather than omitted -->
                                <xsl:processing-instruction name="xpp">lnbrk-1-bs</xsl:processing-instruction>
                                <xsl:if test="$debugState = 1">
                                    <xsl:message>66.5.5a: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                </xsl:if>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <!-- 66.6 -->
                    <xsl:when test="$leaderModify ='force-ldr-bottom' and                         ($blockStyle = 'omitted' or $blockStyle = '0') and                         ancestor::tgroup/colspec[$colspecNum]/normalize-space(@coldef) = ('txt-no-ldr-no-spread','txt-no-ldr')">
                        <!-- 66.6.3 -->
                        <xsl:processing-instruction name="xpp">flb-b;<xsl:value-of select="$flbCount" /></xsl:processing-instruction><xsl:processing-instruction name="xpp">lnbrk-1</xsl:processing-instruction>
                        <xsl:if test="$debugState = 1">
                            <xsl:message>66.6.3: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                        </xsl:if>
                    </xsl:when>
                </xsl:choose>
            </xsl:if>
            <xsl:if test="matches($newEntryModify,'^\d+,\d+$')">
                <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('in;',tokenize($newEntryModify,',')[1],'q')" /></xsl:processing-instruction>
                <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('i1;&amp;-',tokenize($newEntryModify,',')[2],'q')" /></xsl:processing-instruction>
            </xsl:if>
            <xsl:if test="matches($newEntryModify,'^\d+$')">
                <xsl:variable name="oldEntryModify" select="normalize-space(@entry-modify)" as="xs:string" />
                <xsl:choose>
                    <xsl:when test="$oldEntryModify = 'paragraph' or                          starts-with($oldEntryModify,'force-ldr-hier-')">
                        <xsl:processing-instruction name="xpp">xin</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('i1;',$newEntryModify,'q')" /></xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="starts-with($oldEntryModify,'fl-hang-hier-')">
                        <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('in;',$newEntryModify,'q')" /></xsl:processing-instruction>
                    </xsl:when>
                </xsl:choose>
            </xsl:if>
            <xsl:if test="normalize-space(@stub-hierarchy)[. != ''] and                  ancestor::tgroup/colspec[xs:integer($colspecNum)]/normalize-space(@coldef) != 'fig'">
                <!-- 03/15/2016 mharcourt Commented previous code based on documentation update. -->
                <!--<xsl:processing-instruction name="xpp">in;<xsl:value-of 
                    select="xs:integer(@stub-hierarchy) * 10"/>q</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">i1;-6q</xsl:processing-instruction> -->
                <xsl:choose>
                    <xsl:when test="number(normalize-space(@stub-hierarchy)) = number(normalize-space(@stub-hierarchy))"><!-- Whenever normalize-space(@stub-hierarchy) cannot be used as a number, then normalize-space(@stub-hierarchy) is NaN and NaN is not equal to any other value, even to itself. -->
                        <xsl:variable name="shNum" select="xs:integer(normalize-space(@stub-hierarchy))" as="xs:integer" />
                        <xsl:choose>
                            <xsl:when test="$shNum = 0"><!-- NOTE: CHECK WITH XPP TEAM WHAT SHOULD HAPPEN WHEN VALUE OF ZERO HAPPENS -->
                                <xsl:processing-instruction name="xpp">in;<xsl:value-of select="$shNum * 10" />q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">i1;-6q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$shNum &gt;= 1 and $shNum &lt;= 10"><!-- 03/22/2016 mharcourt Added "10" per email this date from Deb Galligan -->
                                <xsl:processing-instruction name="xpp">in;(%fheight/352n*<xsl:value-of select="$shNum + ($shNum - 1)" />)q</xsl:processing-instruction><!-- 03/23/2016 mharcourt Added "q" unit of measure for consistency per email from Deb Galligan dated Wed 3/23/2016 7:41 AM -->
                                <xsl:processing-instruction name="xpp">i1;&amp;-(%fheight/352n*1)</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message>Unexpected numeric value for attribute  @stub-heirarchy: <xsl:value-of select="@stub-hierarchy" /></xsl:message>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>Unexpected non-numeric value for attribute  @stub-heirarchy: <xsl:value-of select="@stub-hierarchy" /></xsl:message>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:if>
            <xsl:if test="ancestor::tfoot">
                <xsl:call-template name="tfootPIs" />
            </xsl:if>
            
            <!-- 03/10/2016 mharcourt Rewrote assignment to handle cases where 
                optional <colspec> node is omitted. 
                Pretend coldef="txt-no-ldr-no-spread" if no <colspec> since
                that is the most frequent value for @coldef. -->
            <xsl:variable name="coldefValue" as="xs:string">
                <xsl:choose>
                    <xsl:when test="ancestor::tgroup/colspec">
                        <xsl:value-of select="(ancestor::tgroup/colspec[xs:integer($colspecNum)]/normalize-space(@coldef))" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>txt-no-ldr-no-spread</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable> 
            
            <xsl:variable name="leaderModify" as="xs:string">
                <xsl:choose>
                    <xsl:when test="normalize-space(@leader-modify) != ''">
                        <xsl:value-of select="normalize-space(@leader-modify)" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>omitted</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            
            <!-- 08-01-2016 mharcourt Added three tunnel parameters for use in linebreak -->
            <xsl:apply-templates select="*|node()" mode="calsTables">
                <xsl:with-param name="colspecNum" select="$colspecNum" as="xs:string" tunnel="yes" />
                <xsl:with-param name="coldefValue" select="$coldefValue" as="xs:string" tunnel="yes" />
                <xsl:with-param name="leaderModify" select="$leaderModify" as="xs:string" tunnel="yes">
                </xsl:with-param>
            </xsl:apply-templates>

            <!-- 04/12/2016 mharcourt - Moved this inside <xsl:element> as
                part of eliminating duplicate PI outputs and rewrote condition. -->
            <xsl:if test="$lastEntryNum != $entryCount and                  ancestor::tbody and                 (                 ($coldefValue = 'txt' and                  ancestor::tgroup/colspec[$colspecNum]/normalize-space(@align) != 'center' and                 @leader-modify != 'clr-ldr')                 or                  ($coldefValue = ('txt','txt-no-spread') and                  @leader-modify and                  @leader-modify != 'clr-ldr')                 or                 $newEntryModify='force-ldr')">
                <xsl:processing-instruction name="xpp">bill-leader</xsl:processing-instruction>
            </xsl:if>
            
            <!-- 02/16/2016 mharcourt Added conditional to output mwt PI if set in <tgroup> and
                if this is not the last entry in the table -->
            <!-- 08/11/2016 mharcourt Revised condition to check string length
                based on email from Deb Galligan that says mwt PI only goes out 
                if the length is exactly one. -->
            <xsl:if test="string-length($mwtPunctuation) = 1 and                 $lastEntryNum = $entryCount and                 . != $lastRowLastEntryNode">
                <xsl:processing-instruction name="xpp">mwt;<xsl:value-of select="$mwtPunctuation" /></xsl:processing-instruction>
            </xsl:if>
            <xsl:if test="(normalize-space(@stub-hierarchy)[. != ''] and                  ancestor::tgroup/colspec[xs:integer($colspecNum)]/normalize-space(@coldef) != 'fig') or                  starts-with(normalize-space(@entry-modify),'force-ldr-hier-') or                  starts-with(normalize-space(@entry-modify),'fl-hang-hier-')">
                <xsl:processing-instruction name="xpp">xin</xsl:processing-instruction>
            </xsl:if>
            <xsl:if test="ancestor::tbody">
                <xsl:if test="not(empty($L1)) and                      count(parent::row) &gt; 1 and                     normalize-space(.) != ''">
                    <xsl:value-of select="$L1" />
                </xsl:if>
                <!-- 07-14-2016 mharcourt Added multiple xsl:choose blocks to implement CALS specifications 66.1 through 66.6 inclusive -->
                <xsl:variable name="flbCount" select="if ($leaderModify = 'force-ldr-bottom')                      then count(preceding-sibling::entry/normalize-space(@leader-modify) = 'force-leader-bottom') + 1                      else 0" />
                <xsl:choose>
                    <xsl:when test="$leaderModify = 'force-ldr-bottom' and                         count(child::linebreak) &gt; 0 and                         ($blockStyle = 'omitted' or $blockStyle = '0') and                         $coldefValue = ('txt', 'txt-no-spread') and                         xs:integer($colspecNum) != count(ancestor::tgroup/colspec)">
                        <xsl:processing-instruction name="end-lnbrk-flb" />
                        <xsl:processing-instruction name="xpp">flb-e;<xsl:value-of select="$flbCount" /></xsl:processing-instruction><xsl:processing-instruction name="xpp">lnbrk-1-bs</xsl:processing-instruction>
                        <xsl:if test="$debugState = 1">
                            <xsl:message>66.3.8: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                        </xsl:if>
                    </xsl:when>
                    <!-- 66.6.4 -->
                    <xsl:when test="$leaderModify = 'force-ldr-bottom' and                          ($blockStyle = 'omitted' or $blockStyle = '0') and                         $coldefValue = ('txt-no-ldr-no-spread','txt-no-ldr')">
                        <xsl:processing-instruction name="xpp">flb-e;<xsl:value-of select="$flbCount" /></xsl:processing-instruction><xsl:processing-instruction name="xpp">lnbrk-1</xsl:processing-instruction>
                        <xsl:if test="$debugState = 1">
                            <xsl:message>66.6.4: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                        </xsl:if>
                    </xsl:when>
                </xsl:choose>
            </xsl:if>
        </xsl:element>
        
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" name="tfootPIs" as="processing-instruction()*">
        <xsl:if test="gpo:parentRowPosition(ancestor::tfoot/row, ..) = 1">
            <xsl:choose>
                <xsl:when test="not(ancestor::tgroup/@fnote-size) and                     not(ancestor::tgroup/@thead-tbody-ldg-size)">
                    <xsl:choose>
                        <!-- 04/13/2016 mharcourt - Expanded conditional to account 
                            for other document types besides bills only. -->
                        <xsl:when test="(/bill/normalize-space(@bill-stage) = 'Enrolled-Bill' or                              /resolution/normalize-space(@resolution-stage) = 'Enrolled-Bill' or                              /amendment-doc/normalize-space(@amend-stage) = 'Enrolled-Bill')">
                            <xsl:processing-instruction name="xpp">sz;8q</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:processing-instruction name="xpp">sz;10q</xsl:processing-instruction>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:choose>
                        <xsl:when test="not(ancestor::tgroup/@fnote-size) and                             ancestor::tgroup/@thead-tbody-ldg-size and                             tokenize(ancestor::tgroup/normalize-space(@thead-tbody-ldg-size),'\.')[1] != ''">
                            <xsl:processing-instruction name="xpp">sz;<xsl:value-of select="tokenize(ancestor::tgroup/normalize-space(@thead-tbody-ldg-size),'\.')[1]" />q</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:choose>
                                <xsl:when test="ancestor::tgroup/@fnote-size and                                     ancestor::tgroup/normalize-space(@fnote-size) != ''">
                                    <xsl:processing-instruction name="xpp">sz;<xsl:value-of select="ancestor::tgroup/normalize-space(@fnote-size)" />q</xsl:processing-instruction>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message>Unhandled otherwise condition for first row in tfoot in template tfootPIs</xsl:message>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:otherwise>
                    </xsl:choose>
                    <xsl:processing-instruction name="xpp">mh;%fheight</xsl:processing-instruction>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
        <xsl:processing-instruction name="xpp">mh;%fheight</xsl:processing-instruction>    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements Item 78.1</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="linebreak[ancestor::thead and parent::entry]" mode="calsTables">
        <xsl:processing-instruction name="xpp">qa</xsl:processing-instruction>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="linebreak[ancestor::tfoot]" mode="calsTables">
        <xsl:processing-instruction name="xpp">xin</xsl:processing-instruction>
        <xsl:processing-instruction name="xpp">qa</xsl:processing-instruction>
        <xsl:processing-instruction name="xpp">i1;%fheight</xsl:processing-instruction>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="linebreak[ancestor::tbody and parent::entry]" mode="calsTables">
        <xsl:param name="blockStyle" as="xs:string" tunnel="yes" />
        <xsl:param name="leaderModify" as="xs:string" tunnel="yes" />
        <xsl:param name="colspecNum" as="xs:string" tunnel="yes" />
        <xsl:param name="coldefValue" as="xs:string" tunnel="yes" />

        <xsl:param name="numCols" as="xs:string" tunnel="yes" />
        <xsl:choose>
            <!-- 66.1, 66.2 -->
            <xsl:when test="$leaderModify = ('force-ldr','clr-ldr', 'omitted') and                 ancestor::tgroup/colspec[$colspecNum]/normalize-space(@coldef) = ('txt','txt-no-spread')">
                <xsl:choose>
                    <xsl:when test="xs:integer($colspecNum) != count(ancestor::tgroup/colspec)">
                        <xsl:choose>
                            <xsl:when test="$blockStyle = ('omitted', '0')"><!-- i.e., $blockStyle was NOT specified -->
                                <!-- 66.1.4b, 66.2.4b -->
                                <xsl:processing-instruction name="xpp">lnbrk-2</xsl:processing-instruction>
                                <xsl:if test="$debugState = 1">
                                    <xsl:message>66.1.4b, 66.2.4b: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                </xsl:if>
                            </xsl:when>
                            <xsl:otherwise><!-- i.e., $blockStyle was specified rather than omitted -->
                                <!-- 66.1.5b, 66.2.5b -->
                                <xsl:processing-instruction name="xpp">lnbrk-2-bs</xsl:processing-instruction>
                                <xsl:if test="$debugState = 1">
                                    <xsl:message>66.1.5b, 66.2.5b: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                </xsl:if>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <!-- 66.1.6, 66.2.6 -->
                    <xsl:otherwise><!-- i.e., entry is in last column of table -->
                        <xsl:processing-instruction name="xpp">linebreak-bs</xsl:processing-instruction>
                        <xsl:if test="$debugState = 1">
                            <xsl:message>66.1.6, 66.2.6: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <!-- 66.3 -->
            <xsl:when test="$leaderModify = 'force-ldr-bottom' and                 ancestor::tgroup/colspec[$colspecNum]/normalize-space(@coldef) = ('txt','txt-no-spread')">
                <xsl:choose>
                    <!-- 66.3.6 -->
                    <xsl:when test="$blockStyle = ('omitted', '0')">
                        <xsl:processing-instruction name="xpp">lnbrk-flb</xsl:processing-instruction>
                        <xsl:if test="$debugState = 1">
                            <xsl:message>66.3.6: linebreak: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                        </xsl:if>
                    </xsl:when>
                    <!-- 66.3.7, 66.3.8 -->
                    <xsl:otherwise>
                        <xsl:choose>
                            <!-- 66.3.7 -->
                            <xsl:when test="xs:integer($colspecNum) != count(ancestor::tgroup/colspec)">
                                <xsl:processing-instruction name="xpp">lnbrk-flb-bs</xsl:processing-instruction>
                                <xsl:if test="$debugState = 1">
                                    <xsl:message>66.3.7: linebreak: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                </xsl:if>
                            </xsl:when>
                            <!-- 66.3.8 -->
                            <xsl:otherwise><!-- i.e., in last coumn of table -->
                                <xsl:processing-instruction name="xpp">lnbrk-bs</xsl:processing-instruction>
                                <xsl:if test="$debugState = 1">
                                    <xsl:message>66.3.8: linebreak: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                </xsl:if>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <!--  66.4 -->
            <xsl:when test="$blockStyle = ('omitted','0') and                 $coldefValue = ('txt-no-ldr-no-spread','txt-no-ldr') and                 $leaderModify = 'clr-ldr'">
                <!--  66.4.4 -->
                <xsl:processing-instruction name="xpp">linebreak-bs</xsl:processing-instruction>
                <xsl:if test="$debugState = 1">
                    <xsl:message>66.4.4: linebreak: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                </xsl:if>
            </xsl:when>
            <!-- 66.5 -->
            <xsl:when test="$leaderModify = 'force-ldr' and                  ancestor::tgroup/colspec[$colspecNum]/normalize-space(@coldef) = ('txt-no-ldr-no-spread','txt-no-ldr')">
                <xsl:choose>
                    <!-- 66.5.4b -->
                    <xsl:when test="$blockStyle = ('omitted', '0')">
                        <xsl:processing-instruction name="xpp">lnbrk-2</xsl:processing-instruction>
                        <xsl:if test="$debugState = 1">
                            <xsl:message>66.5.4b: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                        </xsl:if>
                    </xsl:when>
                    <!-- 66.5.5b, 66.5.5c -->
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="count(.) = 1"><!-- i.e., first linebreak -->
                                <xsl:processing-instruction name="xpp">lnbrk-2-bs</xsl:processing-instruction>
                                <xsl:if test="$debugState = 1">
                                    <xsl:message>66.5.5b: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                </xsl:if>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:processing-instruction name="xpp">linebreak-bs</xsl:processing-instruction>
                                <xsl:if test="$debugState = 1">
                                    <xsl:message>66.5.5c: entry: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                                </xsl:if>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <!-- 66.6 -->
            <xsl:when test="$leaderModify ='force-ldr-bottom' and                 $blockStyle = '1' and                 ancestor::tgroup/colspec[$colspecNum]/normalize-space(@coldef) = ('txt-no-ldr-no-spread','txt-no-ldr')">
                <!-- 66.6.5 -->
                <xsl:processing-instruction name="xpp">linebreak-bs</xsl:processing-instruction>
                <xsl:if test="$debugState = 1">
                    <xsl:message>66.6.5: linebreak: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                </xsl:if>
            </xsl:when>
            
            <xsl:otherwise>
                <xsl:copy-of select="." />
                <xsl:if test="$debugState = 1 and                     ancestor::tbody">
                    <xsl:message>otherwise: linebreak: <xsl:value-of select="$baseXMLfile" /></xsl:message>
                </xsl:if>
            </xsl:otherwise>
            
        </xsl:choose>

    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="linebreak[ancestor::thead and parent::entry]" mode="Leaderwork">
        <xsl:choose>
            <!-- 67.1.4 -->
            <xsl:when test="(count(../preceding-sibling::entry) = 0 and                 count(preceding-sibling::text()) = 0) and                 ancestor::row/entry[2]/normalize-space(.)  != '' and                 ancestor::row/entry[2]/linebreak">
                <xsl:processing-instruction name="xpp">qa</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">xin</xsl:processing-instruction>
                <xsl:text>&amp;#x20;</xsl:text>
                <xsl:processing-instruction name="xpp">qa</xsl:processing-instruction>
            </xsl:when>
            <!-- 67.1.3 -->
            <xsl:when test="ancestor::row/entry[1]/normalize-space(.) != '' and                  ancestor::row/entry[2]/normalize-space(.)  != ''">
                <xsl:processing-instruction name="xpp">qa</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="." />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="oldColdef" />
        <xd:param name="ldg-size" />
        <xd:param name="mdv" />
        <xd:param name="stage" />
        <xd:return />
    </xd:doc><xsl:function xmlns:gpo="http://www.gpo.gov" name="gpo:calculateColwidth" as="xs:string">
        <xsl:param name="oldColdef" as="xs:string" />
        <xsl:param name="ldg-size" as="xs:string" />
        <xsl:param name="mdv" as="xs:string" />
        <xsl:param name="stage" as="xs:string" />
        <xsl:choose>
            <xsl:when test="$oldColdef='fig'">
                <xsl:choose>
                    <xsl:when test="number($ldg-size) = number($ldg-size)"><!-- Whenever $ldg-size cannot be used as a number, then number($ldg-size) is NaN and NaN is not equal to any other value, even to itself. -->
                        <xsl:variable name="divResult" select="xs:integer(ceiling(number($ldg-size) div 2))" as="xs:integer" />
                        <xsl:value-of select="concat(string(ceiling($divResult * number($mdv))),'q')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="$stage='Enrolled-Bill'">
                                <xsl:value-of select="concat(string(number($mdv) * 4),'q')" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="concat(string(number($mdv) * 5),'q')" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$oldColdef=('txt-no-ldr-no-spread','txt-no-spread')">
                <xsl:value-of select="concat($mdv,'q')" />
            </xsl:when>
            <xsl:when test="$oldColdef=('txt','txt-no-ldr')">
                <xsl:value-of select="concat('*+',$mdv,'q')" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:text />
                <xsl:message>Unrecognized @coldef value: <xsl:value-of select="$oldColdef" /></xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="oldColspecNames" />
        <xd:param name="actualWidth" />
        <xd:param name="thead-tbody-ldg-size" />
        <xd:param name="boxGutterPIs" />
        <xd:param name="alignPIs" />
        <xd:param name="colwidthPrefix" />
        <xd:param name="numColspecs" />
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="colspec" mode="calsTables">
        <xsl:param name="oldColspecNames" tunnel="yes" />
        <xsl:param name="actualWidth" as="xs:string" tunnel="yes" />
        <xsl:param name="thead-tbody-ldg-size" as="xs:string" tunnel="yes" />
        <xsl:param name="boxGutterPIs" as="processing-instruction()*" tunnel="yes" />
        <xsl:param name="alignPIs" as="processing-instruction()*" tunnel="yes" />
        <xsl:param name="colwidthPrefix" as="xs:string" tunnel="yes" /><!-- 03/14/2016 mhacourt Added colwidthPrefix parameter -->
        <xsl:param name="numColspecs" as="xs:integer" tunnel="yes" /><!-- 04/07/2016 mharcourt Moved tunnel parameter definition from colspec template to tgroup -->
        
        <!-- 04/07/2016 mharcourt Moved tunnel parameter definition from colspec template to tgroup -->
        <!--<xsl:variable name="numColspecs" select="count(../colspec)" as="xs:integer"/>-->
        <xsl:variable name="myPosition" select="count(preceding-sibling::colspec)+1" as="xs:integer" />
        <xsl:variable name="p1" select="./normalize-space(@coldef)" as="xs:string" />
        <!-- 01/06/2016 mharcourt - Fixed bug in tokenize() and added as="xs:string" -->
        <xsl:variable name="p2" select="tokenize($thead-tbody-ldg-size,'\.')[2]" as="xs:string" />
        <!-- 03/03/2016 mharcourt Asked Kathleen Swiatek what value to use if @min-data-value is 
            non-numeric to fix bug reported by tanastasiou this date in file “Source Files,
            Original\111Congress\S17XX\S1733_IS.XML”. Her reply was to use zero. However, using
            that value in multiplications  will result in a zero column width. Therefore, I am 
            going to use a value of '1' here. I also write an error to the console so that 
            .NET processing can return a diagnostic message to the user. -->
        <!-- 03/31/2016 mharcourt Revised tests of @min-data-value as a number to 
            fix bug where '1' was being selected despite numeric value
            for @min-data-value. -->
        <xsl:variable name="p3" select="if (number(normalize-space(@min-data-value)) = number(normalize-space(@min-data-value))) then              ./normalize-space(@min-data-value) else '1'" as="xs:string" />
        <!--<xsl:variable name="p3" 
            select="if (matches(normalize-space(@min-data-value),'^/d+$')) then 
            ./normalize-space(@min-data-value) else '1'"
            as="xs:string"/>-->
        <xsl:if test="$suppressDiagnosticMessages != 1 and              number(normalize-space(@min-data-value)) != number(normalize-space(@min-data-value))">
            <xsl:message>Markup Error: Unexpected non-numeric @min-data-value attribute value 
                supplied. Value must be numeric. Specified value was: <xsl:value-of select="normalize-space(@min-data-value)" />. 
                Transformation used a value of '1' in computing the width of the 
                column to compensate. Check the output and revise XML file as 
                necessary to correct column formatting for this table.</xsl:message>
        </xsl:if>
        <!-- 02/08/2016 mharcourt - Fixed bugs reported by Tassos Anastasiou on 2/3/2018 and 2/5/2018 when 
            $p4 is an empty sequence as a result of there being no @bill-stage attribute in the document. -->
        <xsl:variable name="p4" select="if (/bill/normalize-space(@bill-stage))              then /bill/normalize-space(@bill-stage)              else if (/resolution/normalize-space(@resolution-stage))              then /resolution/normalize-space(@resolution-stage)              else if (/amendment-doc/normalize-space(@amend-stage))              then /amendment-doc/normalize-space(@amend-stage)              else ''" as="xs:string" />
        
        <xsl:variable name="calculatedColwidth" select="gpo:calculateColwidth($p1, $p2, $p3, $p4)" as="xs:string" />
        <!-- <xsl:comment><xsl:value-of select="concat($p1, '-', $p2, '-', $p3, '-', $p4)"/></xsl:comment>-->
        
        <xsl:element name="{local-name()}">
            <xsl:attribute name="colname">column<xsl:number /></xsl:attribute>
            <xsl:attribute name="colnum"><xsl:number /></xsl:attribute>
            <xsl:variable name="vColwidth">
                <xsl:choose>
                    <xsl:when test="$actualWidth='1'"><!-- If $actualWidth='1', do not insert asterisk/plus (*+) in front of @colwidth values -->
                        <xsl:value-of select="replace($calculatedColwidth,'[+*]','')" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat($colwidthPrefix,$calculatedColwidth)" /><!-- 03/14/2016 mharcourt Added $colwidthPrefix -->
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="$vColwidth != ''">
                <xsl:attribute name="colwidth" select="$vColwidth" />
            </xsl:if>
            
            <!-- 08/16/2016 mharcourt Implemented bug fixes identified by Deb -->
            <xsl:choose>
                <!-- 51.1a -->
                <xsl:when test="./normalize-space(@coldef) = 'fig'">
                    <xsl:choose>
                        <xsl:when test="not(@align) or ./normalize-space(@align) = ''">
                            <xsl:attribute name="align" select="right" />
                        </xsl:when>
                        <xsl:when test="./normalize-space(@align) = ('left', 'right', 'center')">
                            <xsl:attribute name="align" select="./normalize-space(@align)" />
                        </xsl:when>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="./normalize-space(@coldef) = ('txt', 'txt-no-spread', 'txt-no-ldr-no-spread')">
                    <!-- 51.2, 51.3, 51.4, 51.5 -->
                    <xsl:choose>
                        <xsl:when test="not(@align) or ./normalize-space(@align) = ''">
                            <xsl:attribute name="align" select="left" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="align" select="./normalize-space(@align)" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
            </xsl:choose>
            <!-- 02/29/2016 mharcourt Added suppression of @charoff according to 
                documentation and feedback by bharvey -->
            <xsl:copy-of select="@* except (@charoff, @coldef, @colname, @colnum,                  @colsep, @colsep-modify, @colwidth, @align, @align-modify-variable,                  @colsep-modify)" />
        </xsl:element>
        
        <xsl:variable name="thisTable" as="element(table)">
            <xsl:sequence select="./ancestor::table" />
        </xsl:variable>
        
        <!-- After final colspec node, output any XPP rule or ancestor::table/@blank-lines-before processing instructions -->
        <!-- <xsl:if test="$myPosition=$numColspecs">-->
        <!-- 04/14/2016 mharcourt Changed "count(preceding-sibling::colspec) + 1 = $numColspecs" 
            back to "$myPosition = $numColspecs" -->
        <xsl:if test="$myPosition = $numColspecs">
            
            <!-- 04/13/2016 mharcourt - Expanded conditional to account 
                for other document types besides bills only. -->
            <xsl:variable name="stage" select="if (/bill/normalize-space(@bill-stage))                  then /bill/normalize-space(@bill-stage)                  else if (/resolution/normalize-space(@resolution-stage))                  then /resolution/normalize-space(@resolution-stage)                  else if (/amendment-doc/normalize-space(@amend-stage))                  then /amendment-doc/normalize-space(@amend-stage)                  else ''" as="xs:string" />
            
            <!-- 02/16/2016 mharcourt Bug fix. Removed string "xpp " from text content of setctr PIs below. -->
            <xsl:choose>
                <!-- 04/14/2016 mharcourt - Changed conditional to use $stage and 
                    moved output location to match hand coded 
               example provided by Deb Galligan -->
                <xsl:when test="$stage = 'Enrolled-Bill'">
                    <xsl:processing-instruction name="xpp">tblwidth;318q</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">setctr;137q</xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:processing-instruction name="xpp">tblwidth;28p</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">setctr;2p</xsl:processing-instruction>
                </xsl:otherwise>
            </xsl:choose>
            
            <xsl:variable name="blb" as="xs:string?">
                <xsl:choose>
                    <xsl:when test="//bill and ancestor::table/normalize-space(@blank-lines-before)!=''">
                        <xsl:value-of select="ancestor::table/normalize-space(@blank-lines-before)" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="''" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            
            <xsl:sequence select="gpo:getBlank-lines-before($blb,$stage)" />
            
            <xsl:if test="parent::tgroup/@block-style='1'">
                <xsl:for-each select="parent::tgroup/colspec">
                    <xsl:if test="./normalize-space(@coldef)=('txt','txt-no-ldr','txt-no-ldr-no-spread','txt-no-spread')">
                        <xsl:processing-instruction name="xpp">setcol;<xsl:number />;xin</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">setcol;<xsl:number />;i1;0</xsl:processing-instruction>
                    </xsl:if>
                </xsl:for-each>
            </xsl:if>
            
            <xsl:if test="parent::tgroup/@no-hyph='1'">
                <xsl:processing-instruction name="xpp">setcol;1;tj;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">setcol;1;tq;rrs</xsl:processing-instruction>
            </xsl:if>
            
            <!-- 04/14/2016 mharcourt Moved output location to match hand coded 
               example provided by Deb Galligan -->
            <xsl:if test="not(contains(string($boxGutterPIs[1]),'ignore'))">
                <xsl:sequence select="$boxGutterPIs" />
            </xsl:if>
            
            <!-- 04/14/2016 mharcourt Moved output location to match hand coded 
               example provided by Deb Galligan -->
            <xsl:sequence select="gpo:getColspecPIs($thisTable)" />
            
            <xsl:choose>
                <!-- 04/14/2016 mharcourt - Revised this to use $stage -->
                <xsl:when test="$stage = 'Enrolled-Bill'">
                    <xsl:choose>
                        <xsl:when test="contains($thead-tbody-ldg-size,'.')">
                            <xsl:variable name="n1" as="xs:integer" select="xs:integer(tokenize($thead-tbody-ldg-size, '\.')[1])" />
                            <xsl:variable name="n2" as="xs:integer" select="xs:integer(tokenize($thead-tbody-ldg-size, '\.')[2])" />
                            <xsl:variable name="n3" as="xs:integer" select="xs:integer(tokenize($thead-tbody-ldg-size, '\.')[3])" />
                            <xsl:choose>
                                <xsl:when test="$n1 &gt; 0">
                                    <xsl:processing-instruction name="xpp">setallh;sz;<xsl:value-of select="string($n1)" />q</xsl:processing-instruction>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:processing-instruction name="xpp">setallh;sz;8q</xsl:processing-instruction>
                                </xsl:otherwise>
                            </xsl:choose>
                            <xsl:choose>
                                <xsl:when test="$n2 &gt; 0">
                                    <xsl:processing-instruction name="xpp">setall;sz;<xsl:value-of select="string($n2)" />q</xsl:processing-instruction>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:processing-instruction name="xpp">setall;sz;8q</xsl:processing-instruction>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:processing-instruction name="xpp">setallh;sz;8q</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">setall;sz;8q</xsl:processing-instruction>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                
                <xsl:otherwise>
                    <xsl:if test="contains($thead-tbody-ldg-size,'.')">
                        <xsl:variable name="n1" as="xs:integer" select="xs:integer(tokenize($thead-tbody-ldg-size, '\.')[1])" />
                        
                        <xsl:variable name="n2" as="xs:integer" select="xs:integer(tokenize($thead-tbody-ldg-size, '\.')[2])" />
                        <xsl:variable name="n3" as="xs:integer" select="xs:integer(tokenize($thead-tbody-ldg-size, '\.')[3])" />
                        
                        <xsl:if test="$n1 &gt; 0">
                            <xsl:processing-instruction name="xpp">setallh;sz;<xsl:value-of select="string($n1)" />q</xsl:processing-instruction>
                        </xsl:if>
                        
                        <xsl:if test="$n2 &gt; 0">
                            <xsl:processing-instruction name="xpp">setall;sz;<xsl:value-of select="string($n2)" />q</xsl:processing-instruction>
                        </xsl:if>
                        
                        <!-- 02/19/2016 mharcourt Fixed bug reported by dgalligan this date by 
                            subtracting $n2 from $n3 rather than $n3 from $n2. -->
                        <xsl:if test="$n3 &gt; 0">
                            <xsl:processing-instruction name="xpp">setall;le;<xsl:value-of select="string($n3 - $n2)" />q</xsl:processing-instruction>
                        </xsl:if>
                        
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
            
            <xsl:for-each select="parent::tgroup/colspec[normalize-space(@align)='char' and normalize-space(@char)!='' and normalize-space(@coldef)='fig']">
                <xsl:variable name="charvalue" select="./normalize-space(@char)" as="xs:string" />
                <xsl:variable name="colnumvalue" select="gpo:getCnumByCname($oldColspecNames,string(./@colname))" />
                <xsl:variable name="seqNum" select="position()" />
                
                <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('setaln;',$seqNum,';;',$charvalue)" /></xsl:processing-instruction>
                <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('setcol;',$colnumvalue,';align;',$seqNum)" /></xsl:processing-instruction>
            </xsl:for-each>
            
            <xsl:for-each select="parent::tgroup/colspec[normalize-space(@coldef)='fig']">
                <xsl:variable name="colnumvalue" select="gpo:getCnumByCname($oldColspecNames,string(./@colname))" />
                <xsl:choose>
                    <!-- 02/19/2016 mharcourt Fixed bug reported by dgalligan this date by removing 
                        the or (not(normalize-space(@align) = '')) conditional. -->
                    <xsl:when test="(normalize-space(@align)='char' and normalize-space(@char) != '' and normalize-space(@charoff) != '') or                          not(normalize-space(@align))">
                        
                        <!-- 03/10/2016 mharcourt Changed "jstyle;right" to "xin" per revised specifications in CALS document. --> 
                        <!--<xsl:processing-instruction name="xpp"><xsl:value-of select="concat('setcol;',$colnumvalue,';xin')"/></xsl:processing-instruction>-->
                        <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('setcol;',$colnumvalue,';xin')" /></xsl:processing-instruction>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:processing-instruction name="xpp"><xsl:value-of select="concat('setcol;',$colnumvalue,';xin')" /></xsl:processing-instruction>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:for-each>
            
            <xsl:if test="not(empty($alignPIs))">
                <!-- TA: 2016-04-08: A copy-of is required instead of value-of; otherwise the PIs are converted to text -->
                <xsl:copy-of select="$alignPIs" />
                <!--<xsl:value-of select="$alignPIs"/>-->
            </xsl:if>
            
        </xsl:if>
        
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="ttitle" mode="calsTables">
        <xsl:copy>
            <xsl:copy-of select="@*" />
            <xsl:choose>
                <xsl:when test="following-sibling::tgroup/@ttitle-size[xs:integer(.) &gt; 0]">
                    <xsl:processing-instruction name="xpp">sz;<xsl:value-of select="following-sibling::tgroup/@ttitle-size" />q;1q</xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:processing-instruction name="xpp">sz;10q;1q</xsl:processing-instruction>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:processing-instruction name="xpp">tq;rcs</xsl:processing-instruction>
            <xsl:processing-instruction name="xpp">tj;2</xsl:processing-instruction>
            <xsl:apply-templates mode="calsTables" />
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements CALS Specification items 67.1, 67.2 and 67.3.</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="table[normalize-space(@table-type) =         ('Leaderwork', 'Leaderwork,Tax', 'subformat', 'Tax', 'subformat-2-Tax-Rate') and          normalize-space(@table-template-name) = ('Tax (No Calculation)', 'Entry: 2 text, bold hds',          'Flush/hang, 1 text, 1 num, bold hds', 'Generic: 1 text, 1 num', 'Generic: 2 text, 1st longer',          'Generic: 2 text, even cols', 'Tax (No Calculation) 1 text, 1 num (9 chars) and extra long heads') and         tgroup/normalize-space(@cols) = '2' and          tgroup/colspec[1]/normalize-space(@coldef) = 'txt' and          ((tgroup/colspec[2]/normalize-space(@coldef) = 'fig' and         tgroup/colspec[2]/@min-data-value) or         tgroup/colspec[2]/normalize-space(@coldef) = ('txt', 'txt-no-ldr'))]" mode="calsTables">
        
        <xsl:variable name="tableTemplateName" as="xs:string" select="if (normalize-space(@table-template-name) != '') then              normalize-space(@table-template-name) else ''" />
        <!-- 04/05/2016 mharcourt - Removed amendment-doc condition due to no extant examples -->
        <!--<xsl:variable name="formatValue" as="xs:string"
            select="if (@subformat and 
            normalize-space(@subformat) != '' and
            matches(normalize-space(@subformat),'\d{4}') = true()) then 
            replace(normalize-space(@subformat),'^\D*(\d{4})\D*$','$1') else 
            if (/bill/normalize-space(@bill-stage) = 'Enrolled-Bill' or
            /resolution/normalize-space(@resolution-stage) = 'Enrolled-Bill') then 
            '6511' else '6211'"/>-->
        <!--<xsl:variable name="blankLinesBeforeValue" as="xs:string"
            select="if (normalize-space(@blank-lines-before)) 
            then normalize-space(@blank-lines-before) else '1'"/>-->
        <!--<xsl:variable name="tableType" as="xs:string"
            select="if (normalize-space(@table-type) != '') then
            normalize-space(@table-type) else ''"/>-->
        
        <xsl:copy>
            <xsl:attribute name="colsep" select="0" />
            <xsl:attribute name="frame" select="none" />
            <xsl:attribute name="rowsep" select="0" />
            <xsl:processing-instruction name="xpp">mkfix</xsl:processing-instruction>
            <xsl:apply-templates mode="Leaderwork"><!-- Switch to mode="Leaderwork" here -->
                <xsl:with-param name="tblTemplate" tunnel="yes" select="$tableTemplateName" />
                <!--<xsl:with-param name="fmtValue" tunnel="yes" select="$formatValue"/>-->
                <!--<xsl:with-param name="blbValue" tunnel="yes" select="$blankLinesBeforeValue"/>-->
                <!--<xsl:with-param name="tblType" tunnel="yes" select="$tableType"/>-->
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements CALS Specification items 67.1, 67.2 and 67.3.</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="tgroup" mode="Leaderwork">
        <xsl:variable name="tfoot" select="tfoot" as="element()?" />
        <xsl:variable name="coldefTypeValue" as="xs:string" select="colspec[2]/normalize-space(@coldef)" />
        <xsl:variable name="lastEntry" as="node()">
            <xsl:choose>
                <xsl:when test="count($tfoot[element()]) &gt; 0">
                    <xsl:value-of select="$tfoot/row[last()]/entry[last()]" /> 
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="tbody/row[last()]/entry[last()]" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="reversedStr" select="if (normalize-space(string-join($lastEntry,',')) != '')              then gpo:reverse(normalize-space(string-join($lastEntry,','))) else ''" as="xs:string" />
        <xsl:variable name="finalPunctuations" as="xs:string">
            <xsl:choose>
                <!-- Match on reversed string starting with one or 
                    more regex Punctuation character category characters 
                    (after subtracting "%" character from the match) -->
                <xsl:when test="matches($reversedStr,'^[\p{P}-[%]]+')">
                    <!-- tokenize() with the COMPLEMENT of the regex Punctuation 
                        character category characters (minus "%") on the 
                        reversed string and then reverse the resulting first 
                        sequence of characters -->
                    <xsl:value-of select="gpo:reverse(tokenize($reversedStr,'[\P{P}-[%]]+')[1])" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="finalPunctuation" as="xs:string">
            <xsl:choose>
                <xsl:when test="colspec[last()]/normalize-space(@coldef)='fig' and                     string-length($finalPunctuations) &gt; 0">
                    <xsl:value-of select="$finalPunctuations" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:variable name="afterQuotedBlockChars">
            <xsl:if test="ancestor::table/local-name(following-sibling::*[1]) = 'after-quoted-block'">
                <xsl:choose>
                    <xsl:when test="count(.[ancestor::quoted-block]) = 1">”</xsl:when><!-- Right double quote -->
                    <xsl:when test="count(.[ancestor::quoted-block])&gt;1">‚ ”</xsl:when><!-- Right single quote + thin space + right double -->
                </xsl:choose>
            </xsl:if>
        </xsl:variable>
        
        <xsl:copy>
            <xsl:attribute name="cols" select="2" />
            <xsl:attribute name="rowsep" select="0" />
            <xsl:apply-templates mode="Leaderwork">
                <xsl:with-param name="coldefType" tunnel="yes" select="$coldefTypeValue" />
                <xsl:with-param name="mwtChar" select="$finalPunctuation" tunnel="yes" />
                <xsl:with-param name="aqbChar" select="$afterQuotedBlockChars" tunnel="yes" />
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry/text()[1]" mode="calsTables">
        <xsl:param name="inQB" as="xs:integer" tunnel="yes" />
        
        <xsl:if test="$inQB &gt; 0">
            <xsl:choose>
                <xsl:when test="(count(ancestor::row) = 1 and count(ancestor::entry) = 1 and normalize-space(.) != '' ) or                      ((count(ancestor::row) = 2 and count(ancestor::entry) = 1 and                      ancestor::row/preceding-sibling::row/entry[1]/normalize-space(.) = '' and normalize-space(.) != '' )) and                      ((ancestor::thead or ancestor::table/ttitle) or (ancestor::tbody and not(ancestor::thead) and not(ancestor::table/ttitle)))">
                    <xsl:choose>
                        <xsl:when test="count(.[ancestor::quoted-block]) = 1">“</xsl:when><!-- Left double quote -->
                        <xsl:when test="count(.[ancestor::quoted-block])&gt;1">‘ “</xsl:when><!-- Left single quote + thin space + left double -->
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:if test="count(ancestor::row) &gt; 2 and count(ancestor::entry) = 1 and normalize-space(.) != ''">
                        <xsl:processing-instruction name="xpp">
                            <xsl:text>mwt;</xsl:text>
                            <xsl:choose>
                                <xsl:when test="count(.[ancestor::quoted-block]) = 1">“</xsl:when><!-- Left double quote -->
                                <xsl:when test="count(.[ancestor::quoted-block])&gt;1">‘ “</xsl:when><!-- Left single quote + thin space + left double -->
                            </xsl:choose>
                        </xsl:processing-instruction>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
        <xsl:value-of select="." />
        <!--
            <xsl:value-of select="ancestor::table/following-sibling::*[1]/normalize-space(.)"/>
        -->
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry/text()[1]" mode="Leaderwork">
        <!-- Remove from the first space normalized text node all 
            initial character entities assigned in the Unicode 
            character database belonging to the space category 
            (e.g. NO-BREAK SPACE, EN SPACE, EM SPACE, FIGURE 
            SPACE, THIN SPACE, etc.) using an anchored regex 
            category escape command: '\p{Zs}' -->
        <xsl:value-of select="replace(normalize-space(.),'^(\p{Zs})+', '')" />
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="tfoot" mode="Leaderwork">
        <xsl:copy>
            <xsl:apply-templates mode="Leaderwork" />
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements 67.1.1a through 67.1.5a and 67.2.1a through 67.2.5a</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry[1][ancestor::thead and not(ancestor::table/normalize-space(@table-template-name) =          'Tax (No Calculation) 1 text, 1 num (9 chars) and extra long heads')]" mode="Leaderwork">
        <xsl:copy>
            <xsl:attribute name="align" select="left" />
            <xsl:attribute name="colname" select="column1" />
            <xsl:attribute name="morerows" select="0" />
            <xsl:attribute name="namest" select="column1" />
            <xsl:attribute name="nameend" select="column2" />
            <xsl:attribute name="rowsep" select="0" />
            
            <xsl:if test="((../position() = 1 and                 normalize-space(.) != '') or                  ((../position() = 2 and                 ancestor::thead/row[1]/entry[1]/normalize-space(.) = ''))) and                 ancestor::after-quoted-block">
                <xsl:text>“</xsl:text><!-- &#x201C; is the Unicode Character 
                    'LEFT DOUBLE QUOTATION MARK' (U+201C)-->
            </xsl:if>
            <xsl:processing-instruction name="xpp">mk;;14.10p</xsl:processing-instruction>
            <xsl:apply-templates mode="Leaderwork" />
            <xsl:processing-instruction name="xpp">rmk;28p;16p</xsl:processing-instruction>
            <xsl:processing-instruction name="xpp">tq;13</xsl:processing-instruction>
            <xsl:if test="following-sibling::entry/normalize-space(.) = ''">
                <xsl:text>&amp;#x20;</xsl:text>
            </xsl:if>
            <xsl:apply-templates select="following-sibling::entry" mode="Leaderwork" />
            <xsl:processing-instruction name="xpp">xmk;0;0</xsl:processing-instruction>
            <xsl:processing-instruction name="xpp">lz</xsl:processing-instruction>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements 67.1.1b through 67.1.5b and 67.2.1b through 67.2.5b</xd:p>
            <xd:p>Note: Suppress entire entry because data was pulled into column1.</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry[2][ancestor::thead and not(ancestor::table/normalize-space(@table-template-name) =          'Tax (No Calculation) 1 text, 1 num (9 chars) and extra long heads')]" mode="Leaderwork" /><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements 67.3.1a</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry[1][ancestor::thead and ancestor::table/normalize-space(@table-template-name) =          'Tax (No Calculation) 1 text, 1 num (9 chars) and extra long heads']" mode="Leaderwork">
        <xsl:copy>
            <xsl:attribute name="align" select="left" />
            <xsl:attribute name="colname" select="column1" />
            <xsl:attribute name="morerows" select="0" />
            <xsl:attribute name="rowsep" select="0" />
            <xsl:attribute name="namest" select="column1" />
            <xsl:if test="./normalize-space(.) != '' and                  following-sibling::entry/normalize-space(.) != ''">
                <xsl:attribute name="nameend" select="column2" />
            </xsl:if>

            <xsl:if test="((../position() = 1 and                 normalize-space(.) != '') or                  ((../position() = 2 and                 ancestor::thead/row[1]/entry[1]/normalize-space(.) = ''))) and                 ancestor::after-quoted-block">
                <xsl:text>“</xsl:text><!-- &#x201C; is the Unicode Character 
                    'LEFT DOUBLE QUOTATION MARK' (U+201C)-->
            </xsl:if>
            <xsl:choose>
                <xsl:when test="./normalize-space(.) != '' and                      following-sibling::entry/normalize-space(.) != ''">
                    <xsl:processing-instruction name="xpp">mk;;14.10p</xsl:processing-instruction>
                    <xsl:apply-templates mode="Leaderwork" />
                    <xsl:processing-instruction name="xpp">rmk;28p;14p</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">in;16p</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">i1;&amp;-2p</xsl:processing-instruction>
                    <xsl:apply-templates select="following-sibling::entry" mode="Leaderwork" />
                    <xsl:processing-instruction name="xpp">xmk;0;0</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">lz</xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates mode="Leaderwork" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements 67.3.1b</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry[2][ancestor::thead and ancestor::table/normalize-space(@table-template-name) =          'Tax (No Calculation) 1 text, 1 num (9 chars) and extra long heads']" mode="Leaderwork">
        <xsl:choose>
            <!-- Suppress second entry if preceding sibling is non-null -->
            <xsl:when test="./normalize-space(.) != '' and                  preceding-sibling::entry/normalize-space(.) != ''" />
            <xsl:otherwise><!-- Don't suppress the current entry -->
                <xsl:copy>
                    <xsl:attribute name="align" select="right" />
                    <xsl:attribute name="colname" select="column2" />
                    <xsl:attribute name="morerows" select="0" />
                    <xsl:attribute name="rowsep" select="0" />
                    <xsl:attribute name="namest" select="column2" />
                    <xsl:apply-templates mode="Leaderwork" />
                </xsl:copy>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements 67.1.6a</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry[1][ancestor::tbody and          ancestor::tgroup/colspec[2]/normalize-space(coldef) = 'fig']" mode="Leaderwork">
        <xsl:copy>
            <xsl:apply-templates mode="Leaderwork" />
            <xsl:if test="not(normalize-space(.) = '')">
                <xsl:processing-instruction name="xpp">l-b-leader</xsl:processing-instruction>
            </xsl:if>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements 67.1.6b</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry[2][ancestor::tbody and          ancestor::tgroup/colspec[2]/normalize-space(coldef) = 'fig']" mode="Leaderwork">
        <xsl:param name="mwtChar" as="xs:string" tunnel="yes" required="no" />
        <xsl:param name="aqbChar" as="xs:string" tunnel="yes" />

        <xsl:copy>
            <xsl:apply-templates mode="Leaderwork" />
            <xsl:choose>
                <!-- 08/11/2016 mharcourt Revised condition to check string length
                based on email from Deb Galligan that says mwt PI only goes out 
                if the length is exactly one. -->
                <xsl:when test="../count(following-sibling::row) &gt; 0 and                     string-length($mwtChar) = 1"><!-- i.e., not the final row in the table -->
                    <xsl:processing-instruction name="xpp">mwt;<xsl:value-of select="$mwtChar" /></xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise><!-- last row in tbody -->
                    <xsl:if test="../position() = last() and                         $aqbChar != ''">
                        <xsl:value-of select="$aqbChar" />
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements 67.2.6a</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry[1][ancestor::tbody and          not(ancestor::tgroup/colspec[2]/normalize-space(coldef) = 'fig')]" mode="Leaderwork">
        <xsl:copy>
            <xsl:apply-templates mode="Leaderwork" />
            <xsl:if test="not(normalize-space(.) = '')">
                <xsl:processing-instruction name="xpp">bill-leader</xsl:processing-instruction>
            </xsl:if>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements 67.2.6b</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="entry[2][ancestor::tbody and          not(ancestor::tgroup/colspec[2]/normalize-space(coldef) = 'fig')]" mode="Leaderwork">
        <xsl:param name="mwtChar" as="xs:string" tunnel="yes" required="no" />
        <xsl:param name="aqbChar" as="xs:string" tunnel="yes" />
        
        <xsl:copy>
            <xsl:apply-templates mode="Leaderwork" />
            <xsl:choose>
                <!-- 08/11/2016 mharcourt Revised condition to check string length
                based on email from Deb Galligan that says mwt PI only goes out 
                if the length is exactly one. -->
                <xsl:when test="../count(following-sibling::row) &gt; 0 and                     string-length($mwtChar) = 1"><!-- i.e., not the final row in the table -->
                    <xsl:processing-instruction name="xpp">mwt;<xsl:value-of select="$mwtChar" /></xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise><!-- last row in tbody -->
                    <xsl:if test="../position() = last() and                         ancestor::table/local-name(following-sibling::*[1]) = 'after-quoted-block' and                         ancestor::table/following-sibling::*[1]/normalize-space(text) = '.'">
                        <xsl:value-of select="$aqbChar" />
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements CALS Specification items 67.1, 67.2 and 67.3.</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="colspec[1]" mode="Leaderwork">
        <!-- coldef="txt" align="left" colname="column1" colwidth="158q"/> -->
        <xsl:copy>
            <xsl:attribute name="coldef" select="normalize-space(@coldef)" />
            <xsl:attribute name="align" select="left" />
            <xsl:attribute name="colname" select="column1" />
            <xsl:attribute name="colwidth">
                <xsl:choose>
                    <!-- 67.1 -->
                    <xsl:when test="following-sibling::colspec/normalize-space(@coldef) = 'fig'">
                        <xsl:text>*+250q</xsl:text>
                    </xsl:when>
                    <!-- 67.2, 67.3 -->
                    <xsl:otherwise>
                        <xsl:text>158q</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
        </xsl:copy>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p>Implements CALS Specification items 67.1, 67.2 and 67.3.</xd:p>
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="colspec[2]" mode="Leaderwork">
        <xsl:param name="tblTemplate" tunnel="yes" as="xs:string" />
        
        <xsl:copy>
            <xsl:attribute name="coldef" select="normalize-space(@coldef)" />
            <xsl:attribute name="align" select="right" />
            <xsl:attribute name="colname" select="column2" />
            <xsl:attribute name="colsep" select="0" />
            <xsl:attribute name="colwidth">
                <xsl:choose>
                    <xsl:when test="normalize-space(@coldef) = 'fig'">
                        <xsl:choose>
                            <xsl:when test="normalize-space(@minDataValue) = ('0','1','2','3','4','5')">25q</xsl:when>
                            <xsl:when test="normalize-space(@minDataValue) = ('6','7','8','9')">44q</xsl:when>
                            <xsl:otherwise>68q</xsl:otherwise><!-- i.e. 10 or more -->
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>*+158q</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
        </xsl:copy>
        <xsl:processing-instruction name="xpp">tblwidth;28p</xsl:processing-instruction>
        <xsl:processing-instruction name="xpp">setctr;2p</xsl:processing-instruction>
        <xsl:processing-instruction name="xpp">setgut;col;0;10.4q</xsl:processing-instruction> 
        <xsl:processing-instruction name="xpp">setstyle;0;2;xin</xsl:processing-instruction> 
        <xsl:processing-instruction name="xpp">setallh;sz;10q</xsl:processing-instruction> 
        <xsl:processing-instruction name="xpp">setallh;le;2q</xsl:processing-instruction>
        <xsl:processing-instruction name="xpp">setall;sz;10q</xsl:processing-instruction> 
        <xsl:processing-instruction name="xpp">setall;le;2q</xsl:processing-instruction> 
        <xsl:if test="following::thead">
            <xsl:variable name="theadRowCount" select="count(following::thead/row)" as="xs:integer" />
            
            <xsl:if test="$theadRowCount &gt; 1">
                <xsl:for-each select="1 to ($theadRowCount - 1)">
                    <xsl:processing-instruction name="xpp">setgut;row;<xsl:value-of select="position()" />;5.4q</xsl:processing-instruction>
                </xsl:for-each>
                <xsl:for-each select="1 to ($theadRowCount)">
                    <xsl:processing-instruction name="xpp">setstylh;1;0;fv;2</xsl:processing-instruction> 
                    <xsl:processing-instruction name="xpp">setstylh;2;0;fv;2</xsl:processing-instruction>
                    <xsl:choose>
                        <!-- 67.3 -->
                        <xsl:when test="$tblTemplate = 'Tax (No Calculation) 1 text, 1 num (9 chars) and extra long heads'">
                            <xsl:processing-instruction name="xpp">setstylh;1;0;in;20q</xsl:processing-instruction> 
                            <xsl:processing-instruction name="xpp">setstylh;1;0;i1;&amp;-20q</xsl:processing-instruction> 
                            <xsl:processing-instruction name="xpp">setstylh;2;0;in;20q</xsl:processing-instruction> 
                            <xsl:processing-instruction name="xpp">setstylh;2;0;i1;&amp;-20q</xsl:processing-instruction>
                        </xsl:when>
                        <!-- 67.1, 67.2 -->
                        <xsl:otherwise>
                            <xsl:processing-instruction name="xpp">setstylh;1;0;in;10q</xsl:processing-instruction> 
                            <xsl:processing-instruction name="xpp">setstylh;1;0;i1;&amp;-10q</xsl:processing-instruction> 
                            <xsl:processing-instruction name="xpp">setstylh;2;0;in;10q</xsl:processing-instruction> 
                            <xsl:processing-instruction name="xpp">setstylh;2;0;i1;&amp;-10q</xsl:processing-instruction>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:if>
        </xsl:if>
        <xsl:processing-instruction name="xpp">setstyle;0;0;l1;(%lddesc+%ldextra)</xsl:processing-instruction>
        <xsl:choose>
            <!-- 67.1 -->
            <xsl:when test="normalize-space(@coldef) = 'fig'">
                <xsl:processing-instruction name="xpp">setstyle;0;1;in;30q</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">setstyle;0;1;i1;&amp;-10q</xsl:processing-instruction>        
            </xsl:when>
            <!-- 67.2, 67.3 -->
            <xsl:otherwise>
                <xsl:processing-instruction name="xpp">setstyle;0;0;in;20q</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">setstyle;0;0;i1;&amp;-10q</xsl:processing-instruction>        
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" match="after-quoted-block[local-name(preceding-sibling::*[1]) = 'table' and         preceding-sibling::*[1]         [normalize-space(@table-type) = ('Leaderwork', 'Leaderwork,Tax', 'subformat',          'Tax', 'subformat-2-Tax-Rate') and          normalize-space(@table-template-name) = ('Tax (No Calculation)', 'Entry: 2 text, bold hds',          'Flush/hang, 1 text, 1 num, bold hds', 'Generic: 1 text, 1 num', 'Generic: 2 text, 1st longer',          'Generic: 2 text, even cols', 'Tax (No Calculation) 1 text, 1 num (9 chars) and extra long heads') and         tgroup/normalize-space(@cols) = '2' and          tgroup/colspec[1]/normalize-space(@coldef) = 'txt' and          ((tgroup/colspec[2]/normalize-space(@coldef) = 'fig' and         tgroup/colspec[2]/@min-data-value) or         tgroup/colspec[2]/normalize-space(@coldef) = ('txt', 'txt-no-ldr'))]]" priority="2" mode="calsTables" /><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="style" />
        <xd:param name="qValue" />
        <xd:param name="contextElement" />
    </xd:doc><xsl:template xmlns:gpo="http://www.gpo.gov" name="getBoxGutterPIs">
        <xsl:param name="style" as="xs:string" tunnel="yes" />
        <xsl:param name="qValue" as="xs:string" tunnel="yes" />
        <xsl:param name="contextElement" as="element()" tunnel="yes" />
        
        <!-- 08/17/2016 mharcourt Per email feedback from dgalligan (Deb Galligan) dated Wed 8/10/2016 2:27 PM 
            and titled "1st Feedback for tabular transforms" attached Excel worksheet Row 6, 7 and 8, the 
            value returned should be a decimal that ends in .4, as in 5.4 given a qValue of 10.
            Not an integer. Therefore, after dividing by 2 to obtain an integer, add .4 rather than 4.  -->
        <xsl:variable name="boxThickness" select="xs:integer(floor(number($qValue) div 2)) + .4" as="xs:double" />
        <!-- 08/17/2016 mharcourt Per email feedback from dgalligan (Deb Galligan) dated Wed 8/10/2016 2:27 PM 
            and titled "1st Feedback for tabular transforms" attached Excel worksheet Row 7, the 
            value returned should be a decimal that ends in .4, as in 10.4 given a qValue of 10.
            Not an integer. Therefore, add .4 rather than 4.  -->
        <xsl:variable name="colThickness" select="xs:integer(number($qValue)) + .4" as="xs:double" />
        <!-- 08/17/2016 mharcourt Per email feedback from dgalligan (Deb Galligan) dated Wed 8/10/2016 2:27 PM 
            and titled "1st Feedback for tabular transforms" attached Excel worksheet Row 8, the 
            value returned should be a decimal that ends in .4, as in 15.4 given a qValue of 10.
            Not an integer. Therefore, add .4 rather than 4.  -->
        <xsl:variable name="rowThickness" select="xs:integer(floor(number($qValue) * 1.5)) + .4" as="xs:double" />
        
        <!-- 08/17/2016 mharcourt Revised conditional block groups and added Item numbers while 
            implementing bug fixes specified by email feedback from dgalligan (Deb Galligan) 
            dated Wed 8/10/2016 2:27 PM and titled "1st Feedback for tabular transforms" -->
        <xsl:choose>
            <!-- 102.1 and 102.2 -->
            <xsl:when test="$contextElement/tgroup/normalize-space(@rowsep) = '1' and                  not($contextElement/tgroup/@thead-tbody-ldg-size)">
                <xsl:choose>
                    <!-- Case 102.1  -->
                    <xsl:when test="$style = 'Enrolled-Bill'">
                        <xsl:choose>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'all' or                                 $contextElement/normalize-space(@frame) = '' or                                 not($contextElement/normalize-space(@frame))">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'topbot'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;4.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'top'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'bottom'">
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'sides'">
                                <xsl:processing-instruction name="xpp">setbgut;lsidbox;4.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;rsidbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'none'">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;0q</xsl:processing-instruction>
                            </xsl:when>
                        </xsl:choose>
                        <xsl:processing-instruction name="xpp">setgut;col;0;8.4q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Changed setgut;row;0;8.4q 
                            to setgut;row;0;12.4q per change tracking in 
                            XSLT-directions_03-03-2016_track.docx -->                        
                        <xsl:processing-instruction name="xpp">setgut;row;0;12.4q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Added conditional to insert 
                            <?xpp setbgut;topbox;4.4q?> per change tracking in 
                            XSLT-directions_03-03-2016_track.docx -->
                        <xsl:if test="(ancestor::tgroup|ancestor::table)[normalize-space(@colsep) = '1'] and                              $contextElement/normalize-space(@frame) = ('bottom','sides','none')">
                            <xsl:processing-instruction name="xpp">setbgut;topbox;4.4q</xsl:processing-instruction>
                        </xsl:if>
                    </xsl:when>
                    
                    <!-- Case 102.2  -->
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'all' or                                 $contextElement/normalize-space(@frame) = '' or                                 not($contextElement/normalize-space(@frame))">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;5.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'topbot'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;5.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;5.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'top'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;5.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'bottom'">
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;5.4q</xsl:processing-instruction>
                            </xsl:when><xsl:when test="$contextElement/normalize-space(@frame) = 'sides'">
                                <xsl:processing-instruction name="xpp">setbgut;lsidbox;5.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;rsidbox;5.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'none'">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;0q</xsl:processing-instruction>
                            </xsl:when>
                        </xsl:choose>
                        <xsl:processing-instruction name="xpp">setgut;col;0,10.4q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Changed setgut;row;0;10.4q 
                            to setgut;row;0;15.4q per change tracking in 
                            XSLT-directions_03-03-2016_track.docx and
                            XSLT-directions_03-08-2016_track.docx -->                        
                        <xsl:processing-instruction name="xpp">setgut;row;0;15.4q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Added conditional to insert 
                            <?xpp setbgut;topbox;4.4q?> per change tracking in 
                            XSLT-directions_03-03-2016_track.docx -->
                        <xsl:if test="(ancestor::tgroup|ancestor::table)[normalize-space(@colsep) = '1'] and                              $contextElement/normalize-space(@frame) = ('bottom','sides','none')">
                            <xsl:processing-instruction name="xpp">setbgut;topbox;5.4q</xsl:processing-instruction>
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>            
            </xsl:when>
            <!-- 102.3 -->
            <xsl:when test="$contextElement/tgroup/normalize-space(@rowsep) = '1' and                 $contextElement/tgroup/@thead-tbody-ldg-size">
                <xsl:choose>
                    <xsl:when test="$contextElement/normalize-space(@frame) = 'all' or                         $contextElement/normalize-space(@frame) = '' or                         not($contextElement/normalize-space(@frame))">
                        <xsl:processing-instruction name="xpp">setbgut;allbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="$contextElement/normalize-space(@frame) = 'topbot'">
                        <xsl:processing-instruction name="xpp">setbgut;topbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">setbgut;btmbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="$contextElement/normalize-space(@frame) = 'top'">
                        <xsl:processing-instruction name="xpp">setbgut;topbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="$contextElement/normalize-space(@frame) = 'bottom'">
                        <xsl:processing-instruction name="xpp">setbgut;btmbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="$contextElement/normalize-space(@frame) = 'sides'">
                        <xsl:processing-instruction name="xpp">setbgut;lsidbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">setbgut;rsidbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                        <!-- 03/17/2016 mharcourt - Added two new PIS per change tracking in 
                            XSLT-directions_03-08-2016_track.docx -->
                        <xsl:processing-instruction name="xpp">setbrul;lsidbox;.4q</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">setbrul;rsidbox;.4q</xsl:processing-instruction> 
                    </xsl:when>
                    <xsl:when test="$contextElement/normalize-space(@frame) = 'none'">
                        <xsl:processing-instruction name="xpp">setbgut;allbox;0q</xsl:processing-instruction>
                    </xsl:when>
                </xsl:choose>
                <xsl:processing-instruction name="xpp">setgut;col;0;<xsl:value-of select="$colThickness" />q</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">setgut;row;0;<xsl:value-of select="$rowThickness" />q</xsl:processing-instruction>
                <!-- 03/15/2016 mharcourt Added conditional to insert PI for 
                    setbgut;topbox; using $colThickness value as specified per 
                    change tracking in XSLT-directions_03-03-2016_track.docx -->
                <xsl:if test="(ancestor::tgroup|ancestor::table)[normalize-space(@colsep) = '1'] and                      $contextElement/normalize-space(@frame) = ('bottom','sides','none')">
                    <xsl:processing-instruction name="xpp">setbgut;topbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                </xsl:if>
            </xsl:when>
            <!-- 102.4 and 102.5 -->
            <xsl:when test="$contextElement/tgroup/normalize-space(@rowsep) = '0' and                 $contextElement/tgroup/@thead-tbody-ldg-size">
                <xsl:choose>
                    <!-- Case 102.4  -->
                    <xsl:when test="$contextElement/tgroup/thead">
                        <xsl:choose>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'all' or                                 $contextElement/normalize-space(@frame) = '' or                                 not($contextElement/normalize-space(@frame))">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'topbot'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'top'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'bottom'">
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'sides'">
                                <xsl:processing-instruction name="xpp">setbgut;lsidbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;rsidbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                                <!-- 03/17/2016 mharcourt - Added two new PIS per change tracking in 
                                    XSLT-directions_03-08-2016_track.docx -->
                                <xsl:processing-instruction name="xpp">setbrul;lsidbox;.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbrul;rsidbox;.4q</xsl:processing-instruction> 
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'none'">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;0q</xsl:processing-instruction>
                            </xsl:when>
                        </xsl:choose>
                        <xsl:processing-instruction name="xpp">setgut;col;0;<xsl:value-of select="$colThickness" />q</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">setgut;row;1;<xsl:value-of select="$rowThickness" />q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Added conditional to insert PI for 
                            setbgut;topbox; using $colThickness value as specified per 
                            change tracking in XSLT-directions_03-03-2016_track.docx -->
                        <xsl:if test="(ancestor::tgroup|ancestor::table)[normalize-space(@colsep) = '1'] and                              $contextElement/normalize-space(@frame) = ('bottom','sides','none')">
                            <xsl:processing-instruction name="xpp">setbgut;topbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                        </xsl:if>
                    </xsl:when>
                    <!-- Case 102.5  -->
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'all' or                                 $contextElement/normalize-space(@frame) = '' or                                 not($contextElement/normalize-space(@frame))">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'topbot'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'top'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'bottom'">
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'sides'">
                                <xsl:processing-instruction name="xpp">setbgut;lsidbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;rsidbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                                <!-- 03/17/2016 mharcourt - Added two new PIS per change tracking in 
                                    XSLT-directions_03-08-2016_track.docx -->
                                <xsl:processing-instruction name="xpp">setbrul;lsidbox;.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbrul;rsidbox;.4q</xsl:processing-instruction> 
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'none'">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;0q</xsl:processing-instruction>
                            </xsl:when>
                        </xsl:choose>
                        <xsl:processing-instruction name="xpp">setgut;col;0;<xsl:value-of select="$colThickness" />q</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">setgut;row;1;0q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Added conditional to insert PI for 
                            setbgut;topbox; using $colThickness value as specified per 
                            change tracking in XSLT-directions_03-03-2016_track.docx -->
                        <xsl:if test="(ancestor::tgroup|ancestor::table)[normalize-space(@colsep) = '1'] and                              $contextElement/normalize-space(@frame) = ('bottom','sides','none')">
                            <xsl:processing-instruction name="xpp">setbgut;topbox;<xsl:value-of select="$boxThickness" />q</xsl:processing-instruction>
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <!-- 102.6 and 102.7 -->
            <xsl:when test="$contextElement/tgroup/normalize-space(@rowsep) = '0' and                 not($contextElement/tgroup/@thead-tbody-ldg-size)">
                <xsl:choose>
                    <!-- Case 102.6  -->
                    <xsl:when test="$contextElement/tgroup/thead and                         $style = 'Enrolled-Bill'">
                        <xsl:choose>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'all' or                                 $contextElement/normalize-space(@frame) = '' or                                 not($contextElement/normalize-space(@frame))">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'topbot'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;4.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'top'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'bottom'">
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'sides'">
                                <xsl:processing-instruction name="xpp">setbgut;lsidbox;4.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;rsidbox;4.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'none'">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;0q</xsl:processing-instruction>
                            </xsl:when>
                        </xsl:choose>
                        <xsl:processing-instruction name="xpp">setgut;col;0;8.4q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Changed setgut;row;0;8.4q 
                            to setgut;row;0;12.4q per change tracking in 
                            XSLT-directions_03-03-2016_track.docx -->                        
                        <xsl:processing-instruction name="xpp">setgut;row;1;12.4q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Added conditional to insert 
                            <?xpp setbgut;topbox;4.4q?> per change tracking in 
                            XSLT-directions_03-03-2016_track.docx -->
                        <xsl:if test="(ancestor::tgroup|ancestor::table)[normalize-space(@colsep) = '1'] and                              $contextElement/normalize-space(@frame) = ('bottom','sides','none')">
                            <xsl:processing-instruction name="xpp">setbgut;topbox;4.4q</xsl:processing-instruction>
                        </xsl:if>
                    </xsl:when>
                    <!-- Case 102.7  -->
                    <xsl:when test="not($contextElement/tgroup/thead) and                         $style != 'Enrolled-Bill'">
                        <xsl:choose>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'all' or                                 $contextElement/normalize-space(@frame) = '' or                                 not($contextElement/normalize-space(@frame))">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;5.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'topbot'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;5.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;5.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'top'">
                                <xsl:processing-instruction name="xpp">setbgut;topbox;5.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'bottom'">
                                <xsl:processing-instruction name="xpp">setbgut;btmbox;5.4q</xsl:processing-instruction>
                            </xsl:when><xsl:when test="$contextElement/normalize-space(@frame) = 'sides'">
                                <xsl:processing-instruction name="xpp">setbgut;lsidbox;5.4q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">setbgut;rsidbox;5.4q</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="$contextElement/normalize-space(@frame) = 'none'">
                                <xsl:processing-instruction name="xpp">setbgut;allbox;0q</xsl:processing-instruction>
                            </xsl:when>
                        </xsl:choose>
                        <xsl:processing-instruction name="xpp">setgut;col;0,10.4q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Changed setgut;row;0;10.4q 
                            to setgut;row;0;15.4q per change tracking in 
                            XSLT-directions_03-03-2016_track.docx and
                            XSLT-directions_03-08-2016_track.docx -->                        
                        <xsl:processing-instruction name="xpp">setgut;row;1;0q</xsl:processing-instruction>
                        <!-- 03/15/2016 mharcourt Added conditional to insert 
                            <?xpp setbgut;topbox;4.4q?> per change tracking in 
                            XSLT-directions_03-03-2016_track.docx -->
                        <xsl:if test="(ancestor::tgroup|ancestor::table)[normalize-space(@colsep) = '1'] and                              $contextElement/normalize-space(@frame) = ('bottom','sides','none')">
                            <xsl:processing-instruction name="xpp">setbgut;topbox;5.4q</xsl:processing-instruction>
                        </xsl:if>
                    </xsl:when>
                </xsl:choose>            
            </xsl:when>
        </xsl:choose>
    </xsl:template><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="allRows" />
        <xd:param name="currentRow" />
        <xd:return />
    </xd:doc><xsl:function xmlns:gpo="http://www.gpo.gov" name="gpo:parentRowPosition" as="xs:integer*">
        <xsl:param name="allRows" as="node()*" />
        <xsl:param name="currentRow" as="node()" />
        
        <xsl:sequence select="             for $seq in (1 to count($allRows))             return $seq[$allRows[$seq] is $currentRow]             " />
    </xsl:function><xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" xmlns:gpo="http://www.gpo.gov">
        <xd:desc>
            <xd:p />
        </xd:desc>
        <xd:param name="input" />
    </xd:doc><xsl:function xmlns:gpo="http://www.gpo.gov" name="gpo:reverse">
        <xsl:param name="input" as="xs:string" />
        <xsl:sequence select="codepoints-to-string(             reverse(string-to-codepoints($input)))" />
    </xsl:function>
    
    <xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="insertNewlineBeforeElement" as="xs:string">
        <xsl:text>
		</xsl:text>
    </xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gOutputComment" as="xs:string">1</xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="needsAllMark" as="xs:string">
        <xsl:choose>
            <xsl:when test="//bill[contains(@bill-stage, 'Enrolled-Bill')] or  //bill/@bill-stage = 'Pre-Introduction'">no</xsl:when>
            <xsl:when test="//resolution[contains(@resolution-stage, 'Enrolled-Bill')] or  //resolution/@resolution-stage = 'Pre-Introduction'">no</xsl:when>
            <xsl:when test="//bill[starts-with(@bill-stage, 'Introduced-in-')] or //resolution[starts-with(@resolution-stage, 'Introduced-in-')]">yes</xsl:when>
            <xsl:when test="//resolution[starts-with(@resolution-stage, 'Introduced-in-') or (not(contains(@resolution-stage, 'Enrolled-Bill')) and  @resolution-stage != 'Pre-Introduction')]">yes</xsl:when>
            <xsl:when test="(not(//attestation) and not(//endorsement))">yes</xsl:when>
            <xsl:otherwise>no</xsl:otherwise>
        </xsl:choose>
    </xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="lc-docstage" as="xs:string" select="lower-case(/bill/@bill-stage)" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="billstage" as="xs:string?" select="//bill/@bill-stage" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="bill-public-print" as="xs:string?" select="//bill/@public-print" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="bill-star-print" as="xs:string?" select="/bill/@star-print" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="billtype" as="xs:string?" select="//bill/@bill-type" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="amendstage" as="xs:string?" select="//amendment-doc/@amend-stage" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="amend-id" as="xs:string" select="//amendment-doc/@id" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="amend-num" as="xs:string">
        <xsl:choose>
            <xsl:when test="//legis-num"><xsl:value-of select="//legis-num" /></xsl:when>
            <xsl:otherwise>
                <xsl:variable name="text"><xsl:value-of select="substring-before(/amendment-doc/engrossed-amendment-body[1]/section[1]/text[1], ')')" /></xsl:variable>
                <xsl:value-of select="substring-after($text, '(')" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="public-print" as="xs:string" select="//amendment-doc/@public-print" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="current-chamber" as="xs:string" select="//amendment-doc/@current-chamber" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="amendtype" as="xs:string?" select="//amendment-doc/@amend-type" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="resstage" as="xs:string?" select="//resolution/@resolution-stage" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="restype" as="xs:string?" select="//resolution/@resolution-type" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="res-public-print" as="xs:string" select="//resolution/@public-print" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="res-star-print" as="xs:string?" select="//resolution/@star-print" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="isStandAloneVote" as="xs:string">
        <xsl:choose>
            <xsl:when test="//committee-report-form/@display='no'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="docstage" as="xs:string">
        <xsl:choose>
            <xsl:when test="not($billstage='')">
                <xsl:value-of select="$billstage" />
            </xsl:when>
            <xsl:when test="not($resstage='')">
                <xsl:value-of select="$resstage" />
            </xsl:when>
            <xsl:when test="not($amendstage='')">
                <xsl:value-of select="$amendstage" />
            </xsl:when>
        </xsl:choose>
    </xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="doctype" as="xs:string">
        <xsl:choose>
            <xsl:when test="not($billtype='')">
                <xsl:value-of select="$billtype" />
            </xsl:when>
            <xsl:when test="not($restype='')">
                <xsl:value-of select="$restype" />
            </xsl:when>
            <xsl:when test="not($amendtype='')">
                <xsl:value-of select="$amendtype" />
            </xsl:when>
        </xsl:choose>
    </xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="m_legisNumber" as="xs:string?" select="//legis-num" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="m_isCommitteeReport" as="xs:string">
        <xsl:choose>
            <xsl:when test="//committee-report">
                <xsl:text>Yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>No</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="m_isShortTitle" as="xs:string">
        <xsl:choose>
            <xsl:when test="//short-title">
                <xsl:text>Yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>No</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gvLegisNumChamber" as="xs:string">
        <xsl:choose>
            <xsl:when test="contains($m_legisNumber, 'H')">House</xsl:when>
            <xsl:when test="contains($m_legisNumber, 'S')">Senate</xsl:when>
            <xsl:otherwise>LegisNumUnchambered</xsl:otherwise>
        </xsl:choose>
    </xsl:variable><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gvStageChamber" as="xs:string">
        <xsl:choose>
            <xsl:when test="contains($docstage, 'House') or contains($docstage, 'HOUSE')">House</xsl:when>
            <xsl:when test="contains($docstage, 'Senate') or contains($docstage, 'SENATE')">Senate</xsl:when>
            <xsl:otherwise>StageUnchambered</xsl:otherwise>
        </xsl:choose>
    </xsl:variable><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:outputComment" as="item()*">
        <xsl:param name="s" as="item()*" />
        
        <xsl:if test="$gOutputComment = '1'">
         <xsl:comment>
             <xsl:value-of select="$s" />
         </xsl:comment>
        </xsl:if>
        
    </xsl:function><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="xsltsl-str-lower" select="'abcdefghijklmnopqrstuvwxyzµàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĺļľŀłńņňŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżžſƃƅƈƌƒƕƙơƣƥƨƭưƴƶƹƽƿǅǆǈǉǋǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǲǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȣȥȧȩȫȭȯȱȳɓɔɖɗəɛɠɣɨɩɯɲɵʀʃʈʊʋʒͅάέήίαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώϐϑϕϖϛϝϟϡϣϥϧϩϫϭϯϰϱϲϵабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљњћќѝўџѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӈӌӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӹաբգդեզէըթժիլխծկհձղճմյնշոչպջռսվտրցւփքօֆḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕẛạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹἀἁἂἃἄἅἆἇἐἑἒἓἔἕἠἡἢἣἤἥἦἧἰἱἲἳἴἵἶἷὀὁὂὃὄὅὑὓὕὗὠὡὢὣὤὥὦὧὰάὲέὴήὶίὸόὺύὼώᾀᾁᾂᾃᾄᾅᾆᾇᾐᾑᾒᾓᾔᾕᾖᾗᾠᾡᾢᾣᾤᾥᾦᾧᾰᾱᾳιῃῐῑῠῡῥῳⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻⅼⅽⅾⅿⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ𐐨𐐩𐐪𐐫𐐬𐐭𐐮𐐯𐐰𐐱𐐲𐐳𐐴𐐵𐐶𐐷𐐸𐐹𐐺𐐻𐐼𐐽𐐾𐐿𐑀𐑁𐑂𐑃𐑄𐑅𐑆𐑇𐑈𐑉𐑊𐑋𐑌𐑍'" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="xsltsl-str-upper" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZΜÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞŸĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮIĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŹŻŽSƂƄƇƋƑǶƘƠƢƤƧƬƯƳƵƸƼǷǄǄǇǇǊǊǍǏǑǓǕǗǙǛƎǞǠǢǤǦǨǪǬǮǱǱǴǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȢȤȦȨȪȬȮȰȲƁƆƉƊƏƐƓƔƗƖƜƝƟƦƩƮƱƲƷΙΆΈΉΊΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΣΤΥΦΧΨΩΪΫΌΎΏΒΘΦΠϚϜϞϠϢϤϦϨϪϬϮΚΡΣΕАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯЀЁЂЃЄЅІЇЈЉЊЋЌЍЎЏѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӁӃӇӋӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӸԱԲԳԴԵԶԷԸԹԺԻԼԽԾԿՀՁՂՃՄՅՆՇՈՉՊՋՌՍՎՏՐՑՒՓՔՕՖḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔṠẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸἈἉἊἋἌἍἎἏἘἙἚἛἜἝἨἩἪἫἬἭἮἯἸἹἺἻἼἽἾἿὈὉὊὋὌὍὙὛὝὟὨὩὪὫὬὭὮὯᾺΆῈΈῊΉῚΊῸΌῪΎῺΏᾈᾉᾊᾋᾌᾍᾎᾏᾘᾙᾚᾛᾜᾝᾞᾟᾨᾩᾪᾫᾬᾭᾮᾯᾸᾹᾼΙῌῘῙῨῩῬῼⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ𐐀𐐁𐐂𐐃𐐄𐐅𐐆𐐇𐐈𐐉𐐊𐐋𐐌𐐍𐐎𐐏𐐐𐐑𐐒𐐓𐐔𐐕𐐖𐐗𐐘𐐙𐐚𐐛𐐜𐐝𐐞𐐟𐐠𐐡𐐢𐐣𐐤𐐥'" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="xsltsl-str-digits" select="'0123456789'" /><xsl:variable xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="xsltsl-str-ws" select="' 	&#xD;&#xA;+-)('" /><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Turns lowercase text into uppercase text.</desc>
        <param>String</param>
        <return>Uppercase text, i.e., 'abc' to 'ABC'</return>
        <gpo:srcXSL>Named Template:  str:to-upper</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:to-upper" as="xs:string?">
        <xsl:param name="text" as="xs:string" />
        <xsl:value-of select="upper-case($text)" />
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Turns uppercase text into lower text.</desc>
        <param>String</param>
        <return>Lowercase text, i.e., 'ABC' to 'abc'</return>
        <gpo:srcXSL>Named Template:  str:to-lower</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:to-lower" as="xs:string?">
        <xsl:param name="text" as="xs:string" />
        <xsl:value-of select="lower-case($text)" />
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Turns a phrase into camelcase text. The template gpo:capitalize and gpo:captialize-first are
        based on written functions by Priscilla Walmsley (Datapic).  When sending strings to this function, add a space to the
        front of the string in order for the function to grab the first word.</desc>        
        <param>String</param>
        <return>Lowercase text, i.e., 'now is the time' to 'Now Is The time'</return>
        <gpo:srcXSL>Named Template:  capitalise</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:capitalize" as="item()*">
        <xsl:param name="text" as="xs:string?" />           
            <xsl:sequence select="                 string-join(                 for $word in tokenize($text,'\s+')                 return gpo:capitalize-first-word($word)                 ,' ')                 " />
    </xsl:function><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:capitalize-first-word" as="xs:string?">
            <xsl:param name="text" as="xs:string?" /> 
            <xsl:variable name="string-length"><xsl:value-of select="string-length($text)" /></xsl:variable>
            <xsl:variable name="remove-uppercase"><xsl:value-of select="string-length(translate($text, 'ABCDEFGHIJKLMOPQRSTUVWXYZ', ''))" /></xsl:variable>
            <xsl:choose>
                <!--Issue #519 -->
                <xsl:when test="$text='and' or $text='for' or $text='on' or $text='a' or                      $text='an' or $text='as' or $text='at' or $text='but' or $text='by' or $text='in'                      or $text='nor' or $text='of' or $text='or' or $text='to' or $text='the'  or $text='if'                     or $text='etc'">
                    <xsl:value-of select="$text" /></xsl:when>
                <xsl:when test="(number($string-length) - number($remove-uppercase)) &gt; 1">
                    <xsl:value-of select="$text" />
                </xsl:when>
                <xsl:when test="count(translate($text, 'ABCDEFGHIJKLMOPQRSTUVWXYZ', '')) = 0"><xsl:value-of select="$text" /></xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="                         concat(upper-case(substring($text,1,1)),                         substring($text,2))                         " />         
                </xsl:otherwise>
            </xsl:choose>           
        </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Takes the first part of the string before the content of $char.</desc>
        <param>text</param>
        <param>chars</param>
        <return>Truncate following text, i.e., "John Doe" = "John" when 'chars' param is " Doe".</return>
        <gpo:srcXSL>Named Template:  str:substring-before-first</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:substring-before-first" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="chars" />
        <xsl:value-of select="substring-before($text, $chars)" />
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Takes the last part of the string before the content of $char.</desc>
        <param>text</param>
        <param>chars</param>
        <return>Remove first part of text, i.e., "John Doe" = "Doe" when 'chars' param is "John ".</return>
        <gpo:srcXSL>Named Template:  str:substring-after-last</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:substring-after-last" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="chars" />
        <xsl:value-of select="substring-after($text, $chars)" />
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Translates string within text to another string.</desc>
        <param name="text">The original text</param>
        <param name="from-text">Text to be translated</param>
        <param name="to-text">Resulting text.</param>
        <return>Translate "The time is 10:00 EST" - result:  "The time is 10:00 PST"</return>
        <gpo:srcXSL>Named Template:  str:subst</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:substitute-string" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="from-text" />
        <xsl:param name="to-text" />
        <xsl:value-of select="replace($text, $from-text, $to-text)" />
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Translates the last string within text to another string.</desc>
        <param name="text">The original text</param>
        <param name="from-text">Text to be translated</param>
        <param name="to-text">Resulting text.</param>
        <return>Translate "The time is 10:00 EST in New York and 10:00 EST in California" - result:  "The time is 10:00 EST in New York and 07:00 PST in California "</return>
        <gpo:srcXSL>Named Template:  str:substring-before-last</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:substring-before-last" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="from-text" />
        <xsl:param name="to-text" />
        <xsl:variable name="count"><xsl:value-of select="count(tokenize($text, $from-text)) - 1" /></xsl:variable>
        <xsl:variable name="createString">
        <xsl:for-each select="tokenize($text, $from-text)">
            <xsl:choose>
                <xsl:when test="position() = $count"><xsl:value-of select="concat(., $to-text)" /></xsl:when>
                <xsl:when test="position() = last()"><xsl:value-of select="." /></xsl:when>
                <xsl:otherwise><xsl:value-of select="." /><xsl:value-of select="$from-text" /></xsl:otherwise>
            </xsl:choose>            
        </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="string($createString)" />
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Counts the number of the times a string occurs in a string.</desc>
        <param name="text">The original text</param>
        <param name="string">The string to be counted</param>
        <return>How much wood would a woodchuck chuck chuck if a woodchuck could chuck wood = 5</return>
        <gpo:srcXSL>Named Function:  str:count-substring</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:count-substring" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="count-string" />       
       <xsl:value-of select="count(tokenize($text, $count-string)) -1" />       
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Takes the end of a string based on character position and string.</desc>
        <param name="text">The original text</param>
        <param name="char">The string that is used as the lookup</param>
        <param name="position">The beginning position of the $char to be used.</param>
        <return>(position = 16, char = 'and 'Border Security and Immigration Act = Immigration Act</return>
        <gpo:srcXSL>Named Functon:  str:substring-after-at</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:substring-after-at" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="char" />
        <xsl:param name="position" />
        <xsl:variable name="total-char"><xsl:value-of select="string-length($text)" /></xsl:variable>
        <xsl:variable name="char-count"><xsl:value-of select="string-length($char)" /></xsl:variable>
        <xsl:variable name="to-position"><xsl:value-of select="number($position) + $char-count" /></xsl:variable>
        <xsl:variable name="start-char"><xsl:value-of select="substring($text, number($position), ($total-char))" /></xsl:variable>
        <xsl:if test="starts-with($start-char, $char)">
        <xsl:value-of select="substring-after($start-char, $char)" />
        </xsl:if>    
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Inserts a string at a given location.</desc>
        <param name="text">The original text</param>
        <param name="char">The string to be inserted</param>
        <param name="position">The beginning position of the $char to be used.</param>
        <return>(position = 16, char = 'and', text="Border Security Immigration Act = Border Security and Immigration Act</return>
        <gpo:srcXSL>Named Functon:  str:insert-at</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:insert-at" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="char" />
        <xsl:param name="position" />
        <xsl:variable name="total-char"><xsl:value-of select="string-length($text)" /></xsl:variable>
        <xsl:variable name="before-text"><xsl:value-of select="substring($text, 1, number($position))" /></xsl:variable>
        <xsl:variable name="after-text"><xsl:value-of select="substring($text, number($position), number($total-char))" /></xsl:variable>
        <xsl:value-of select="concat($before-text, $char, $after-text)" />    
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Reverses the location of a string.</desc>
        <param name="text">The original text</param>
        <return>abcde = edcba</return>
        <gpo:srcXSL>Named Functon:  str:backward</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:backward" as="xs:string">
        <xsl:param name="text" />
        <xsl:variable name="string-length"><xsl:value-of select="string-length($text)" /></xsl:variable>
        <xsl:variable name="mirror">
            <xsl:value-of select="gpo:build-mirror($text, $string-length)" />
        </xsl:variable>
        <xsl:value-of select="substring($mirror, string-length($text) + 1, string-length($text))" />
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Worker function for 'gpo.function'.</desc>
        <param name="text">The original text</param>
        <param name="char">The string to be inserted</param>
        <param name="position">The beginning position of the $char to be used.</param>
        <return>(position = 16, char = 'and', text="Border Security Immigration Act = Border Security and Immigration Act</return>
        <gpo:srcXSL>Named Functon:  str:insert-at</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:build-mirror" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="string-length" />
        <xsl:choose>
            <xsl:when test="$string-length &gt; 0">
                <xsl:variable name="text" select="concat($text, substring($text, $string-length, 1))" />
                <xsl:variable name="string-length" select="$string-length - 1" />
                <xsl:value-of select="gpo:build-mirror($text, $string-length)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="string($text)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Worker function for 'gpo:string-match'.</desc>
        <param name="text">Text String</param>
        <param name="char">String to match</param>
        <return>Returns 1 when string is matched and 0 when string is not matched.</return>
        <gpo:srcXSL>Named Functon:  gpo:string-match</gpo:srcXSL>
    </doc><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:string-match" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="char" />
        <xsl:choose>
          <xsl:when test="contains($text, $char)">1</xsl:when>
          <xsl:otherwise>0</xsl:otherwise>            
        </xsl:choose>
    </xsl:function><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:generate-string" as="xs:string">
        <xsl:param name="text" />
        <xsl:param name="count" />
        <xsl:variable name="number"><xsl:value-of select="number($count)" /></xsl:variable>
        <xsl:variable name="concat-text">
        <xsl:for-each select="1 to $number">
            <xsl:value-of select="$text" />
        </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="$concat-text" />
    </xsl:function><xsl:function xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:isNumeric" as="xs:boolean">
        <xsl:param name="s" as="xs:string" />
        <xsl:value-of select="matches($s, '^[0-9]+$')" />
    </xsl:function><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="enum" mode="go">
		<xsl:if test="parent::node()/@display-inline='yes-display-inline' and local-name(../preceding-sibling::*[1])='text'">
			<xsl:text> </xsl:text>
		</xsl:if>
		
	    <xsl:variable name="linesOffOn" as="xs:string?" select="gpo:getLineNumbersValue(.)" />
		
		<xsl:variable name="reportedDisplayStyle" as="xs:string?">		
			<xsl:if test="./@vbattChangedForReported != ''">
				<xsl:value-of select="./@vbattChangedForReported" />
			</xsl:if>
			<xsl:if test="not(@vbattChangedForReported != '') and @reported-display-style !=''">
				<xsl:value-of select="@reported-display-style" />
			</xsl:if>
		</xsl:variable>		
		<xsl:variable name="beginingOfEnumNumPhrase" as="xs:string?">
			<xsl:if test="$linesOffOn = 'off'">
				<xsl:call-template name="getBegginingOfThePhraseLiseOff">
					<xsl:with-param name="aBeginingFor">
						<xsl:text>enumNumber</xsl:text>
					</xsl:with-param>
					<xsl:with-param name="aReportingStyle" select="$reportedDisplayStyle" />					
				</xsl:call-template>
			</xsl:if>
		</xsl:variable>

		<xsl:variable name="isExceptionalHeaderAllSmallCaps" as="xs:string">
			<xsl:choose>				
				<xsl:when test="following-sibling::header/@header-style = 'All-Small-Caps'">
					<xsl:text>yes</xsl:text>
				</xsl:when>				
				<xsl:otherwise>
					<xsl:text>no</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="endOfEnumNumPhrase" as="xs:string?">
			<xsl:if test="$linesOffOn = 'off'">
				<xsl:call-template name="getEndOfThePhraseLiseOff">
					<xsl:with-param name="aBeginingFor">
						<xsl:text>enumNumber</xsl:text>
					</xsl:with-param>
					<xsl:with-param name="aReportingStyle" select="$reportedDisplayStyle" />					
				</xsl:call-template>
			</xsl:if>
		</xsl:variable>

		<xsl:value-of select="$beginingOfEnumNumPhrase" />

		<xsl:choose>
			<xsl:when test="$isExceptionalHeaderAllSmallCaps = 'yes'">
				<xsl:variable name="enumValueToPrint" as="xs:string">
					<xsl:apply-templates mode="process" />
				</xsl:variable>
				<xsl:value-of select="lower-case($enumValueToPrint)" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates mode="process" />
			</xsl:otherwise>
		</xsl:choose>
		
		<xsl:value-of select="$endOfEnumNumPhrase" />
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="enum" mode="belK"> <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="enum" mode="goTrad">
		<xsl:variable name="style" as="xs:string" select="gpo:GetNearestAncestorStyleRecursive(., true())" />
			
		
		
	    <xsl:variable name="linesOffOn" as="xs:string?" select="gpo:getLineNumbersValue(.)" />
			
		<xsl:variable name="reportedDisplayStyle" as="xs:string?">		
			<xsl:if test="./@vbattChangedForReported != ''">
				<xsl:value-of select="./@vbattChangedForReported" />
			</xsl:if>
			<xsl:if test="not(./@vbattChangedForReported != '') and ./@reported-display-style !=''">
				<xsl:value-of select="./@reported-display-style" />
			</xsl:if>
		</xsl:variable>
		
		<xsl:variable name="beginingOfEnumTextPhrase" as="xs:string?">
			<xsl:if test="$linesOffOn = 'off'">
				<xsl:call-template name="getBegginingOfThePhraseLiseOff">
					<xsl:with-param name="aBeginingFor">
						<xsl:text>enumNumber</xsl:text>
					</xsl:with-param>
					<xsl:with-param name="aReportingStyle" select="$reportedDisplayStyle" />
					<xsl:with-param name="aStyle" select="$style" />
				</xsl:call-template>
			</xsl:if>
		</xsl:variable>
		
		<xsl:variable name="endOfEnumTextPhrase" as="xs:string?">
			<xsl:if test="$linesOffOn = 'off'">
				<xsl:call-template name="getEndOfThePhraseLiseOff">
					<xsl:with-param name="aBeginingFor">
						<xsl:text>enumNumber</xsl:text>
					</xsl:with-param>
					<xsl:with-param name="aReportingStyle" select="$reportedDisplayStyle" />
					<xsl:with-param name="aStyle" select="$style" />
				</xsl:call-template>
			</xsl:if>
		</xsl:variable>
		
		<xsl:if test="../../*[@display-inline='yes-display-inline']">
			<xsl:variable name="enumContent" as="node()*">
				<xsl:apply-templates mode="process" />
			</xsl:variable>
			<xsl:choose>
				
				<xsl:when test="(./added-phrase or ./deleted-phrase)">
					<xsl:apply-templates mode="process" />
				</xsl:when>
				<xsl:when test="starts-with($style , 'archaic') and parent::subsection">
					<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					<xsl:value-of select="$beginingOfEnumTextPhrase" />
					<xsl:value-of select="normalize-space(string(.))" />
					<xsl:value-of select="$endOfEnumTextPhrase" />
				</xsl:when>
				<xsl:when test="starts-with($style , 'traditional') and (./added-phrase or ./deleted-phrase)">
					<xsl:value-of select="gpo:escapeWithBelKandBelT4(normalize-space(string($enumContent)),'(\([a-z]+\))')" />
				</xsl:when>
				<xsl:when test="starts-with($style , 'traditional')">
					<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					<xsl:value-of select="gpo:rawRegexReplace(string(.), '([A-Za-z])', '$1')" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="gpo:escapeWithBelKandBelT4(normalize-space(string(.)),'(\([a-z]+\))')" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>

		<xsl:if test="not(../../*[@display-inline='yes-display-inline'])">
			
			<xsl:variable name="enumContent" as="node()">
				<xsl:apply-templates mode="process" />
			</xsl:variable>

			
			<xsl:variable name="includesLetters" as="xs:string">
				<xsl:choose>
					<xsl:when test="replace(., '[\p{Lu}]|[\p{Ll}]', '', 'm') = .">
						<xsl:text>no</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>yes</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:choose>
				
				<xsl:when test="(./added-phrase or ./deleted-phrase)">
					<xsl:apply-templates mode="process" />
				</xsl:when>

				<xsl:when test="starts-with($style , 'traditional') and       not(child::deleted-phrase or child::added-phrase) and       $includesLetters ='yes'">
									
					<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					<xsl:value-of select="gpo:rawRegexReplace(string(.), '([A-Za-z])', '$1')" />
				</xsl:when>
				
				<xsl:otherwise>
					<xsl:value-of select="$beginingOfEnumTextPhrase" />
					<xsl:value-of select="$enumContent" />
					<xsl:value-of select="$endOfEnumTextPhrase" />
				</xsl:otherwise>
			</xsl:choose>		
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="rules-clause-header " mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="enum" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="insertQ4BillLangCommitteeReport">
		<xsl:variable name="theNextElement" as="xs:string"><!-- 09/28/2015 mharcourt elminate "trivial documents" by defining type -->
			<xsl:choose>
				<xsl:when test="following-sibling::*[1]  and local-name(following-sibling::*[1]) != 'after-quoted-block'">
					<xsl:value-of select="local-name(following::*[1])" />
				</xsl:when>							
				<xsl:when test=" ancestor::*[1]/following-sibling::*[1]  and local-name (ancestor::*[1]/following-sibling::*[1] ) != 'after-quoted-block'">
					<xsl:value-of select="local-name(ancestor::*[1]/following::*[1])" />
				</xsl:when>
				<xsl:when test="ancestor::*[2]/following-sibling::*[1] ">
					<xsl:value-of select="local-name(ancestor::*[2]/following-sibling::*[1] )" />
				</xsl:when>
				<xsl:when test="ancestor::*[3]/following-sibling::*[1] ">
					<xsl:value-of select="local-name(ancestor::*[3]/following-sibling::*[1] )" />
				</xsl:when>	
				<xsl:when test="ancestor::*[4]/following-sibling::*[1] ">
					<xsl:value-of select="local-name(ancestor::*[4]/following-sibling::*[1] )" />
				</xsl:when>	
				<xsl:otherwise>
					<xsl:value-of select="local-name(following::*/text[text != ''])" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="not(//committee-report) or not(ancestor::amendment-block)">
				<xsl:text>no</xsl:text>
			</xsl:when>
			<xsl:when test="$theNextElement = 'subsection' or $theNextElement ='paragraph' or $theNextElement='subparagraph' or $theNextElement='clause' or $theNextElement='subclause' or $theNextElement='item' or $theNextElement='subitem'">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>no</xsl:text>
			</xsl:otherwise>
		</xsl:choose>		
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="specialPrintIndexTable">
		<para format="6659">
			<xsl:apply-templates mode="indexTableCommitteeReport" />
		</para>
		<para format="6602" />
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="ttitle" mode="indexTableCommitteeReport">
		<para loc="21">
			<xsl:value-of select="upper-case(.)" />
		</para>
		<para loc="22" />
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="thead/row[position()=1]/entry[@colname='column2']/italic" mode="indexTableCommitteeReport">
		<para loc="23">
			<xsl:value-of select="." />
		</para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="thead/row[position()=2]/entry[@colname='column2']/italic" mode="indexTableCommitteeReport">
		<para loc="24">
			<xsl:value-of select="." />
		</para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="thead/row[position()=2]/entry[@colname='column3']/italic" mode="indexTableCommitteeReport">
		<para loc="25">
			<xsl:value-of select="." />
		</para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="tbody/row/entry[position()=1]" mode="indexTableCommitteeReport">
		<xsl:element name="para">
			<xsl:attribute name="loc">
				<xsl:choose>
					<xsl:when test="(@stub-hierarchy='1' or not(@stub-hierarchy)) and @leader-modify='clr-ldr'">
						<xsl:text>27</xsl:text>
					</xsl:when>
					
					<xsl:when test="@stub-hierarchy='1' or not(@stub-hierarchy)">
						<xsl:text>26</xsl:text>
					</xsl:when>
					<xsl:when test="@stub-hierarchy='2'  and @leader-modify='clr-ldr'">
						<xsl:text>29</xsl:text>
					</xsl:when>
					<xsl:when test="@stub-hierarchy='2' ">
						<xsl:text>28</xsl:text>
					</xsl:when>			
					<xsl:when test="@stub-hierarchy='3' ">
						<xsl:text>30</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>30</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
			<xsl:value-of select="." />
		</xsl:element>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="tbody/row/entry[position()=2]" mode="indexTableCommitteeReport">
		<para loc="41">
			<xsl:value-of select="." />
		</para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="tbody/row/entry[position()=3]" mode="indexTableCommitteeReport">
		<para loc="42">
			<xsl:value-of select="." />
		</para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="metadata" mode="process">
		<xsl:if test="./dc:title or ./dc:publisher ">
			<command>
				<xsl:call-template name="copy-node-deep" />
			</command>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="running-header" priority="1" mode="process">
		<xsl:if test="not(attribute::display='no')">
			<para loc="81">
				<xsl:apply-templates mode="process" />
			</para>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="signature-line" mode="process">
		<xsl:if test="not(@display='no')">
			<para loc="78">
				<xsl:text>                                         .....................................................................</xsl:text>
			</para>
			<para loc="78">
				<xsl:text>                                          </xsl:text>
				<xsl:apply-templates mode="process" />
			</para>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="author-note" mode="process">
		<!-- NB 6/16/2006 Wrapped the logic of this template in an if so that there must be text in it to do anything (processing instructions shouldn't count) -->
		<xsl:variable name="contents" as="node()">
			<xsl:value-of select="." />
		</xsl:variable>
		<xsl:if test="not($contents='')">
			<xsl:if test="not(@display='no')">
				<para loc="95">
					<xsl:apply-templates mode="process" />
				</para>
			</xsl:if>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="first-page-header" mode="process">
		<xsl:if test="$m_isCommitteeReport='Yes'">
			<para loc="46">
				<xsl:apply-templates mode="process" />
			</para>
		</xsl:if>
		<xsl:if test="not(@display='no' or ../@display='no') and $m_isCommitteeReport='No'">
			<para loc="39">
				<xsl:apply-templates mode="process" />
			<xsl:if test="($amendtype='senate-amendment'      or  $amendtype='Amendment' )">
			    <xsl:processing-instruction name="xpp">lp;&amp;04q</xsl:processing-instruction><xsl:text>  </xsl:text>
			</xsl:if></para>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="first-page-date" mode="process">
		<!-- SM: We may need to empolyee this code. @display !='no' and string-length(./text()) != 0 -->
		<xsl:if test="not(@display='no') ">
			<xsl:if test="./text()">
				<para loc="46">
					<xsl:value-of select="." />
				</para>
			</xsl:if>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="first-page-desc[@display='yes' or not(@display)]" mode="process">
		<xsl:if test="text() !=''">
			<xsl:element name="para">
				<xsl:attribute name="loc">
			<xsl:choose>
				<xsl:when test="//committee-report">
					<xsl:text>18</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>61</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
				</xsl:attribute>
			</xsl:element>
			<para loc="46"><xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			</para>
			<xsl:choose>
				<xsl:when test="//committee-report">
					<para loc="20">
				    <xsl:processing-instruction name="xpp">lp;&amp;36q</xsl:processing-instruction>
				</para>
				</xsl:when>
				<xsl:otherwise>
					<para loc="61" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="legis-counsel" mode="process">
		<xsl:if test="not (@display='no') and not(//pre-form/@display='no') and not(//resolution/@resolution-stage='Reported-in-Senate')">
			<para loc="82">
				<xsl:apply-templates mode="process" />
			</para>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="reintroduction-code" mode="process">
		<xsl:if test="not(@display='no')">
			<para loc="60">
				<xsl:apply-templates mode="process" />
			</para>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="suspension-floor-action" priority="1" mode="process">
		<xsl:if test="not(//amendment-form) and not(attribute::display='no')">
			<para loc="74">
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			</para>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="suspension-instructions" priority="1" mode="process">
		<xsl:if test="not(//amendment-form) and not(attribute::display='no')">
			<para loc="74">
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			</para>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="*[name() != 'running-header'][@display='no']" priority="1" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="*[@commented='hidden']" priority="1" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="para" mode="process">
	<xsl:choose>
	<xsl:when test="text() = ''" />
	<xsl:when test=". = ''" />
	<xsl:otherwise>
		<xsl:element name="para">
			<xsl:attribute name="loc">
				<xsl:choose>
					<xsl:when test="@para-indent='1'">
						<xsl:text>20</xsl:text>
					</xsl:when>
					<xsl:when test="@para-indent='2'">
						<xsl:text>22</xsl:text>
					</xsl:when>
					<xsl:when test="@para-indent='3'">
						<xsl:text>24</xsl:text>
					</xsl:when>
					<xsl:when test="@para-indent='4'">
						<xsl:text>26</xsl:text>
					</xsl:when>
					<xsl:when test="@para-indent='5'">
						<xsl:text>28</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::letter-body">
					    <xsl:choose>
						<xsl:when test="not(local-name(preceding-sibling::*[1]) = 'salutation')">
							<xsl:text>21</xsl:text>
						</xsl:when>
					        <xsl:otherwise>
					            <xsl:text>20</xsl:text>
					        </xsl:otherwise>
					    </xsl:choose>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>20</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		    <!--Issue #421-->
		    <xsl:if test="ancestor::quoted-block">
		        <xsl:text>“</xsl:text>
		    </xsl:if>
			<xsl:apply-templates mode="process" />
		</xsl:element>
		</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="pagebreak" name="pagebreak" mode="process">
        <xsl:param name="noPageBreak" as="xs:string?" />
        <xsl:if test="local-name(preceding-sibling::*[1]) ='linebreak'  and (parent::*/parent::section or parent::*/parent::subsection or parent::*/parent::paragraph or parent::*/parent::subparagraph or parent::*/parent::clause or parent::*/parent::subclause or parent::*/parent::item or parent::*/parent::subitem) and not ($noPageBreak ='true') ">
            <para loc="13">
                <xsl:text> </xsl:text>	
            </para>
        </xsl:if>
        <xsl:if test="not(following-sibling::text() and ancestor::amendment-instruction/text)">
            <xsl:choose>
                <xsl:when test="$noPageBreak ='true'">
                    <!-- nothing -->
                </xsl:when>
                <xsl:when test=" (preceding-sibling::text() and following-sibling::text()) or (not(preceding-sibling::text()) and (parent::resolution-body or parent::legis-body) and following-sibling::*/@display-inline='yes-display-inline')">
                    <xsl:if test="not(../linebreak) and not(not(preceding-sibling::text()) and  (parent::resolution-body or parent::legis-body)) and not (//committee-report)">
                        <!--<xsl:text>&lt;ASC208&gt;</xsl:text>-->
                       <!-- <para loc="13">
                            <xsl:text>&#x2003;</xsl:text>	
                        </para>-->
                    </xsl:if>
                   <xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>
                    <xsl:call-template name="returnToPreviousLocator" />
                    <xsl:if test=" ./text/pagebreak/following-sibling::text()">
                        <xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>
                    </xsl:if>
                </xsl:when>
                <xsl:otherwise>	
                    <xsl:if test="(ancestor::*[@commented='yes']) and ((not(following-sibling) or not(following-sibling::*[@display-inline='yes-display-inline'])) and  not(local-name(following::*[1]) = 'after-quoted-block'))">
                        <xsl:text>❩</xsl:text>
                    </xsl:if>
                    <xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>
                    <xsl:call-template name="returnToPreviousLocator" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
        <xsl:if test="parent::official-title and not($noPageBreak ='true')">
            <para loc="53" />
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="pagebreak" name="pagebreak_old" mode="pagebreak">
		<xsl:param name="noPageBreak" as="xs:string?" /> 
		<xsl:if test="local-name(preceding-sibling::*[1]) ='linebreak'  and (parent::*/parent::section or parent::*/parent::subsection or parent::*/parent::paragraph or parent::*/parent::subparagraph or parent::*/parent::clause or parent::*/parent::subclause or parent::*/parent::item or parent::*/parent::subitem) and not ($noPageBreak ='true') ">
			<para loc="13">
				<xsl:text> </xsl:text>	
			</para>
		</xsl:if>
		<xsl:if test="not(following-sibling::text() and ancestor::amendment-instruction/text)">
			<xsl:choose>
				<xsl:when test="$noPageBreak ='true'">
					<!-- nothing TB 9June2009 bug fixing #1024 -->
				</xsl:when>
				<xsl:when test=" (preceding-sibling::text() and following-sibling::text()) or (not(preceding-sibling::text()) and (parent::resolution-body or parent::legis-body) and following-sibling::*/@display-inline='yes-display-inline')">
					<!-- NB 1/5/2007 - Added clause from new clause in when because we already have an ASC208 when there is an enacting clause preceding this. -->
					<xsl:if test="not(../linebreak) and not(not(preceding-sibling::text()) and  (parent::resolution-body or parent::legis-body)) and not (//committee-report)">
					    <!-- issue #40 -->
					    <!--<para loc="13">
							<xsl:text>&#x2003;</xsl:text>	
						</para>-->
					</xsl:if>
					<!-- SM 1/10/2007 Space was added to end of <BEL>A -->
					
					<!--<xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>-->
				   
					<!-- Bug #507 SM 3/5/07  I29 should be outputed  for whereas-->
					<!-- TB #742 -->
					<xsl:call-template name="returnToPreviousLocator" />
					
				    <xsl:if test=" ./text/pagebreak/following-sibling::text()">
						<xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>
					</xsl:if>
					
				</xsl:when>
			
				<xsl:otherwise>	
					<!-- TB 10Oct2009 Bug Fixing #1064 -->
					<xsl:if test="(ancestor::*[@commented='yes']) and ((not(following-sibling) or not(following-sibling::*[@display-inline='yes-display-inline'])) and  not(local-name(following::*[1]) = 'after-quoted-block'))">
						<xsl:text>❩</xsl:text>
					</xsl:if>
				    <!--BH:  I am commenting this out because it looks like this is being output in wrong location-->
					<!--<xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>-->
					<!-- TB #742 -->
					<xsl:call-template name="returnToPreviousLocator" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
		
		<!-- TB 15Oct2007 the commented logic removed. For review see revision #425 of version control -->
		
		<xsl:if test="parent::official-title and not($noPageBreak ='true')">
			<para loc="53" />
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quoted-block/para" mode="process"> 
		<xsl:choose>
		    <xsl:when test="preceding-sibling::table[1]"><para><xsl:copy-of select="node() | @*" /></para></xsl:when>
		    <xsl:when test="text() = ''" />
		    <xsl:otherwise>
		<xsl:element name="para">
			<xsl:attribute name="loc">
				<xsl:choose>
					<xsl:when test="./@para-indent='1'">
						<xsl:text>20</xsl:text>
					</xsl:when>
					<xsl:when test="./@para-indent='2'">
						<xsl:text>22</xsl:text>
					</xsl:when>
					<xsl:when test="./@para-indent='3'">
						<xsl:text>24</xsl:text>
					</xsl:when>
					<xsl:when test="./@para-indent='4'">
						<xsl:text>26</xsl:text>
					</xsl:when>
					<xsl:when test="./@para-indent='5'">
						<xsl:text>28</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>20</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
			<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
		   <xsl:apply-templates mode="process" />
		   
	    
		</xsl:element>
		    </xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="graphic" mode="process">
		<xsl:if test="image-data != ''">
			<xsl:variable name="prevFormat" as="xs:string">
				<xsl:call-template name="AddorDelete" />
			</xsl:variable>
			<!-- put format first -->
			<xsl:if test="contains($prevFormat, 'S6201')">
				<para format="6602" />
			</xsl:if>
		    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
			<xsl:if test="graphic-caption/@location = 'above'">				
				<xsl:call-template name="printGraphicCaption" />
			</xsl:if>	
			
			<!-- 09/01/2015 mharcourt XSLT 2.0 refactoring. In the absence of XPP graphic processsing specs, wrapped  
				graphic merge information into new variable that is output as an XML comment in upcoming para element.
				Revisit once the XPP formatting team supplies graphic processing specs. -->
			<xsl:variable name="gsCommand" as="xs:string"><!-- 09/28/2015 mharcourt elminate "trivial documents" by defining type -->
				<xsl:text>gs</xsl:text><!--<xsl:text disable-output-escaping="yes">				
&lt;BEL&gt;gs</xsl:text>-->
				<xsl:choose>
					<xsl:when test="@halign = 'left'">
						<xsl:text>,il</xsl:text>
					</xsl:when>
					<xsl:when test="@halign = 'right'">
						<xsl:text>,ir</xsl:text>
					</xsl:when>
					<xsl:when test="@graphic-indent != ''">
						<xsl:text>,i</xsl:text>
						<xsl:value-of select="@graphic-indent" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>,ic</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
				
				<xsl:text>,d</xsl:text>
				<xsl:value-of select="number(@depth) + 20" />
				<xsl:if test="@rotation != ''">
					<xsl:text>,r</xsl:text>
					<xsl:choose>
						<xsl:when test="@rotation='p'">
							<xsl:text>1</xsl:text>
						</xsl:when>
						<xsl:when test="@rotation='l'">
							<xsl:text>2</xsl:text>
						</xsl:when>
						<xsl:when test="@rotation='i'">
							<xsl:text>3</xsl:text>
						</xsl:when>
						<xsl:when test="@rotation='il'">
							<xsl:text>4</xsl:text>
						</xsl:when>
					</xsl:choose>
					
				</xsl:if>
			</xsl:variable>
			
			<para loc="95">
				<xsl:comment>Microcomp graphic merge command: <xsl:value-of select="$gsCommand" /></xsl:comment>
				<xsl:value-of select="gpo:convertGraphic(string(image-data),string(@file))" />
				<xsl:if test="graphic-caption/@location = 'below' or not(graphic-caption/@location)">				
					<xsl:call-template name="printGraphicCaption" />
				</xsl:if>
			
		    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
			</para><!-- call out to the previous format -->
			<!-- put format first -->
			<xsl:if test="$prevFormat != '' and  contains($prevFormat, 'S6201')">				
				<xsl:value-of select="$prevFormat" />
			</xsl:if>
		</xsl:if>
		
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="printGraphicCaption">
		<para loc="96">
			<xsl:choose>
				<xsl:when test="graphic-caption/bold">
					<xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
					<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				</xsl:when>
				<xsl:when test="graphic-caption/italic">
					<xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
					<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				</xsl:when>
			</xsl:choose>
			<!-- open quote -->
			<xsl:if test="graphic-caption/quote">
				<xsl:text>“</xsl:text>
			</xsl:if>
			<xsl:value-of select="graphic-caption" />	
			<!-- close quote -->
			<xsl:if test="graphic-caption/quote">
				<xsl:text>''</xsl:text>
			</xsl:if>
		</para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="returnToPreviousLocator" as="item()*">
        <xsl:variable name="level" as="xs:string">
            <xsl:choose>
                <xsl:when test="parent::*/parent::paragraph or local-name(ancestor::text/parent::*) = 'paragraph'">
                    <xsl:text>paragraph</xsl:text>
                </xsl:when>
                <xsl:when test="ancestor-or-self::whereas and following-sibling::text() != '' and  preceding-sibling::text() !=''">
                    <xsl:text>whereas</xsl:text>
                </xsl:when>
                <xsl:when test="ancestor-or-self::whereas and following-sibling::text() != '' and  (preceding-sibling::text() ='' or not (preceding-sibling::text()))">
                    <xsl:text>whereasPlus</xsl:text>
                </xsl:when>
                <xsl:when test="ancestor-or-self::whereas and (following-sibling::text() = '' or not (following-sibling::text()))">
                    <xsl:text>whereasPlus</xsl:text>
                </xsl:when>
                <xsl:when test="parent::*/parent::subparagraph  or local-name(ancestor::text/parent::*) = 'subparagraph'">
                    <xsl:text>subparagraph</xsl:text>
                </xsl:when>
                <xsl:when test="parent::*/parent::clause  or local-name(ancestor::text/parent::*) = 'clause'">
                    <xsl:text>clause</xsl:text>
                </xsl:when>
                <xsl:when test="parent::*/parent::subclause or local-name(ancestor::text/parent::*) = 'subclause'">
                    <xsl:text>subclause</xsl:text>
                </xsl:when>
                <xsl:when test="parent::*/parent::item or local-name(ancestor::text/parent::*) = 'item'">
                    <xsl:text>item</xsl:text>
                </xsl:when>
                <xsl:when test="parent::*/parent::subitem or local-name(ancestor::text/parent::*) = 'subitem'">
                    <xsl:text>subitem</xsl:text>
                </xsl:when>
                <xsl:when test="ancestor-or-self::committee-report-para">
                    <xsl:text>committee-report-para</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>section</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
		
        <xsl:choose>
            <xsl:when test="not(following-sibling::text()[1])">
                <!--  if I am not in the middle of the text - not to print returning locator code. The template will print nothing -->
            </xsl:when>
            <xsl:when test="local-name(.)='legis-body' or local-name(..)='official-title-amendment' ">
                <!-- nothing -->
            </xsl:when>
            <!-- TB 29-Jan-2008 Bug #830  I29 was changed to be I27 for whereas clause-->
            <!-- TB Oct2010 bug fixing #1168 -->
            <xsl:otherwise>
                <xsl:variable name="locatorCode" as="xs:integer" select="gpo:actualPutLocatorWithIndent(., 'yes', $level)" />
                <para loc="{$locatorCode}" />
            </xsl:otherwise>			
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="linebreak" name="linebreak" mode="process">
		<xsl:element name="linebreak" />
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quoted-block[@display-inline='yes-display-inline']" mode="process">
		<!-- Cannot use QuotedBlockNestingStart because we are not in the QB yet! COunt is off by 1-->
		<xsl:variable name="countAncQuotedBlock" select="count(ancestor::quoted-block)" as="xs:integer" /><!-- 09/28/2015 mharcourt elminate "trivial documents" by defining type -->
		<xsl:if test="$countAncQuotedBlock mod 2">
			<xsl:text> `</xsl:text>
		</xsl:if>
		<xsl:if test="not($countAncQuotedBlock mod 2)">
			<xsl:text>“</xsl:text>
		</xsl:if>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quoted-block[parent::paragraph][@display-inline='yes-display-inline']/text" mode="process">
       <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="text[parent::quoted-block[@display-inline='no-display-inline' or not(@display-inline)]]" mode="process">
		<!-- Cannot use QuotedBlockNestingStart because we are not in the QB yet! COunt is off by 1-->
		<xsl:variable name="countAncQuotedBlock" select="count(ancestor::quoted-block)" as="xs:integer" />
		<para loc="20">
		    <xsl:text>  </xsl:text>
			<xsl:if test="$countAncQuotedBlock mod 2">
			    <xsl:text>“</xsl:text>
			</xsl:if>
		    <xsl:if test="not($countAncQuotedBlock mod 2)">‘</xsl:if>
		    <xsl:apply-templates mode="process" />    
		    <xsl:if test="not(../*/enum) and not(../*/header) and not(../descendant::continuation-text)">
		        <xsl:text>”</xsl:text>
		        <xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
		    </xsl:if>
		    
		</para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quoted-block[@display-inline='yes-display-inline'][not(parent::paragraph)]/text" mode="process">
        <!-- Cannot use QuotedBlockNestingStart because we are not in the QB yet! COunt is off by 1-->
        <xsl:variable name="countAncQuotedBlock" select="count(ancestor::quoted-block)" as="xs:integer" />
        <xsl:if test="$countAncQuotedBlock mod 2">
                <xsl:text>“</xsl:text>
            </xsl:if>
            <xsl:if test="not($countAncQuotedBlock mod 2)">‘</xsl:if>
           <xsl:apply-templates mode="process" />
            <xsl:if test="not(../*/enum) and not(../*/header) and not(../descendant::continuation-text)">
                <xsl:text>”</xsl:text>
                <xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
            </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quoted-block" mode="inline">
        <!--<xsl:text> &#x201C;<xsl:apply-templates select="*"-->
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="pre-form" mode="PreForm">
		<!-- NB 8/17/2006 - when a part of the match="/", this if included a test for //pre-form
			since it is in a match for this, we no longer need to test for it, so it was removed -->
		<xsl:variable name="toPrintPreForm" as="xs:string"><!-- 09/28/2015 mharcourt elminate "trivial documents" by defining type -->
			<xsl:choose>
				<xsl:when test="@display='no'">
					<xsl:text>no</xsl:text>					
				</xsl:when>
				<xsl:when test="(//meta-senate and count(//meta-senate/child::*) != 0) or (//meta-house and count(//meta-house/child::*) != 0)">
					<xsl:text>yes</xsl:text>
				</xsl:when>
				<xsl:when test="//resolution and contains($docstage,'Senate') or contains($restype,'Senate')">
					<!-- if Senate resolution - print pre-from only if meta senate exists -->
					<!-- we are here if no meta-senate exists -->
					<xsl:text>no</xsl:text>					
				</xsl:when>
				<xsl:when test="//resolution">
					<!-- we are here if it is house resolution -->
					<xsl:text>yes</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>no</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<!-- if no meta-senate or meta-house - not to show the pre-form -->
		<xsl:if test="$toPrintPreForm='yes' and    (//meta-senate or     contains($docstage,'Senate') or     contains($restype,'Senate'))"><!-- 08/28/2015 mharcourt XSLT 2.0 refactoring/simplication. 
				Removed single nested <xsl:if> conditional by moving the inner test into the outer test. -->	
			
			<xsl:variable name="mode" as="xs:string"><!-- 09/28/2015 mharcourt elminate "trivial documents" by defining type -->
				<!-- Mode may not need to distinguish between resolution and insert - depending on how the feedback comes regarding PRBY -->
				<xsl:choose>
					<xsl:when test="/resolution">resolution</xsl:when>
					<xsl:when test="//insert">insert</xsl:when>
					<xsl:otherwise>other</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>

			<xsl:element name="para">
				<xsl:attribute name="format" select="7781" />
			</xsl:element>
			
			<xsl:choose>
				<xsl:when test=".//slc-for">
					<xsl:element name="para">
						<xsl:attribute name="loc" select="05" />
						<xsl:text> FOR: </xsl:text>
						<xsl:if test=".//slc-for-office or        .//slc-for-sponsor or        .//slc-for-staffer">
							<xsl:processing-instruction name="xpp">ff;7</xsl:processing-instruction>
							<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
						</xsl:if>
						<xsl:if test=".//slc-for-office">
							<xsl:if test="not(.='__')">
								<xsl:value-of select=".//slc-for-office" />
							</xsl:if>
						</xsl:if>
						<xsl:if test=".//slc-for-sponsor">
							<xsl:if test="not(.='__')">
								<xsl:text>/</xsl:text>
								<xsl:value-of select=".//slc-for-sponsor" />
							</xsl:if>
						</xsl:if>
						<xsl:if test=".//slc-for-staffer">
							<xsl:if test="not(.='__')">
								<xsl:text>/</xsl:text>
								<xsl:value-of select=".//slc-for-staffer" />
							</xsl:if>
						</xsl:if>
					</xsl:element>
				</xsl:when>
				<xsl:when test="not($mode='other')">
					<xsl:element name="para">
						<xsl:attribute name="loc" select="05" />
						<xsl:text> FOR: </xsl:text>
					</xsl:element>
				</xsl:when>
				<xsl:otherwise>
					<xsl:element name="para">
						<xsl:attribute name="loc" select="05" />
						<xsl:text> </xsl:text>
					</xsl:element>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test=".//slc-subject">
					<xsl:if test=".//slc-subject-field1">
						<para loc="05">
						    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
							<xsl:text> SUB: </xsl:text>
							<xsl:value-of select=".//slc-subject-field1" />
							<xsl:if test=".//slc-subject-field2">
								<xsl:text>/</xsl:text>
								<xsl:value-of select=".//slc-subject-field2" />
							</xsl:if>
							<xsl:if test=".//slc-subject-field3">
								<xsl:text>/</xsl:text>
								<xsl:value-of select=".//slc-subject-field3" />
							</xsl:if>
							<xsl:if test=".//slc-subject-field4">
								<xsl:text>/</xsl:text>
								<xsl:value-of select=".//slc-subject-field4" />
							</xsl:if>
						</para>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="not($mode='other')">
						<para loc="05">
						    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
							<xsl:text> SUB: </xsl:text>
						</para>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test=".//slc-type">
					<para loc="05">
					    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
						<xsl:text> TYP: </xsl:text>
						<xsl:value-of select=".//slc-type" />
					</para>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="not($mode='other')">
						<para loc="05">
						    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
							<xsl:text> TYP: </xsl:text>
						</para>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test=".//slc-description">
					<para loc="05">
					    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
						<xsl:text> DES: </xsl:text>
						<xsl:apply-templates select=".//slc-description" mode="process" />
					</para>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="not($mode='other')">
						<para loc="05">
						    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
							<xsl:text> DES: </xsl:text>
						</para>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test=".//slc-received">
					<para loc="05">
					    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
						<xsl:text> REC: </xsl:text>
						<xsl:value-of select=".//slc-received" />
					</para>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="not($mode='other')">
						<para loc="05">
						    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
							<xsl:text> REC: </xsl:text>
						</para>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test=".//slc-delivered">
					<para loc="05">
						<xsl:text> DLV: </xsl:text>
						<xsl:value-of select=".//slc-delivered" />
					</para>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="not($mode='other')">
						<para loc="05">
							<xsl:text> DLV: </xsl:text>
						</para>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:choose>
				<xsl:when test=".//slc-staff">
					<para loc="05">
					    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
						<xsl:text> STF: </xsl:text>
						<xsl:value-of select=".//slc-staff" />
					</para>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="not($mode='other')">
						<para loc="05">
						    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
							<xsl:text> STF: </xsl:text>
						</para>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
			I<xsl:choose>
				<xsl:when test=".//slc-peer-reviewed-by">
					<para loc="05">
					    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
						<xsl:text> PRBY: </xsl:text>
						<xsl:value-of select=".//slc-peer-reviewed-by" />
					</para>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="not($mode='other')">
						<para loc="05">
						    <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
							<xsl:text> PRBY: </xsl:text>
						</para>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="footnote-ref" mode="process">
		<xsl:param name="forceFootnoteRef" />
	    <xsl:choose>
			<xsl:when test="ancestor::front-matter-back-titlepage and parent::legislator and not ($forceFootnoteRef='yes')">
				<!-- skip -->
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>∖</xsl:text>
				<xsl:value-of select="." />
				<xsl:text>∖</xsl:text>
				<xsl:if test="not(ancestor::committee-vote) and      not(ancestor::front-matter-back-titlepage)">
					<xsl:comment> Commented out insertion of second BELL-N </xsl:comment>
				</xsl:if>
			</xsl:otherwise>
	    </xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="footnote" mode="process">
		<xsl:param name="forceFootnote" as="xs:string" /><!-- 09/28/2015 mharcourt elminate "trivial documents" by defining type --><!-- Parameter is supplied inside an <xsl:apply-templates> command. -->
		<!--<xsl:variable name="idReference" select="@id" as="xs:ID"/>--><!-- 09/28/2015 mharcourt elminate "trivial documents" by defining type -->
		<xsl:variable name="idReference" select="@id" as="xs:string" />
		<xsl:variable name="locator" as="xs:string"><!-- 09/28/2015 mharcourt elminate "trivial documents" by defining type --><!-- 08/28/2015 mharcourt XSLT 2.0 refactoring/simplication -->
			<xsl:choose>
				<xsl:when test="not($forceFootnote='yes') and      (parent::legis-comment or       parent::inline-comment or      parent::enum or       parent::enum-in-header or      parent::quote or      parent::term or      parent::italic)">
					<xsl:text />
				</xsl:when>				
				<xsl:when test="ancestor::committee-vote">
					<xsl:text />
				</xsl:when>
				<xsl:when test="ancestor::front-matter-back-titlepage">
					<xsl:if test="$forceFootnote='yes'">
						<xsl:value-of select="96" />
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="68" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:choose><!-- 08/28/2015 mharcourt XSLT 2.0 refactoring/ simplication -->
			<xsl:when test="not($forceFootnote='yes') and     (parent::legis-comment or      parent::inline-comment or     parent::enum or     parent::enum-in-header or     ancestor::committee-vote or     ancestor::front-matter-back-titlepage or     parent::term or     parent::term or     parent::italic)">
				<!--exclude-->
			</xsl:when>
			<xsl:otherwise>
				<xsl:element name="para">
					<xsl:if test="$locator and $locator!=''">
						<xsl:attribute name="loc"><xsl:value-of select="$locator" /></xsl:attribute>
					</xsl:if>
					<xsl:text>∖</xsl:text><!--<xsl:text>[FRACSLASH]</xsl:text>-->
					<xsl:value-of select="//footnote-ref[@idref=$idReference]" />
					<xsl:text>∖ </xsl:text><!--<xsl:text>[FRACSLASH][[[THINSP]]]</xsl:text>-->
					<xsl:apply-templates mode="process" />
				</xsl:element>
			</xsl:otherwise>
		</xsl:choose>		
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="createLevelLocator">
        <xsl:choose>
            <xsl:when test="name()='title'">78</xsl:when>
            <xsl:when test="name()='section' and @style='traditional'">89</xsl:when>
            <xsl:when test="name()='paragraph' and @style='USC'">22</xsl:when>
            <xsl:when test="name()='paragraph' and @style='OLC'">22</xsl:when>
            <xsl:when test="name()='paragraph' and @style='tax'">22</xsl:when>
            <xsl:when test="name()='paragraph'">20</xsl:when>
            <xsl:when test="name()='subsection'">20</xsl:when>
 <!--           <xsl:when test="name()='subparagraph' and @style='USC'">22</xsl:when>
            <xsl:when test="name()='subparagraph' and @style='OLC'">24</xsl:when>-->
            <xsl:when test="name()='subparagraph'">24</xsl:when>
            <xsl:when test="name()='subparagraph'">22</xsl:when>
            <xsl:when test="name()='clause' and @style='OLC'">26</xsl:when>
            <xsl:when test="name()='clause' and @style='USC'">24</xsl:when>
            <xsl:when test="name()='clause'">26</xsl:when>
            <!--Issue ##317 -->
            <!--<xsl:when test="name()='subclause'  and  @style='traditional'">26</xsl:when>-->
            <xsl:when test="name()='subclause'">28</xsl:when>
            <xsl:when test="name()='item'">30</xsl:when>
            <xsl:when test="name()='subitem'">31</xsl:when>
            <xsl:otherwise>20</xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quoted-block" mode="process">
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="FirstWordCapitalizeHyphen">
        <xsl:param name="text" as="xs:string" />
        <xsl:variable name="string">
        <xsl:for-each select="tokenize(., '-')">
            <xsl:variable name="length" select="string-length(.)" as="xs:double" />
            <xsl:value-of select="upper-case(substring(., 1, 1))" /><xsl:value-of select="substring(., 2, $length)" />
            <xsl:if test="not(position() = last())">-</xsl:if>
        </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="translate($string, ' ', '')" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintOficialTitleInEndorsment">
        <xsl:choose>
            <xsl:when test="contains(lower-case($docstage), 'engrossed') and contains(lower-case($doctype), 'concurrent')">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="ActualPrintEndorsmentActionForPP">
        <xsl:processing-instruction name="xpp">lp;&amp;04q</xsl:processing-instruction>

        <xsl:if test="not(@display = 'no')">
            <para loc="40" />
            <xsl:variable name="text" as="xs:string">
                <xsl:value-of select="." />
            </xsl:variable>
            <xsl:processing-instruction name="xpp">lp;&amp;04q</xsl:processing-instruction>
        </xsl:if>
        <xsl:if test="not(following-sibling::action-desc/@display = 'no')">
            
            <para loc="40">
                <xsl:value-of select="following-sibling::action-desc" />
            </para>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="ActualPrintEndorsmentAction">
        <xsl:if test="not(@display = 'no')">
            <para loc="46">
                <!--			<xsl:text disable-output-escaping="yes">
&lt;BEL&gt;I46</xsl:text>-->
                <!--xsl:value-of select="substring-before(//endorsement/action-date, ' ')"/-->
                <xsl:if test="not(preceding-sibling::action-date)">
                <xsl:processing-instruction name="xpp">lp;&amp;9q</xsl:processing-instruction>
                </xsl:if>
                <xsl:value-of select="substring-before(., ' ')" />
                <!--Issue #57: the month was being output 2x.  Added substring-after.-->
                <xsl:variable name="tempActionDate" as="xs:string">
                    <xsl:value-of select="substring-after(., ' ')" />
                </xsl:variable>
               
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                
                <!--	<xsl:text disable-output-escaping="yes">&lt;BEL&gt;T1 </xsl:text>-->
                
                <!-- SM 08/14/07 Bug #648 -->
                <!-- Fix commented by TB 17-Feb-2010 Bug #1101  -->
                <!--xsl:choose>
				<xsl:when test="not(contains($tempActionDate, '(') and contains($tempActionDate, ')'))">
					<xsl:value-of select="substring-after($tempActionDate, ' ')"/>
				</xsl:when>
				<xsl:when test="not(preceding-sibling::action-date)"-->
                <!--BH:  Need to find out the structure of the ActionDate-->
                <!-- fixes issue #210. We need to add back the space that was removed above 
                    when using substring(). The space exists in the original source -->
                <xsl:text> </xsl:text>
                <xsl:value-of select="$tempActionDate" />
                <!--<xsl:value-of select="lexa:ActionDateText(string($tempActionDate))"/>-->
                <!--/xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="substring-after(substring-before($tempActionDate, '('),' ')"/>
					<xsl:value-of select="substring-after($tempActionDate, ')')"/>
				</xsl:otherwise>
			</xsl:choose-->
            </para>
        </xsl:if>
        
        <xsl:if test="not(following-sibling::action-desc/@display = 'no') and following-sibling::action-desc">
            <para loc="50">
                <xsl:if test="not(preceding-sibling::action-desc)">
                <xsl:processing-instruction name="xpp">lp;&amp;5q</xsl:processing-instruction>
                </xsl:if>
                <!--Issue #383 - look at only first action-desc-->
                <xsl:value-of select="following-sibling::action-desc[1]" />
            </para>
        </xsl:if>
        
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintAnOpeningRuler">
        <xsl:choose>
            <xsl:when test="$billstage = 'Printed-as-Passed'">
                <!-- bug fixing 1314 TB June 2013 -->
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="contains($docstage, 'Enrolled')">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="(lower-case($doctype) = 'house-resolution' or lower-case($doctype) = 'senate-order' or lower-case($doctype) = 'senate-resolution') and (contains(lower-case($docstage), 'engrossed'))">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="//current-chamber and not(//current-chamber/@display = 'no') and not(//current-chamber/text = '') and (not((contains(lower-case($docstage), 'engrossed'))) and contains(lower-case($doctype), 'concurrent'))">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="not(//form/action) and not(//form/action/@display = 'yes' or not(//form/action/@display))">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="//form/action[@display = 'yes' or not(@display)]/child::*[@display = 'yes' or not(@display)]">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="action-desc/text()" mode="process">
        <xsl:value-of select="." /><xsl:text> </xsl:text>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="action-desc/committee-name" mode="process">
        <xsl:value-of select="." />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="action-date" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="insertPageBreakBeforeEnactingClause">
        <xsl:variable name="toInsertPageBreaks" as="xs:string">
            <xsl:value-of select="//bill/@microcomp-version" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$billstage != 'Reported-in-House'">
                <!-- nothing -->
                <!-- all father cases will work only for bills and only for Reported-in-house -->
            </xsl:when>
            <xsl:when test="$toInsertPageBreaks = 'page-one'">
                <xsl:call-template name="pagebreak" />
               
                <para format="6300" />
         
                <para loc="13">
                    <xsl:text>❩</xsl:text>
                </para>
               
                <xsl:call-template name="pagebreak" />
               
                <para format="6203" />
                
            </xsl:when>
            <xsl:when test="$toInsertPageBreaks = 'page-two'">
                <xsl:call-template name="pagebreak" />
            </xsl:when>
            <xsl:when test="$toInsertPageBreaks = 'page-three'">
                <xsl:call-template name="pagebreak" />
            </xsl:when>
            <xsl:when test="$toInsertPageBreaks = 'page-four'">
                <xsl:call-template name="pagebreak" />
            </xsl:when>
            <xsl:when test="$toInsertPageBreaks = 'page-five'">
                <xsl:call-template name="pagebreak" />
            </xsl:when>
            <xsl:otherwise>
                <!-- nothing to do -->
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="official-title/text()" mode="process">
        <xsl:value-of select="." />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quote" mode="process">
        <xsl:param name="iteration" />
        <xsl:variable name="quoteStr" as="item()*">
            <xsl:apply-templates mode="process" />
        </xsl:variable>
        <xsl:variable name="depth" as="xs:integer" select="count(ancestor-or-self::quoted-block) + count(ancestor-or-self::quote) + count(ancestor-or-self::term)" />
       <xsl:if test="$depth &gt; 0">
            <xsl:if test="($depth mod 2)=1">
                <xsl:text>“</xsl:text>
                <xsl:choose>
                    <xsl:when test="parent::header-in-text/@level='subsection' or self::header-in-text/@level='subsection' and @style='OLC'">	
                        <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                        <xsl:value-of select="." />
                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                        <!--
                            select="lexa:capICHeader(concat(translate(string(.),'&#x20;&#x9;&#xD;&#xA;','    '), 'HeaderInTextBigHeads'))"/>	-->					
                    </xsl:when>
                    <xsl:when test="parent::header-in-text/@level='subsection' or self::header-in-text/@level='subsection'">						
                        <xsl:value-of select="." />
                        <!--
                            select="lexa:capICHeader(concat(translate(string(.),'&#x20;&#x9;&#xD;&#xA;','    '), 'HeaderInTextBigHeads'))"/>	-->					
                    </xsl:when>
                    <xsl:when test="parent::header-in-text/@level='paragraph'">
                        <xsl:value-of select="lower-case(string(..))" />
                    </xsl:when>
                    <!--Issue 394-->
                    <xsl:when test="ends-with(text()[last()], ' ') and starts-with(following-sibling::text()[1], ';')">
                        <xsl:value-of select="normalize-space(.)" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:for-each select="$quoteStr">
                            <xsl:choose>
                                <xsl:when test="ends-with(., ', ')">
                               <xsl:value-of select="normalize-space(.)" />
                                </xsl:when>
                                <xsl:when test="self::text()">
                                    <!-- fixes issue #227. Do not use normalize-space() below
                                        as we have a case where we have a space at the end of the quote
                                        and it is removed and as a result it runs into the following word
                                        -->
                                    <xsl:choose>
                                        <xsl:when test="position() = last()">
                                            <xsl:if test="starts-with(., ' ')">
                                                <xsl:text> </xsl:text>
                                            </xsl:if><xsl:value-of select="normalize-space(.)" />
                                        </xsl:when>
                                        <xsl:otherwise><xsl:value-of select="." /></xsl:otherwise>
                                    </xsl:choose>     
                                </xsl:when>
                                <xsl:otherwise>
                                    <!-- fixes issue #209. Use xsl:sequence instead of xsl:value to process PIs. -->
                                    <xsl:sequence select="." />
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:for-each>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:text>”</xsl:text>
            </xsl:if>
            <xsl:if test="($depth mod 2)=0">
                <!--This fixes reversed quotes in quote/term-->
                <xsl:choose>
                    <!--This fixes reversed quotes in quote/term-->
                    <xsl:when test="term">
                        <xsl:text>“ </xsl:text>
                        <xsl:apply-templates mode="process" />
                        <xsl:text> ”</xsl:text>                  
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>‘</xsl:text>
                        <xsl:choose>
                            <xsl:when test="parent::header-in-text/@level='subsection' or self::header-in-text/@level='subsection' and @style='OLC'">	
                                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                <xsl:value-of select="." />
                                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                                <!--
                            select="lexa:capICHeader(concat(translate(string(.),'&#x20;&#x9;&#xD;&#xA;','    '), 'HeaderInTextBigHeads'))"/>	-->					
                            </xsl:when>
                            <xsl:when test="parent::header-in-text/@level='subsection' or self::header-in-text/@level='subsection'">	
                                <!-- issue #63: convert text only to upper case since contents could contain more than just text -->
                                <xsl:for-each select="$quoteStr">
                                    <xsl:choose>
                                        <xsl:when test="self::text()">
                                            <xsl:sequence select="upper-case(.)" />
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:sequence select="normalize-space(.)" />
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:for-each>
                                <!--
                        <xsl:value-of
                            select="lexa:capICHeader(concat(translate(string(.),'&#x20;&#x9;&#xD;&#xA;','    '), 'HeaderInTextBigHeads'))"/>	-->					
                            </xsl:when>
                            <xsl:when test="parent::header-in-text/@level='paragraph'">
                                <xsl:value-of select="lower-case(string(..))" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:for-each select="$quoteStr">
                                    <xsl:choose>
                                        <xsl:when test="self::text()">
                                            <xsl:sequence select="." />
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:sequence select="." />
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:for-each>
                            </xsl:otherwise>
                        </xsl:choose>
                        <xsl:text>’</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:if>
 
        </xsl:if>
        
        <xsl:if test="contains(following-sibling::*[1]/@reported-display-style,'brackets') or contains(following-sibling::*[1]/@reported-display-style,'parentheses') or local-name(following-sibling::*[1]) = 'quote'">
            
            <xsl:variable name="isNoTextFollowing">				
                <xsl:call-template name="noTextInBetween">					
                    <xsl:with-param name="aFirstPartText">
                        <xsl:value-of select="normalize-space(.)" />
                    </xsl:with-param>
                    <xsl:with-param name="aSecondPartText">
                        <xsl:choose>
                            <xsl:when test="count(following-sibling::*[1]/child::*) &gt; 0">
                                <xsl:value-of select="normalize-space(following-sibling::*[1]/child::*[1]/text())" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="normalize-space(following-sibling::*[1]/text())" />						
                            </xsl:otherwise>
                        </xsl:choose>
                        
                    </xsl:with-param>
                </xsl:call-template>									
            </xsl:variable>
            <xsl:if test="$isNoTextFollowing = 'true'">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="noTextInBetween">		
        <xsl:param name="aFirstPartText" />
        <xsl:param name="aSecondPartText" /> 
        <xsl:variable name="aWholeText" as="xs:string">
            <xsl:for-each select="parent::node()">
                <xsl:value-of select="." />
            </xsl:for-each>		
        </xsl:variable>
        <xsl:variable name="stringPartToProceed_1" as="xs:string">
            <xsl:value-of select="normalize-space(substring-before(normalize-space($aWholeText), $aSecondPartText))" />
        </xsl:variable>		
        <xsl:variable name="stringInBetween" as="xs:string">
            <xsl:choose>
                <xsl:when test="contains(stringPartToProceed_1, $aFirstPartText)">
                    <xsl:value-of select="substring-after($stringPartToProceed_1, normalize-space($aFirstPartText))" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="substring-before(substring-after(normalize-space($aWholeText),$aFirstPartText) , normalize-space($aSecondPartText))" />
                </xsl:otherwise>
            </xsl:choose>                
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$aSecondPartText = ',' ">
                <!-- punctuation can occur several times in the string - gives wrong result -->
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="normalize-space($stringInBetween) = ''">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>false</xsl:text>
            </xsl:otherwise>
        </xsl:choose>		
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="LastEmDashBefore">		
        <xsl:param name="aCurrentText" as="xs:string?" />		   
        <xsl:variable name="aWholeText" as="xs:string">
            <xsl:for-each select="parent::node()">
                <xsl:value-of select="." />
            </xsl:for-each>		
        </xsl:variable>
        <xsl:variable name="stringPartToProceed_1" as="xs:string?">
            <xsl:value-of select="normalize-space(substring-before($aWholeText, $aCurrentText))" />
        </xsl:variable>
        <xsl:variable name="isEndsWithEmDash" as="xs:string?">
            <xsl:choose>
                <xsl:when test="local-name() = 'subsection' or local-name() = 'paragraph' or local-name() = 'subparagraph' or local-name() = 'clause' or local-name() = 'subclause' or local-name() = 'item' or local-name() = 'subitem'">
                    <xsl:choose>
                        <xsl:when test="substring(normalize-space(header) , string-length(normalize-space(header) ) - 10) ='[[[mdash]]]' ">
                            <xsl:text>yes</xsl:text>
                        </xsl:when>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="substring($stringPartToProceed_1, string-length($stringPartToProceed_1) - 10) = '[[[mdash]]]'">
                    <xsl:text>yes</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>no</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>      
        <xsl:choose>	
            <xsl:when test="$isEndsWithEmDash='yes'">
                <xsl:text>true</xsl:text>
            </xsl:when>									
            <xsl:otherwise>
                <xsl:text>false</xsl:text>
            </xsl:otherwise>
        </xsl:choose>		
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="act-name" mode="process">
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="printFootnotesAtTheEnd">
        <!-- TB implementing footnote printing 16-Dec-2013 -->
        <xsl:if test="descendant::quote/footnote != ''">
            <xsl:for-each select="descendant::quote/footnote">
                <xsl:apply-templates select="self::*" mode="process">
                    <xsl:with-param name="forceFootnote">yes</xsl:with-param>
                </xsl:apply-templates>
            </xsl:for-each>
        </xsl:if>
        <xsl:if test="descendant::term/footnote != ''">
            <xsl:for-each select="descendant::term/footnote">
                <xsl:apply-templates select="self::*" mode="process">
                    <xsl:with-param name="forceFootnote">yes</xsl:with-param>
                </xsl:apply-templates>
            </xsl:for-each>
        </xsl:if>
        <xsl:if test="descendant::italic/footnote != ''">
            <xsl:for-each select="descendant::italic/footnote">
                <xsl:apply-templates select="self::*" mode="process">
                    <xsl:with-param name="forceFootnote">yes</xsl:with-param>
                </xsl:apply-templates>
            </xsl:for-each>
        </xsl:if>
        <xsl:if test="descendant::legis-comment/footnote != ''">
            <xsl:for-each select="descendant::legis-comment/footnote">
                <xsl:apply-templates select="self::*" mode="process">
                    <xsl:with-param name="forceFootnote">yes</xsl:with-param>
                </xsl:apply-templates>
            </xsl:for-each>
        </xsl:if>
        <xsl:if test="descendant::inline-comment/footnote != ''">
            <xsl:for-each select="descendant::inline-comment/footnote">
                <xsl:apply-templates select="self::*" mode="process">
                    <xsl:with-param name="forceFootnote">yes</xsl:with-param>
                </xsl:apply-templates>
            </xsl:for-each>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="printNormalizedText">
        <xsl:variable name="hrtcontents" as="xs:string">
            <xsl:value-of select="translate(.,'&#xD;&#xA;',' ')" />
        </xsl:variable>
        <xsl:variable name="contents" select="translate($hrtcontents,' 	&#xD;&#xA;','    ')" as="xs:string" />
        <xsl:choose>
            <xsl:when test="starts-with($contents,' ') and not (ancestor-or-self::rules-clause) and not (ancestor-or-self::level-header)">
                <xsl:text> </xsl:text>
            </xsl:when>
        </xsl:choose>
        
        <xsl:variable name="linesOffOn" as="xs:string" select="gpo:getLineNumbersValue(.)" />
         
        <xsl:variable name="reportedDisplayStyle" as="xs:string">			
            <xsl:if test="../@vbattChangedForReported != ''">
                <xsl:value-of select="../@vbattChangedForReported" />
            </xsl:if>
            <xsl:if test="not(../@vbattChangedForReported != '') and ../@reported-display-style !=''">
                <xsl:value-of select="../@reported-display-style" />
            </xsl:if>
        </xsl:variable>  
        <xsl:variable name="beginingOfTextPhrase" as="xs:string">
            <xsl:choose>	
                <xsl:when test="$linesOffOn = 'off'">
                    <xsl:call-template name="getBegginingOfThePhraseLiseOff">
                        <xsl:with-param name="aBeginingFor">
                            <xsl:text>text</xsl:text>
                        </xsl:with-param>
                        <xsl:with-param name="aReportingStyle" select="$reportedDisplayStyle" />					
                    </xsl:call-template>
                </xsl:when>					
            </xsl:choose>			
        </xsl:variable>	
        <para>
        <xsl:if test="parent::text and local-name(ancestor::*[2]) = 'amendment-block' and not (parent::text/preceding-sibling::*) ">
            <xsl:attribute name="loc">21</xsl:attribute>
        </xsl:if>
        <xsl:value-of select="$beginingOfTextPhrase" />
        <xsl:value-of select="normalize-space($contents)" />		
            <xsl:variable name="lastChar" select="substring($contents,string-length($contents))" as="xs:string" />
        <xsl:choose>
            <xsl:when test="starts-with($lastChar,' ')">
                <xsl:text> </xsl:text>
            </xsl:when>			
        </xsl:choose>
        </para>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="text()" mode="AllCaps">
        <xsl:choose>
            <xsl:when test="normalize-space(string(.)) = ''" />           
            <xsl:otherwise>
                <xsl:call-template name="printNormalizedAllCapsText" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="printNormalizedAllCapsText">
        <xsl:variable name="contents" select="upper-case(translate(.,' 	&#xD;&#xA;','    '))" as="xs:string" />
        <xsl:if test="starts-with($contents,' ')">
            <xsl:text> </xsl:text>
        </xsl:if>
        <xsl:value-of select="normalize-space($contents)" />
        <xsl:variable name="lastChar" select="substring($contents,string-length($contents))" as="xs:string" />
        <xsl:if test="starts-with($lastChar,' ')">
            <xsl:text> </xsl:text>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="text()" mode="AllLower">
        <xsl:choose>
            <xsl:when test="normalize-space(string(.)) = ''" />          
            <xsl:otherwise>
                <xsl:call-template name="printNormalizedAllLowerText" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="printNormalizedAllLowerText">		
        <xsl:if test="parent::added-phrase and $billtype='appropriations'">
            <xsl:choose>
                <xsl:when test="parent::added-phrase/@reported-display-style='italic' and ancestor::appropriations-small">
                    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="parent::added-phrase/@reported-display-style='italic' and (ancestor::appropriations-major or ancestor::appropriations-intermediate)">
                    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                </xsl:when>
            </xsl:choose>
        </xsl:if>		
        <xsl:variable name="contents" as="xs:string">
            <xsl:variable name="contIn" select="translate(string(.),' 	&#xD;&#xA;','    ')" as="xs:string" />
            <xsl:value-of select="lower-case($contIn)" />
        </xsl:variable>
        <xsl:if test="starts-with($contents,' ')">
            <xsl:text> </xsl:text>
        </xsl:if>
        <xsl:value-of select="normalize-space($contents)" />
        <xsl:variable name="lastChar" select="substring($contents,string-length($contents))" as="xs:string" />
        <xsl:if test="starts-with($lastChar,' ')">
            <xsl:text> </xsl:text>
        </xsl:if>		
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="text()" mode="InitialCaps">
        <xsl:variable name="text" select="translate(.,' 	&#xD;&#xA;','    ')" as="xs:string" />
        <xsl:variable name="isNoTextBefore" as="xs:string"> 
            <xsl:call-template name="NoTextBefore">
                <xsl:with-param name="aCurrentText" select="." />
            </xsl:call-template>			
        </xsl:variable>	
        
        <!-- TA: fixes issue #212. We are not sure which ancestor::header-in-text to use here (first, last, any)
            so we are concatening all ancestor values in the sequence, basically using ANY (which, at least covers 
            the other two cases and seems to match the original LXL code). 
            If that creates problems we might have to revist this approach and use either the first or last ancestor node.
            -->
        <xsl:variable name="level" as="xs:string?" select="string-join(ancestor::header-in-text/@level, '')" />
   
        <xsl:variable name="contents" as="xs:string">
            <xsl:choose>
                <xsl:when test="ancestor::header-in-text and                      $level != '' and                     (contains($level, 'paragraph') or contains($level, 'clause') or contains($level, 'item') )">                    
                        <xsl:value-of select="gpo:capitalize($text)" />	
                </xsl:when>
                <xsl:when test="ancestor::header-in-text and preceding-sibling::linebreak and $isNoTextBefore = 'false'">
                    <xsl:value-of select="gpo:capitalize($text)" />	
                </xsl:when>
                <xsl:when test="ancestor::header-in-text">
                    <xsl:value-of select="gpo:capitalize($text)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="gpo:capitalize($text)" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>   
        <xsl:if test="starts-with($contents,' ')">
            <xsl:text> </xsl:text>
        </xsl:if>
        <xsl:value-of select="normalize-space($contents)" />
        <xsl:variable name="lastChar" select="substring($contents,string-length($contents))" as="xs:string" />
        <xsl:if test="starts-with($lastChar,' ')">
            <xsl:text> </xsl:text>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="text()" mode="FirstWord">
        <!--BH: redid this template -->
       <!-- <xsl:variable name="count" select="string-length(.)" as="xs:double"/>
        <xsl:variable name="firsChar" select="upper-case(substring(., 1, 1))"  as="xs:string"/>
        <xsl:variable name="restOfString" select="substring(., 2, $count)"  as="xs:string"/>
        <xsl:value-of select="concat($firsChar, $restOfString)"/>-->
        <xsl:variable name="contents" select="gpo:capFWHeader(.)" />
   
        <xsl:if test="starts-with($contents,' ')">
            <xsl:text> </xsl:text>
        </xsl:if>
        <xsl:value-of select="normalize-space($contents)" />
        <xsl:variable name="lastChar" select="substring($contents,string-length($contents))" />
        <xsl:if test="starts-with($lastChar,' ')">
            <xsl:text> </xsl:text>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="enum-in-header" mode="AllLower">
        <xsl:apply-templates select="." mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="enum-in-header" mode="AllCaps">
        <xsl:value-of select="upper-case(.)" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="enum-in-header" mode="process">
        <xsl:variable name="node" select="." as="node()" />
        <xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
        <xsl:variable name="currElementStyle" as="item()*">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>
        <xsl:variable name="parentOrLevel" as="xs:string">
            <xsl:choose>
                <xsl:when test="local-name(./parent::*) = 'header-in-text'">
                    <xsl:value-of select="./parent::header-in-text/@level" />
                </xsl:when>
                <xsl:when test="local-name(./parent::*) = 'inline-comment'">
                    <xsl:choose>
                        <xsl:when test="local-name(ancestor::*[2]) = 'toc-entry'">
                            <xsl:text>toc-entry</xsl:text>
                        </xsl:when>
                        <xsl:when test="local-name(ancestor::*[3]) = 'header-in-text'">
                            <xsl:value-of select="ancestor::*[3]/header-in-text/@level" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="local-name(ancestor::*[3])" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="local-name(../parent::*)" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="isExceptionalHeader" as="xs:string">
            <xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />		
        </xsl:variable>
        
 
        <xsl:choose>
            <!--Issue #293-->
            <xsl:when test="parent::toc-entry">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                 <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$isExceptionalHeader = 'true'">
                <xsl:call-template name="ExceptionalHeadersRamseyerCordonEnumCode" />		
                
                <xsl:apply-templates mode="process" />
            </xsl:when>
            <xsl:when test="($parentOrLevel = 'division'  and ($currElementStyle='traditional-inline' or $currElementStyle='appropriations')) or  $parentOrLevel = 'subdivision'">
                <xsl:apply-templates mode="process" />
            </xsl:when>
            <xsl:when test="local-name (parent::*) != 'header-in-text' and ($parentOrLevel = 'division'  or  $parentOrLevel = 'title' or ($parentOrLevel = 'subchapter' and ($currElementStyle='USC'  or  contains($currElementStyle,'traditional' ) or $currElementStyle = 'appropriations' or contains($currElementStyle,'archaic' ) )))">
              <xsl:choose>
                    <xsl:when test="not($parentOrLevel = 'subchapter') and ($currElementStyle='USC'  or ($parentOrLevel = 'title' and $currElementStyle='nuclear' )) and  (contains(.,'(') or contains(.,')') or contains(.,'1') or contains(.,'2') or contains(.,'3') or contains(.,'4') or contains(.,'5') or contains(.,'6') or contains(.,'7') or contains(.,'8') or contains(.,'9') or contains(.,'0'))">
                        <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                        <xsl:apply-templates mode="process" />
                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>                     
                    </xsl:when>
                    <xsl:when test="not ($parentOrLevel = 'subchapter' and ($currElementStyle='traditional-inline' or $currElementStyle='appropriations')) and (contains($currElementStyle,'traditional')  or $currElementStyle='appropriations' or $currElementStyle='USC' or $currElementStyle='nuclear'  or $currElementStyle='archaic' or $currElementStyle='archaic-paragraph') and  (contains(.,'(') or contains(.,')') or contains(.,'1') or contains(.,'2') or contains(.,'3') or contains(.,'4') or contains(.,'5') or contains(.,'6') or contains(.,'7') or contains(.,'8') or contains(.,'9') or contains(.,'0'))">
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        <xsl:apply-templates mode="process" />
                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>                     
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates mode="process" />
                    </xsl:otherwise>
                </xsl:choose>               
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'section' and ($currElementStyle='traditional' or $currElementStyle='appropriations')">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'section'  and contains ($currElementStyle,'archaic' )">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'section'  and $currElementStyle='nuclear'">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'subsection' and contains($currElementStyle,'archaic')">
                <xsl:apply-templates mode="process" />
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'chapter'   and $currElementStyle='nuclear'">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'chapter'  and ($currElementStyle='traditional-inline' or $currElementStyle='appropriations')">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'section' and $currElementStyle='traditional-inline'">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>             
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'part'  and (contains($currElementStyle,'traditional' ) or $currElementStyle='appropriations')">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'subpart'  and (contains($currElementStyle,'traditional' ) or $currElementStyle='appropriations')">
                <xsl:apply-templates mode="process" />
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'section'  and ($currElementStyle = 'OLC' or $currElementStyle='tax') and ancestor::header-in-text">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'part'  and ($currElementStyle = 'OLC' or $currElementStyle='tax' or $currElementStyle='USC') and ancestor::header-in-text">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$parentOrLevel = 'part'  and contains($currElementStyle,'archaic') and ancestor::header-in-text">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="($parentOrLevel = 'section'  or $parentOrLevel = 'subtitle'                  or  $parentOrLevel = 'part' or  $parentOrLevel = 'subpart'                   or  $parentOrLevel = 'chapter'  or  $parentOrLevel = 'subchapter')">               
                <xsl:apply-templates mode="process" />
            </xsl:when>
            <xsl:when test="parent::toc-entry or $parentOrLevel = 'toc-entry'">
                <xsl:choose>
                    <xsl:when test="$currElementStyle='tax'">
                        <xsl:apply-templates mode="process" />
                    </xsl:when>
                    <xsl:when test="(contains(.,'(') or contains(.,')') or contains(.,'1') or contains(.,'2') or contains(.,'3') or contains(.,'4') or contains(.,'5') or contains(.,'6') or contains(.,'7') or contains(.,'8') or contains(.,'9') or contains(.,'0') )                         and not(../@level='section'  or  ../@level='subchapter' )"> 
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        <xsl:apply-templates mode="process" />
                        <xsl:processing-instruction name="xpp">fv;T</xsl:processing-instruction>
                        <!--BH:  This is probably wrong.  Need to revisit after completing.-->
                        <!--<xsl:text disable-output-escaping="yes">&lt;BEL&gt;TT</xsl:text>-->                    
                    </xsl:when>
                    <xsl:when test="(contains(.,'(') or contains(.,')') or contains(.,'1') or contains(.,'2') or contains(.,'3') or contains(.,'4') or contains(.,'5') or contains(.,'6') or contains(.,'7') or contains(.,'8') or contains(.,'9') or contains(.,'0') )                         and (../@level='subchapter'  and (not ($currElementStyle ='traditional' or @style='other') or $currElementStyle='nuclear'))">
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        <xsl:apply-templates mode="process" />
                        <xsl:processing-instruction name="xpp">fv;T</xsl:processing-instruction>
                        <!--BH:  This is probably wrong.  Need to revisit after completing.-->
                        <!--<xsl:text disable-output-escaping="yes">&lt;BEL&gt;TT</xsl:text>-->                         
                    </xsl:when>
                    <xsl:otherwise>
                        <!--Issue #293-->
                        <!--Only the text of the PI is being output -->
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        <xsl:apply-templates mode="process" />
                        <xsl:processing-instruction name="xpp">fv;T</xsl:processing-instruction>
                        <!--BH:  This is probably wrong.  Need to revisit after completing.-->
                        <!--<xsl:text disable-output-escaping="yes">&lt;BEL&gt;TT</xsl:text>-->        
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="not($parentOrLevel = 'section' or  $parentOrLevel = 'division'                  or $parentOrLevel = 'title' or  $parentOrLevel = 'subtitle'                  or $parentOrLevel = 'part' or  $parentOrLevel = 'subpart'                 or  $parentOrLevel = 'chapter' or $parentOrLevel = 'subchapter')">
                <xsl:choose>
                    <xsl:when test="contains(.,'(') or contains(.,')') or contains(.,'1') or contains(.,'2') or contains(.,'3') or contains(.,'4') or contains(.,'5') or contains(.,'6') or contains(.,'7') or contains(.,'8') or contains(.,'9') or contains(.,'0')">
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        <xsl:apply-templates mode="process" />
                       <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                        
                    </xsl:when>
                    <xsl:when test="not($parentOrLevel = 'section') and string-length(translate(.,'()1234567890','')) = 0">
                        <xsl:apply-templates mode="process" />                       
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates mode="process" />
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="process" />
            </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="not(../parent::section) and preceding-sibling::enum-in-header[contains(.,'(') or contains(.,')') or contains(.,'1') or contains(.,'2') or contains(.,'3') or contains(.,'4') or contains(.,'5') or contains(.,'6') or contains(.,'7') or contains(.,'8') or contains(.,'9') or contains(.,'0')] and not (local-name()='enum-in-header')">
            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="attestation" mode="process">
        <xsl:if test="not(ancestor::legis-body/@reported-display-style='italic')">
            <xsl:if test="descendant::attestation-date and not($billstage='Enrolled-Bill')">
                <para format="6201" />
            </xsl:if>
        </xsl:if>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="attestation-date" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="attestation-group" mode="process">
        <xsl:if test="not($docstage='Enrolled-Bill' )  or  ( $docstage='Enrolled-Bill'  and   ($doctype ='house-concurrent' or  $doctype ='senate-concurrent' )) ">
            <xsl:if test="preceding-sibling::attestation-group and $restype='house-concurrent'   and $resstage='Enrolled-Bill' ">
                <xsl:processing-instruction name="xpp">lp;&amp;12q</xsl:processing-instruction>
            </xsl:if>
            <xsl:if test="./attestation-date">
                <para loc="13">
                    <xsl:value-of select="attestation-date" />
                </para>
            </xsl:if>
            <xsl:if test="./role and (not(attestor ) or attestor[@display='no' ]) and not($billstage='Enrolled-Bill')">
                <para loc="13"> Attest:
                    <xsl:if test="contains($docstage, 'Engrossed')  or                          $docstage = 'Received-in-Senate' or $docstage ='Referred-in-Senate'                         "> 
                    </xsl:if>
                </para>
            </xsl:if>
            
        </xsl:if>
        <xsl:apply-templates mode="process" />
        <!-- TA: commented out, the PIs are added in printEndorsement -->
      <!--  <xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>
        <xsl:processing-instruction name="xpp">ps;2</xsl:processing-instruction>-->
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="attestor" mode="process">    
        <xsl:variable name="comment">attestor</xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <!--Issue Number #71 - Suppress output of the QCodes-->
        <xsl:if test="not($billstage='Enrolled-Bill') and not (ancestor::letter)">
            <para loc="13">Attest:</para>
            <xsl:if test="not(./@display='yes'  and  string-length(.) &gt; 0) and (contains($docstage, 'Engrossed') and ( following-sibling::role)) ">
               <!-- <xsl:processing-instruction name="xpp">lp;&amp;60q</xsl:processing-instruction>-->
            </xsl:if>
        </xsl:if>   
        <xsl:if test="@display='yes' or (string-length(.) &gt; 0)  ">
            <xsl:if test="($docstage='Enrolled-Bill'                   or $resstage='Enrolled-House'                  or $resstage='Enrolled-in-Senate')">
                <xsl:if test="count(preceding-sibling::attestor) &gt; 0">
                   <!-- <xsl:processing-instruction name="xpp">lp;&amp;12q</xsl:processing-instruction>-->
                </xsl:if>
                <xsl:if test="$resstage!='Enrolled-Bill'">
                    <para loc="13"> </para>
                </xsl:if>
            </xsl:if>
           
            <xsl:choose>				
                <xsl:when test="((($restype='house-concurrent' or $restype='house-joint'  or $restype='house-resolution' ) and $resstage='Engrossed-in-House' )  or $billstage='Engrossed-in-House')and following-sibling::proxy">
                    
                    <para loc="14">
                        <xsl:processing-instruction name="xpp">lp;&amp;06q</xsl:processing-instruction>  
                        <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>    
                        <xsl:value-of select="." />  
                       <!-- <xsl:processing-instruction name="xpp">lp;&amp;18q</xsl:processing-instruction>  -->
                    </para>
                </xsl:when>
                <xsl:when test="$restype='house-concurrent' and $resstage='Enrolled-Bill' and following-sibling::proxy">  
                    <para loc="14">
                        <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>  
                        <xsl:value-of select="." />       
                    </para>
                    <xsl:processing-instruction name="xpp">lp;&amp;14q</xsl:processing-instruction>  
                </xsl:when>
                <xsl:when test="contains($billstage, 'Engrossed')">
                    <xsl:text>         </xsl:text>
                    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>  
                    <xsl:value-of select="lower-case(.)" />        
                </xsl:when>
                <xsl:when test="ancestor::letter">
                    <para loc="28">
                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                                   
                        <xsl:value-of select="." />
                    </para>
                </xsl:when>
                <xsl:otherwise>				
                    <para loc="15">
                        <xsl:value-of select="upper-case(.)" />
                    </para>
                </xsl:otherwise>           
            </xsl:choose>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="addAttestorQcode">
    <xsl:if test="not($billstage='Enrolled-Bill') and not (ancestor::letter)">
        <xsl:if test="not(preceding-sibling::attestor/@display='yes'  and  string-length(preceding-sibling::attestor) &gt; 0) and (contains($docstage, 'Engrossed')) ">
            <xsl:processing-instruction name="xpp">lp;&amp;60q</xsl:processing-instruction>
        </xsl:if>
    </xsl:if>   
    <xsl:if test="preceding-sibling::attestor/@display='yes' or (string-length(preceding-sibling::attestor) &gt; 0)  ">
        <xsl:if test="($docstage='Enrolled-Bill'               or $resstage='Enrolled-House'              or $resstage='Enrolled-in-Senate')">
          <!-- Issue #207 - Modified processing-instruction from 12 to 72-->
            <xsl:if test="count(preceding-sibling::attestor) &gt; 0">
                <xsl:processing-instruction name="xpp">lp;&amp;72q</xsl:processing-instruction>
            </xsl:if>
        </xsl:if>        
        <xsl:choose>				
            <xsl:when test="((($restype='house-concurrent' or $restype='house-joint'  or $restype='house-resolution' )                  and $resstage='Engrossed-in-House' )  or $billstage='Engrossed-in-House')and following-sibling::proxy">
                    <xsl:processing-instruction name="xpp">lp;&amp;18q</xsl:processing-instruction>  
            </xsl:when>
            <xsl:when test="$restype='house-concurrent' and $resstage='Enrolled-Bill' and following-sibling::proxy">  
                <xsl:processing-instruction name="xpp">lp;&amp;14q</xsl:processing-instruction>  
            </xsl:when>
            <xsl:when test="contains($billstage, 'Engrossed')" />              
            <xsl:when test="ancestor::letter" />         
            <xsl:otherwise />				                    
        </xsl:choose>
    </xsl:if>
</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="role" mode="process">
        <xsl:variable name="docstage" select="/bill/@bill-stage" as="xs:string?" />
        <xsl:variable name="comment">role</xsl:variable>
        <xsl:choose>
            <xsl:when test="starts-with(.,'Speaker') and ($docstage='Enrolled-Bill')">
                <para loc="14">
                    <xsl:processing-instruction name="xpp">lp;&amp;72q</xsl:processing-instruction>
                    <xsl:value-of select="." />
                    <!--Issue #370-->
                    <xsl:choose>
                        <xsl:when test="ends-with(., '.')" />
                        <xsl:otherwise><xsl:text>.</xsl:text></xsl:otherwise>
                    </xsl:choose>
                </para>
            </xsl:when>
            <xsl:when test="starts-with(.,'Vice') and ($docstage='Enrolled-Bill')">
               <para loc="14">
                    <xsl:processing-instruction name="xpp">lp;&amp;72q</xsl:processing-instruction>
                    <xsl:value-of select="substring-before(.,'and') " />
                    <xsl:text>and  </xsl:text>
               </para>
                <para loc="14">
                    <xsl:text>President of the Senate.</xsl:text>
                </para>
            </xsl:when>
            <xsl:otherwise>
              <xsl:choose>
                    <xsl:when test="not(../attestor)" />
                    <xsl:otherwise>
                        <xsl:for-each select="../attestor">
                            <xsl:if test="translate(., ' ', '') = ''">
                                <xsl:processing-instruction name="xpp">lp;&amp;72q</xsl:processing-instruction>
                            </xsl:if>
                        </xsl:for-each>
                    </xsl:otherwise>
                  <!--
                    <xsl:when test="translate(../attestor,' ', '') = ''">
                        <para qcode="72"/> 
                    </xsl:when>       
                    <xsl:otherwise/> 
                    -->
                </xsl:choose>
                <para loc="14">
                    <!--Issue #71:  Move PI from end of Attest to 'role'.-->
                    <xsl:call-template name="addAttestorQcode" />
                     <!--<xsl:processing-instruction name="xpp">lp;&amp;60q</xsl:processing-instruction>-->
                <xsl:apply-templates mode="process" />              
                <xsl:if test="not(contains(.,'.'))">
                    <xsl:text>.</xsl:text>
                </xsl:if>
                </para>
                <xsl:if test="following-sibling::proxy/@display = 'no' or (not (following-sibling::proxy/@display) and following-sibling::proxy)">
                    <para loc="13">      By</para>
                    <xsl:processing-instruction name="xpp">lp;&amp;60q</xsl:processing-instruction>
                <para>
                <xsl:if test=".='Vice President of the United States and'">
                    <xsl:text>  </xsl:text>
                </xsl:if>
                </para>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="proxy" mode="process">
        <xsl:if test="@display='yes'">
            <para loc="13">
                <xsl:text>          By</xsl:text>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>         
            <xsl:apply-templates mode="process" />
            </para>
            <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>       
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="calendar" mode="process">
        <xsl:choose>
            <xsl:when test="$billstage='Received-in-Senate' or $billstage='Referred-in-Senate' or $billstage='Engrossed-in-Senate' or $billstage='Engrossed-in-House' or $billstage='Enrolled-Bill'" />
            <xsl:otherwise>
                <para loc="40">
                <xsl:if test="contains(//calendar,'No.')">
                    <xsl:value-of select="substring-before(//calendar,'No.')" />
                    <xsl:text>No. </xsl:text>
                    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                    <xsl:value-of select="substring-after(//calendar,'No. ')" />
                </xsl:if>
                </para>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="omitted-text" mode="process">     
        <xsl:variable name="punc" as="xs:string">
            <xsl:value-of select="substring(normalize-space(following-sibling::text()),(string-length(normalize-space(following-sibling::text()))),1)" />
        </xsl:variable>     
        <xsl:choose>
            <xsl:when test="@type='horizontal' and substring(normalize-space(..),1,11)=substring(normalize-space(following-sibling::text()),1,11)">
                <xsl:text>* * * </xsl:text>
            </xsl:when>
            <xsl:when test="@type='horizontal' and ($punc='.'  or  $punc=';'  or  $punc=',' or $punc='?')">* * *</xsl:when>
            <xsl:when test="@type='horizontal'">* * *</xsl:when>
            <xsl:when test="@type='vertical'">
                <xsl:choose>
                    <xsl:when test="not($m_isCommitteeReport='Yes')">
                        <para loc="20">  *   *   *   *   *   *   *</para>
                    </xsl:when>
                    <xsl:otherwise>
                        <para loc="65">* * * * * * *</para>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="process" />
            </xsl:otherwise>
        </xsl:choose>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='italic']| deleted-phrase[@reported-display-style='italic']|italic|proviso" mode="process">
        <xsl:call-template name="spaceBeforeAddedDeleted" />      
        <xsl:if test="contains(@reported-display-style,'parentheses')">
            <xsl:text>【</xsl:text>
        </xsl:if>
        <xsl:if test="contains(@reported-display-style,'brackets')">
            <xsl:text>❨</xsl:text>
        </xsl:if>
        <xsl:call-template name="phrase-italic" />
        <xsl:if test="contains(@reported-display-style,'parentheses')">
            <xsl:text>】</xsl:text>
        </xsl:if>
        <xsl:if test="contains(@reported-display-style,'brackets')">
            <xsl:text>❩</xsl:text>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='strikethrough']| deleted-phrase[@reported-display-style='strikethrough']" mode="process">
        <xsl:variable name="node" select="." as="node()" />
        <xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
        <!--******* Opening character****************-->
        <xsl:variable name="currElStyle" as="item()+">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>		
        <xsl:if test="contains(@reported-display-style,'parentheses')">
            <xsl:text>【</xsl:text>
        </xsl:if>
        <xsl:if test="contains(@reported-display-style,'brackets')">
            <xsl:text>❨</xsl:text>
        </xsl:if>     
        <xsl:call-template name="spaceBeforeAddedDeleted" />
        <!--*******Actual Phrase Display Optimized***********-->        
        <xsl:variable name="aMode" as="xs:string">
            <xsl:call-template name="defineMode">
                <xsl:with-param name="aStyle" select="$currElStyle" />
            </xsl:call-template>
        </xsl:variable>       
        <!-- to print G3T3 phrase -->
        <xsl:variable name="printG3T3Phrase" as="xs:string">
            <xsl:call-template name="toPrintG3T3Phrase">
                <xsl:with-param name="aStyle" select="$currElStyle" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:variable>        
        <xsl:if test="$printG3T3Phrase != 'no'">
            <xsl:call-template name="actualPrintThePhrase">
                <xsl:with-param name="aPhraseBegining">
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                </xsl:with-param>
                <xsl:with-param name="aPhraseEnding" select="$printG3T3Phrase" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:if>        
        <!-- *********Print  G3-T2 phrase exclusively to previous phrase printing************* -->
        <xsl:variable name="printG3T2Phrase" as="xs:string">
            <xsl:call-template name="toPrintG3T2Phrase">
                <xsl:with-param name="aStyle" select="$currElStyle" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:variable>      
        <xsl:if test="$printG3T3Phrase = 'no' and $printG3T2Phrase != 'no' ">
            <xsl:call-template name="actualPrintThePhrase">
                <xsl:with-param name="aPhraseBegining">
                    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                </xsl:with-param>
                <xsl:with-param name="aPhraseEnding" select="$printG3T2Phrase" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:if>              
        <!-- **********Print G3-T4 PHrase************* -->      
        <xsl:variable name="printG3T4Phrase" as="xs:string">
            <xsl:call-template name="toPrintG3T4Phrase">
                <xsl:with-param name="aStyle" select="$currElStyle" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:variable>      
        <xsl:if test="$printG3T3Phrase = 'no' and $printG3T4Phrase != 'no' and $printG3T2Phrase ='no' ">
            <xsl:call-template name="actualPrintThePhrase">
                <xsl:with-param name="aPhraseBegining">
                    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                </xsl:with-param>
                <xsl:with-param name="aPhraseEnding" select="$printG3T4Phrase" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:if>        
        <!-- *********Print  G3-T5 phrase exclusively to each previous************* -->
        <xsl:variable name="printG3T5Phrase" as="xs:string">
            <xsl:call-template name="toPrintG3T5Phrase">
                <xsl:with-param name="aStyle" select="$currElStyle" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:variable>     
        <xsl:if test="$printG3T3Phrase = 'no' and $printG3T5Phrase != 'no' and $printG3T2Phrase ='no' and $printG3T4Phrase='no'">
            <xsl:call-template name="actualPrintThePhrase">
                <xsl:with-param name="aPhraseBegining">
                    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                </xsl:with-param>
                <xsl:with-param name="aPhraseEnding" select="$printG3T5Phrase" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:if>      
        <!-- *********Print  G3 phrase************* -->
        <xsl:variable name="printG3Phrase" as="xs:string">
            <xsl:call-template name="toPrintG3Phrase">
                <xsl:with-param name="aStyle" select="$currElStyle" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:variable>      
        <xsl:if test="$printG3T3Phrase = 'no' and $printG3Phrase != 'no' and $printG3T2Phrase ='no' and $printG3T4Phrase='no' and $printG3T5Phrase='no'">
            <xsl:call-template name="actualPrintThePhrase">
                <xsl:with-param name="aPhraseBegining">
                    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                </xsl:with-param>
                <xsl:with-param name="aPhraseEnding" select="$printG3Phrase" />
                <xsl:with-param name="aMode" select="$aMode" />
            </xsl:call-template>
        </xsl:if>     
        <!-- *********Print other phrases************* -->
        <!-- TBD D for 'Done' -->        
        <!-- *********Print  G3-T1 phrase************* -->
        <!-- Default printing must be at the end -->
        <xsl:if test="$printG3T3Phrase = 'no' and $printG3Phrase = 'no' and $printG3T2Phrase ='no' and $printG3T4Phrase='no' and $printG3T5Phrase='no'">
            <xsl:variable name="printG3T1Phrase" as="xs:string">
                <xsl:call-template name="toPrintG3T1Phrase">
                    <xsl:with-param name="aStyle" select="$currElStyle" />
                    <xsl:with-param name="aMode" select="$aMode" />
                </xsl:call-template>
            </xsl:variable>            
            <xsl:if test="$printG3T1Phrase != 'no' ">
                <!--Issue #213-->
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <!--<xsl:call-template name="actualPrintThePhrase">
                    <xsl:with-param name="aPhraseBegining">
                        <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    </xsl:with-param>
                    <xsl:with-param name="aPhraseEnding" select="$printG3T1Phrase"/>
                    <xsl:with-param name="aMode" select="$aMode"/>
                </xsl:call-template>-->
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:if>
        </xsl:if>
        <!-- ************Closing Symbol*********************** -->
        <xsl:if test="contains(@reported-display-style,'parentheses')">
            <xsl:text>】</xsl:text>
        </xsl:if>
        <xsl:if test="starts-with(@reported-display-style,'brackets')">
            <xsl:text>❩</xsl:text>
        </xsl:if>
        <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintG3T3Phrase">
        <xsl:param name="aStyle" />
        <xsl:param name="aMode" />
        <xsl:choose>
            <xsl:when test="($aMode='5'  or $aMode='10') and parent::header-in-text">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>			
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintG3T1Phrase">
        <xsl:param name="aStyle" />
        <xsl:param name="aMode" />
        <xsl:choose>
            <xsl:when test="$aMode='3' or $aMode='13'  or $aMode='2' or $aMode='4' or $aMode='12' or $aMode='6' or $aMode='11' ">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="parent::toc-entry">
                <xsl:choose>
                    <xsl:when test="(contains($aStyle, 'traditional') and ../@level='subchapter' ) or                          ((contains($aStyle, 'traditional')  or $aStyle='tax') and ../@level='subpart' ) or  ../@level='subtitle'  or ../@level='title' ">
                        <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="parent::header and local-name(../..)='subsection'">
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="parent::header and local-name(../..)='subchapter'  and $aStyle='USC' ">
                        <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="parent::header and local-name(../..)='chapter' and $aStyle='nuclear'">
                        <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                    </xsl:otherwise>
                </xsl:choose>
                
            </xsl:when>
            <xsl:when test="parent::header and local-name(../..)='subdivision' and $aStyle='traditional'">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <!-- TB 22June2009 Bug #1026 -->
            <xsl:when test="parent::header-in-text and ../@level='subdivision' and $aStyle='traditional'">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise>
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintG3T2Phrase">
        <xsl:param name="aStyle" />
        <xsl:param name="aMode" />
        <xsl:choose>
            <xsl:when test="$aMode='5'  or $aMode='10'">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aMode='3' or $aMode='13'  or $aMode='2' or $aMode='4' or $aMode='12' or $aMode='6' or $aMode='11'">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="$aMode='1' or $aMode='5' or $aMode='8' or $aMode='10' ">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aMode='9' ">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="@reported-display-style='strikethrough'  and parent::enum and local-name(../..)='chapter'  and not ($aStyle='traditional-inline' or $aStyle='appropriations')">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header and (local-name(../..) = 'division' or local-name(../..) = 'subdivision' ) and ($aStyle='tax' or $aStyle='nuclear')">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text and (../@level = 'division' or ../@level = 'subdivision'  or ../@level='title') and ($aStyle='tax' or $aStyle='nuclear' or $aStyle='OLC' or $aStyle='USC') ">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="@reported-display-style='strikethrough' and local-name(/*)='resolution'  and ((parent::header or parent::enum) and local-name(../..)='chapter' and not ($aStyle = 'traditional-inline'  or $aStyle='appropriations' or contains($aStyle,'archaic')))">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="@reported-display-style='strikethrough' and local-name(/*)='resolution'  and ((parent::header-header-in-text) and ../@level='chapter' and not ($aStyle = 'traditional-inline'  or $aStyle='appropriations' or contains($aStyle,'archaic')))">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test=" (parent::header  or parent::enum) and (local-name(../..)='chapter'  and ($aStyle= 'traditional' or contains($aStyle, 'archaic')))">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test=" (parent::header-in-text ) and (../@level='chapter'  and ($aStyle= 'traditional' or contains($aStyle, 'archaic')))">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="not(parent::text) and not (parent::continuation-text) and @reported-display-style='strikethrough' and local-name(../..)='section'  and  ($aStyle = 'USC' or  ($aStyle='OLC' and not(.././@section-type='undesignated-section')))">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header  and local-name(../..) = 'section'  and not (contains($aStyle, 'traditional')) and not ($aStyle='nuclear') and not ($aStyle='appropriations') and not (contains($aStyle,'archaic'))">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text  and ../@level = 'section'  and not (contains($aStyle, 'traditional')) and not ($aStyle='nuclear') and not ($aStyle='appropriations') and not (contains($aStyle,'archaic'))">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>			
            <xsl:when test="@reported-display-style='strikethrough'  and parent::enum and (($aStyle='defense' or $aStyle='tax') and local-name(../..) = 'section')">
                
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::text and contains(@reported-display-style,'brackets')">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="not(parent::quoted-block-continuation-text ) and local-name(../..)='subchapter'  and not (contains($aStyle,'traditional') or $aStyle='appropriations'  or contains($aStyle,'archaic')) and not($aStyle='USC' and (parent::header or parent::enum))">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test=" (parent::header  or parent::enum) and (local-name(../..)='division'  or local-name(../..)='subdivision') and ($aStyle = 'traditional-inline' or $aStyle='appropriations')">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test=" (parent::header-in-text ) and (../@level='division'  or ../@level='subdivision') and ($aStyle = 'traditional-inline' or $aStyle='appropriations')">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header                  and (local-name(../..)='title'                      or local-name(../..)='part'                          or local-name(../..)='chapter'                  or local-name(../..)='subchapter')                  and not(contains($aStyle, 'traditional'))                 and not($aStyle = 'appropriations')                 and not(local-name(../..)='subchapter' and $aStyle='USC' )                 and not(local-name(../..)='chapter' and $aStyle='nuclear')                 and not(local-name(../..)!='chapter' and $aStyle='archaic-paragraph')                 and not((local-name(../..)='title' or local-name(../..)='part'  or  local-name(../..)='subchapter'  ) and contains($aStyle,'archaic'))">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text                 and (../@level='title'                      or ../@level='part'                          or ../@level='chapter'                  or ../@level='subchapter')                  and not(contains($aStyle, 'traditional'))                 and not($aStyle = 'appropriations')                 and not(../@level='subchapter' and $aStyle='USC' )                 and not(../@level='chapter' and $aStyle='nuclear')                 and not(../@level!='chapter' and $aStyle='archaic-paragraph')                 and not((../@level='title' or local-name(../..)='part'  or  ../@level='subchapter'  ) and contains($aStyle,'archaic'))">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>			
            <xsl:when test="parent::header                  and local-name(../..)='part'                      and not(contains($aStyle, 'traditional'))                  and not($aStyle = 'appropriations')                     and  ($aStyle='nuclear')">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text                  and ../@level='part'                      and not(contains($aStyle, 'traditional'))                  and not($aStyle = 'appropriations')                     and  ($aStyle='nuclear')">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="(local-name(../..)='division'  or local-name(../..)='subdivision' or local-name(../..)='part') and $aStyle ='OLC'  ">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintG3T4Phrase">
        <xsl:param name="aStyle" />
        <xsl:param name="aMode" />
        <xsl:choose>
            <xsl:when test="parent::continuation-text">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="$aMode='3' or $aMode='13'  or $aMode='2' or $aMode='4' or $aMode='12' or $aMode='6'">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="$aMode='11'">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="(contains($aStyle, 'traditional') or $aStyle='appropriations') and (local-name(../..)='subtitle' or local-name(../..)='subpart' or local-name(../..)='subchapter' )">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="contains($aStyle, 'archaic') and local-name(../..)='subdivision' ">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="parent::header and local-name(/*)='resolution' and not (local-name(../..)='subtitle' or local-name(../..)='subpart'  or local-name(../..)='subdivision' ) and not (  local-name (../..) = 'subsection' and contains($aStyle, 'archaic')) ">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text and local-name(/*)='resolution' and not (../@level='subtitle' or ../@level='subpart'  or ../@level='subdivision' ) and not (  ../@level= 'subsection' and contains($aStyle, 'archaic')) ">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header  and (local-name(../..)='section'  and contains($aStyle, 'archaic') ) ">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text  and (../@level='section'  and contains($aStyle, 'archaic') ) ">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="local-name(../..)='section' and not (parent::text)  and @reported-display-style='strikethrough'  and $aStyle='traditional' ">
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="local-name(../..)='section'  and @reported-display-style='strikethrough'  and ($aStyle='traditional-inline' or $aStyle='appropriations') and not(parent::text)">
                <!--xsl:text>&lt;BEL&gt;T1</xsl:text-->
                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="(($aStyle='traditional-inline' or $aStyle='appropriations') and not(parent::enum) and not(parent::text)  and not (parent::after-quoted-block)  )  or ($aStyle='archaic-paragraph'  and not(parent::text)  and (local-name(../..)='subparagraph' or local-name(../..)='clause' or local-name(../..)='subclause' or local-name(../..)='item' or local-name(../..)='subitem'))">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintG3T5Phrase">
        <xsl:param name="aStyle" />
        <xsl:param name="aMode" />
        <xsl:choose>
            <xsl:when test="$aMode='3'  or $aMode='13'  or $aMode='2' or $aMode='4' or $aMode='12'">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="$aMode='6'">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::toc-entry and contains($aStyle,'traditional') and (../@level='chapter' or ../@level='part'  or ../@level='subchapter' or ../@level='subpart' ) ">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header and contains($aStyle,'traditional') and local-name(../..)='part'  ">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text and contains($aStyle,'traditional') and ../@level='part'  ">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header and ($aStyle = 'traditional-inline'  or $aStyle='approptiations')  and  local-name(../..) = 'section' ">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text and ($aStyle = 'traditional-inline'  or $aStyle='approptiations')  and  ../@level = 'section' ">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintG3Phrase">
        <xsl:param name="aStyle" />
        <xsl:param name="aMode" />
        <xsl:choose>
            <xsl:when test="$aMode='3'  or $aMode='13'  or $aMode='2' or $aMode='4' or $aMode='12'">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="(contains($aStyle, 'traditional') and local-name(../..)='subchapter' ) or local-name(../..)='subtitle' or local-name(../..)='subpart'  or local-name(../..)='title' ">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aStyle='tax' and local-name(../..)='subpart' ">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header and contains($aStyle,'archaic')">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header and  local-name(../..)='section'  and $aStyle ='nuclear'">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text and contains($aStyle,'archaic')">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::level-header[@level='chapter']">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::toc-entry and ../@level='section'">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aStyle='USC' and not (parent::text  and @reported-display-style='strikethrough')">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header and (local-name(../..)='subsection' or  local-name(../..)='paragraph' or local-name(../..)='subparagraph' or local-name(../..)='clause' or local-name(../..)='subclause' or local-name(../..)='item' or local-name(../..)='subitem')">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header-in-text and (../@level='subsection' or  ../@level='paragraph' or ../@level='subparagraph' or ../@level='clause' or ../@level='subclause' or ../@level='item' or ../@level='subitem')">
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>     
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="actualPrintThePhrase">
        <xsl:param name="aPhraseBegining" />
        <xsl:param name="aPhraseEnding" />
        <xsl:param name="aMode" />     
        <xsl:variable name="phraseToPrint" as="item()*">
            <xsl:apply-templates mode="process" />
        </xsl:variable>       
        <xsl:value-of select="$aPhraseBegining" />
        <xsl:choose>
            <xsl:when test="$aMode='1' or $aMode='2' or $aMode='8'  ">
                <xsl:sequence select="upper-case($phraseToPrint)" />
            </xsl:when>
            <xsl:when test="$aMode='5'  or  $aMode='10' or $aMode='11' ">
                <xsl:sequence select="upper-case($phraseToPrint)" />
            </xsl:when>
            <xsl:when test="$aMode='3' or $aMode='4' or $aMode='6' or $aMode='9'">
                <xsl:sequence select="gpo:capitalize($phraseToPrint)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="$phraseToPrint" />
            </xsl:otherwise>
        </xsl:choose>
        <xsl:sequence select="$aPhraseEnding" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='brackets-boldface-roman']| deleted-phrase[@reported-display-style='brackets-boldface-roman']" mode="process">		
    <xsl:call-template name="spaceBeforeAddedDeleted" />
    <xsl:text>❨</xsl:text>
       <xsl:call-template name="phrase-boldface-roman" />
       <xsl:text>❩</xsl:text>
    <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='boldface-roman']| deleted-phrase[@reported-display-style='boldface-roman']" mode="process">		
        <xsl:call-template name="spaceBeforeAddedDeleted" />
        <xsl:call-template name="phrase-boldface-roman" />
        <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='boldface-italic']| deleted-phrase[@reported-display-style='boldface-italic']" mode="process">		
        <!-- TB 12July2010 Bug #1157 -->
        <xsl:call-template name="spaceBeforeAddedDeleted" />		
        <xsl:call-template name="phrase-boldface-italic" />
        <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='bold-brackets']| deleted-phrase[@reported-display-style='bold-brackets']" mode="process">
        <xsl:call-template name="spaceBeforeAddedDeleted" />	
        <xsl:variable name="toOpenBracketRam" as="xs:string">
            <xsl:call-template name="toOpenBracketDeletedPhraseRam" />
        </xsl:variable>
        <xsl:if test="$toOpenBracketRam='yes'">
            <xsl:text>❨</xsl:text>
        </xsl:if>
        <xsl:apply-templates mode="process" />
        <xsl:variable name="toCloseBracketRam" as="xs:string">
            <xsl:call-template name="toCloseBracketDeletedPhraseRam" />
        </xsl:variable>
        <xsl:if test="$toCloseBracketRam='yes'">
            <xsl:text>❩</xsl:text>
        </xsl:if>
        <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="NoTextAfter">		
        <xsl:param name="aCurrentText" />		       
        <xsl:variable name="aWholeText" as="xs:string">
            <xsl:for-each select="parent::node()">
                <xsl:value-of select="." />
            </xsl:for-each>		
        </xsl:variable>
        <xsl:variable name="stringPartToProceed_1" as="xs:string">
            <xsl:value-of select="normalize-space(substring-after($aWholeText, $aCurrentText))" />
        </xsl:variable>      
        <xsl:choose>	
            <xsl:when test="parent::subparagraph or parent::clause or parent::subclause or parent::item or parent::subitem">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$stringPartToProceed_1 = '' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>							
            <xsl:otherwise>
                <xsl:text>false</xsl:text>
            </xsl:otherwise>
        </xsl:choose>		
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toCloseBracketDeletedPhraseRam">
        <xsl:variable name="isInRamseyersCordon" as="xs:string">
            <xsl:call-template name="isRamseyerCordon" />
        </xsl:variable>
        <xsl:variable name="isNoTextAfter" as="xs:string">
            <xsl:call-template name="NoTextAfter">
                <xsl:with-param name="aCurrentText" select="." />
            </xsl:call-template>
        </xsl:variable>      
        <xsl:choose>
            <xsl:when test="$isInRamseyersCordon != 'yes'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="$isNoTextAfter ='false'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="parent::text">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(parent::enum/following-sibling::*[1]) = 'header' and parent::enum/following-sibling::*[1]/node()[1]/@reported-display-style='bold-brackets'">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(parent::enum/following-sibling::*[1]) = 'text' and parent::enum/following-sibling::*[1]/node()[1]/@reported-display-style='bold-brackets'">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="parent::header/following-sibling::text/node()[1]/@reported-display-style='bold-brackets'">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>yes</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toOpenBracketDeletedPhraseRam">
        <xsl:variable name="isInRamseyersCordon" as="xs:string">
            <xsl:call-template name="isRamseyerCordon" />
        </xsl:variable>
        <xsl:variable name="isNoTextBefore" as="xs:string">
            <xsl:call-template name="NoTextBefore">						
                <xsl:with-param name="aCurrentText" select="." />
            </xsl:call-template>
        </xsl:variable>     
        <xsl:choose>
            <xsl:when test="$isInRamseyersCordon != 'yes'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="$isNoTextBefore = 'false'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="parent::enum">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="parent::header/preceding-sibling::enum/node()[position()=last()]/@reported-display-style='bold-brackets'">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(parent::text/preceding-sibling::*[1])='header' and parent::text/preceding-sibling::*[1]/node()[position()=last()]/@reported-display-style='bold-brackets'">				
                <xsl:text>no</xsl:text>					
            </xsl:when>
            <xsl:when test="local-name(parent::text/preceding-sibling::*[1])='enum' and parent::text/preceding-sibling::*[1]/node()[position()=last()]/@reported-display-style='bold-brackets'">				
                <xsl:text>no</xsl:text>					
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>yes</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='bold-brackets']| deleted-phrase[@reported-display-style='bold-brackets']" mode="AllLower">		
        <xsl:call-template name="spaceBeforeAddedDeleted" />
        <xsl:text>❨</xsl:text><xsl:apply-templates mode="AllLower" /><xsl:text>❩</xsl:text>
        <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='strikethrough']| deleted-phrase[@reported-display-style='strikethrough']" mode="AllLower">
        <xsl:call-template name="spaceBeforeAddedDeleted" />	
        <xsl:choose>
            <xsl:when test="parent::subheader">
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:apply-templates mode="AllLower" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                <xsl:call-template name="spaceForAddedDeletedPhrase" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="AllLower" />
            </xsl:otherwise>
        </xsl:choose> 
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase|added-phrase[@reported-display-style='italic']| deleted-phrase[@reported-display-style='italic']|italic" mode="AllLower">
        <xsl:call-template name="spaceBeforeAddedDeleted" />
        <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
        <xsl:apply-templates mode="AllLower" />
        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
        <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='brackets-boldface-italic']| deleted-phrase[@reported-display-style='brackets-boldface-italic']" mode="process">		
        <xsl:call-template name="spaceBeforeAddedDeleted" />		
        <xsl:text>❨</xsl:text><xsl:call-template name="phrase-boldface-italic" /><xsl:text>❩</xsl:text>
        <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='brackets-boldface-roman']| deleted-phrase[@reported-display-style='brackets-boldface-roman']" mode="process">		
        <xsl:call-template name="spaceBeforeAddedDeleted" />	
        <xsl:text>❨</xsl:text><xsl:call-template name="phrase-boldface-roman" /><xsl:text>❩</xsl:text>
        <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="added-phrase[@reported-display-style='parentheses-boldface-roman']| deleted-phrase[@reported-display-style='parentheses-boldface-roman']" mode="process">		
        <xsl:call-template name="spaceBeforeAddedDeleted" />		
        <xsl:text>【</xsl:text><xsl:call-template name="phrase-boldface-roman" /><xsl:text>】</xsl:text>
        <xsl:call-template name="spaceForAddedDeletedPhrase" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="SpecialTextBefore">		
        <xsl:param name="aCurrentText" />			        
        <xsl:variable name="aWholeText" as="xs:string">
            <xsl:for-each select="parent::node()">
                <xsl:value-of select="." />
            </xsl:for-each>		
        </xsl:variable>
        <xsl:variable name="stringPartToProceed_1" as="xs:string">
            <xsl:value-of select="normalize-space(substring-before($aWholeText, $aCurrentText))" />
        </xsl:variable>
        <xsl:variable name="stringInBefore" as="xs:string">
            <xsl:value-of select="substring($stringPartToProceed_1, string-length($stringPartToProceed_1) , 1)" />
        </xsl:variable>	
        <xsl:variable name="string5ChBefore" as="xs:string">
            <xsl:value-of select="substring($stringPartToProceed_1, string-length($stringPartToProceed_1) - 4 ,5)" />
        </xsl:variable>	
        <xsl:variable name="string10ChBefore" as="xs:string">
            <xsl:value-of select="substring($stringPartToProceed_1, string-length($stringPartToProceed_1) - 9 ,10)" />
        </xsl:variable>	
        <xsl:choose>
            <xsl:when test="$stringInBefore = '(' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>	
            <xsl:when test="$stringInBefore = '[' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$stringInBefore = '+' ">			
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$stringInBefore = '-' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$stringInBefore = '—' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$stringInBefore = '–' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$stringInBefore = '‘' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$stringInBefore = '“' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>			
            <xsl:when test="$string5ChBefore = '&amp;' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>				
            <xsl:when test="$string10ChBefore = '[[[mdash]]]' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>	
            <xsl:when test="$string10ChBefore = '[[[ndash]]]' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$string10ChBefore = '[[[ensp]]]' ">				
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>false</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="spaceBeforeAddedDeleted">		
        <xsl:variable name="isSpecialTextBefore" as="xs:string">
            <xsl:call-template name="SpecialTextBefore">
                <xsl:with-param name="aCurrentText" select="." />
            </xsl:call-template>
        </xsl:variable>      
        <xsl:variable name="isNoTextBefore" as="xs:string">
            <xsl:call-template name="NoTextBefore">
                <xsl:with-param name="aCurrentText" select="." />
            </xsl:call-template>			
        </xsl:variable>	
        <xsl:variable name="IsGenerateEmDash" as="xs:string">
            <xsl:call-template name="GenerateEmDash">
                <xsl:with-param name="IsForFollowingSibling" select="'true'" />
                <xsl:with-param name="currentStyle" select="''" />
            </xsl:call-template>
        </xsl:variable>
        
        <xsl:choose>
            <xsl:when test="parent::enum" />           
            <xsl:when test="parent::toc-entry and (local-name(preceding-sibling::*[1]) = 'added-phrase' or local-name(preceding-sibling::*[1]) = 'deleted-phrase') " />
            <xsl:when test="parent::header and not(preceding-sibling::*) and $isNoTextBefore='true'" />
            <xsl:when test="substring(normalize-space(.),1,1) =',' or  substring(normalize-space(.),1,1) ='.'  or substring(normalize-space(.),1,1) =':'  or substring(normalize-space(.),1,1) =';' " />
            <xsl:when test="$isSpecialTextBefore = 'true'" />
            <xsl:when test="normalize-space(.)=''" />
            <xsl:when test="(parent::term or parent::quote) and not(preceding-sibling::*) and $isNoTextBefore='true'" />	
            <xsl:when test="(parent::quoted-block-continuation-text or parent::quoted-block) and not(preceding-sibling::*) and $isNoTextBefore='true'" />	
            <xsl:when test="substring(preceding-sibling::text()[1], string-length(preceding-sibling::text()[1]) - 10) = '[[[ldquo]]]' and (local-name()='italic' or local-name() = 'proviso')" />
            <xsl:when test="substring(parent::proviso/preceding-sibling::text()[1], string-length(parent::proviso/preceding-sibling::text()[1]) - 10) = '[[[ldquo]]]' and local-name()='italic' " />
            <xsl:when test="(local-name(ancestor::*[2]) = 'term' or local-name(ancestor::*[2]) ='quote') and not(parent::*/preceding-sibling) and not(preceding-sibling::*) and $isNoTextBefore='true'" />	
            <xsl:when test="$IsGenerateEmDash='true'" />
            <xsl:when test=".='l' or .='ll' or (contains(., 'l–')  and substring-before (.,  'l–') = '')  or (contains(.,'l[[[ndash]]]' ) and substring-before (.,'l[[[ndash]]]' ) = '') " />
            <xsl:when test=".='o' or .='oo' or (contains(., 'o–')  and substring-before (.,  'o–') = '')  or (contains(.,'l[[[ndash]]]' ) and substring-before (.,'l[[[ndash]]]' ) = '') " />
            <xsl:when test="parent::committee-report-header and $isNoTextBefore='true' " />
            <xsl:when test="parent::text and not (preceding-sibling::*) and $isNoTextBefore='true'" />
            <xsl:otherwise>
                <xsl:text> </xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="defineMode">
        <xsl:param name="aStyle" />
        <xsl:choose>			
            <xsl:when test=" ((parent::header and (local-name(../..) = 'division' or local-name(../..)='subdivision' or local-name(../..)='title'))                  or (parent::header-in-text and (../@level = 'division' or ../@level ='subdivision' or ../@level ='title')))                   and ($aStyle='USC' or $aStyle='OLC' or $aStyle='tax' or $aStyle='nuclear')">
                <xsl:text>1</xsl:text>
            </xsl:when>
            <xsl:when test="(((parent::header and local-name(../..) = 'division' )                  or (parent::header-in-text and ../@level = 'division' ))                  and ($aStyle='traditional' or $aStyle='appropriations'  or contains($aStyle, 'archaic')))                 or(((parent::header and local-name(../..) = 'title' )                  or (parent::header-in-text and ../@level = 'title' ))                  and (contains($aStyle,'traditional') or $aStyle='appropriations'  or contains($aStyle, 'archaic')))                 or(((parent::header and local-name(../..) = 'chapter' )                  or (parent::header-in-text and ../@level = 'chapter'))                  and ($aStyle='traditional-inline' or $aStyle='appropriations'  or $aStyle='nuclear'))                 or(((parent::header and local-name(../..) = 'subchapter' )                  or (parent::header-in-text and ../@level = 'subchapter'))                  and ($aStyle='traditional'  or $aStyle='USC' or contains($aStyle, 'archaic')))                 or (parent::header-in-text and ../@level = 'appropriations-major')">
                <xsl:text>2</xsl:text>
            </xsl:when>
            <xsl:when test="((parent::header and local-name(../..) = 'subtitle' )                  or (parent::header-in-text and ../@level = 'subtitle'))                   and ($aStyle='USC' or $aStyle='OLC' or $aStyle='tax'  or $aStyle='nuclear')">
                <xsl:text>3</xsl:text>
            </xsl:when>
            <xsl:when test="(((parent::header and local-name(../..) = 'subpart' )                  or (parent::header-in-text and ../@level = 'subpart'))                  and ($aStyle='OLC' or $aStyle='USC' or $aStyle='tax'  or $aStyle='nuclear'))">
                <xsl:text>3</xsl:text>
            </xsl:when>
            <xsl:when test="(((parent::header and (local-name(../..) = 'subtitle' or  local-name(../..)='subpart')                  or (parent::header-in-text and (../@level = 'subtitle' or ../@level = 'subpart')))                  and (contains($aStyle,'traditional') or $aStyle='appropriations'  or contains($aStyle, 'archaic'))))                 or (((parent::header and local-name(../..) = 'subdivision')                  or (parent::header-in-text and ../@level = 'subdivision'))                  and ($aStyle='traditional'  or contains($aStyle, 'archaic')))                 or (((parent::header and local-name(../..)='subchapter') or (parent::header-in-text and ../@level = 'subchapter') ) and ($aStyle='traditional-inline' or $aStyle='appropriations'))                 or (((parent::header and local-name(../..)='subsection') or (parent::header-in-text and ../@level = 'subsection') ) and contains($aStyle, 'archaic'))    ">
                <xsl:text>4</xsl:text>
            </xsl:when>
            <xsl:when test="((parent::header and local-name(../..) = 'part' )                  or (parent::header-in-text and ../@level = 'part'))                  and ($aStyle='OLC' or $aStyle='USC' or $aStyle='tax'  or $aStyle='nuclear')">
                <xsl:text>5</xsl:text>
            </xsl:when>
            <xsl:when test="(((parent::header and local-name(../..) = 'part' )                  or (parent::header-in-text and ../@level = 'part'))                  and (contains($aStyle,'traditional') or $aStyle='appropriations' or contains($aStyle, 'archaic')))                 or (((parent::header and local-name(../..) = 'section' )                  or (parent::header-in-text and ../@level = 'section'))                  and ($aStyle='traditional-inline' or $aStyle='appropriations'  or $aStyle='nuclear'))                 or (((parent::header and local-name(../..) = 'subsection' )                  or (parent::header-in-text and ../@level = 'subsection'))                  and not(contains($aStyle, 'archaic')))                 or (parent::header-in-text and ../@level = 'appropriations-intermediate')">
                <xsl:text>6</xsl:text>
            </xsl:when>
            <xsl:when test="(((parent::header and local-name(../..) = 'chapter' )                  or (parent::header-in-text and ../@level = 'chapter'))                  and (contains($aStyle, 'archaic') or $aStyle='traditional' or $aStyle='tax'  or $aStyle='USC' or $aStyle='OLC'))                 or (((parent::header and local-name(../..) = 'division' )                  or (parent::header-in-text and ../@level = 'division'))                  and $aStyle='traditional-inline')">
                <xsl:text>8</xsl:text>
            </xsl:when>
            <xsl:when test="(((parent::header and local-name(../..) = 'subchapter' )                  or (parent::header-in-text and ../@level = 'subchapter'))                  and ($aStyle='tax'  or $aStyle='nuclear' or $aStyle='OLC'))                 or (((parent::header and local-name(../..) = 'subdivision' )                  or (parent::header-in-text and ../@level = 'subdivision'))                  and( $aStyle='traditional-inline' or $aStyle='appropriations' )) ">
                <xsl:text>9</xsl:text>
            </xsl:when>
            <xsl:when test="((parent::header and local-name(../..) = 'section' )                  or (parent::header-in-text and ../@level = 'section'))                  and ($aStyle='tax' or $aStyle='OLC')">
                <xsl:text>10</xsl:text>
            </xsl:when>
            <xsl:when test="(((parent::header and local-name(../..) = 'section' )                  or (parent::header-in-text and ../@level = 'section'))                  and (contains($aStyle, 'archaic') or $aStyle='traditional' ))                 or (parent::header-in-text and ../@level = 'appropriations-small')                 or (((parent::header and local-name(../..)='paragraph') or (parent::header-in-text and ../@level = 'paragraph') ) and $aStyle='archaic-paragraph')">
                <xsl:text>11</xsl:text>
            </xsl:when>
            <xsl:when test="(parent::header and (local-name(../..)='subparagraph' or local-name(../..)='clause' or local-name(../..)='subclause' or local-name(../..)='item' or local-name(../..)='subitem'))                 or (parent::header-in-text and (../@level='subparagraph' or ../@level ='clause' or  ../@level ='subclause' or ../@level ='item' or ../@level ='subitem'))                 or (((parent::header and local-name(../..)='paragraph') or (parent::header-in-text and ../@level='paragraph' )) and $aStyle != 'archaic-paragraph')">
                <xsl:text>12</xsl:text>
            </xsl:when>
            <xsl:when test="((parent::header and local-name(../..) = 'section' ) or (parent::header-in-text and ../@level = 'section')) and $aStyle='USC'">
                <xsl:text>13</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>NoMode</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="phrase-italic">
	    <xsl:variable name="node" select="." as="node()" />
	    <xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
	    <xsl:variable name="style" as="item()">
		    <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
		</xsl:variable>
	    <xsl:variable name="isInRamseyer" as="xs:string">
			<xsl:call-template name="isRamseyerCordon" />
		</xsl:variable>
	    <xsl:variable name="isExceptionalHeader" as="xs:string">
			<xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />		
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$isExceptionalHeader='true'">
				<!--<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocatorExt">
					<xsl:with-param name="isBold">
						<xsl:choose>
							<xsl:when test="ancestor::header/@bold='on'">
								<xsl:text>yes</xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text>no</xsl:text>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:with-param>
					<xsl:with-param name="isItalic">yes</xsl:with-param>
					<xsl:with-param name="headerStyle" select="ancestor::header/@header-style"/>
					<xsl:with-param name="headerSize" select="ancestor::header/@size"/>
				</xsl:call-template>-->
				<xsl:apply-templates mode="process" />
			    <xsl:variable name="theCallOutCode" as="xs:string?">
					<!--<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocatorExt">
						<xsl:with-param name="isItalic">no</xsl:with-param>
						<xsl:with-param name="headerStyle" select="ancestor::header/@header-style"/>
						<xsl:with-param name="headerSize" select="ancestor::header/@size"/>
					</xsl:call-template>-->
				</xsl:variable>
				<xsl:choose>
					<xsl:when test="$theCallOutCode != ''">
						<xsl:value-of select="$theCallOutCode" />
					</xsl:when>
					<xsl:otherwise>
					    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="parent::header and contains($docstage, 'Enrolled')">
			    <xsl:variable name="aMode" as="xs:string">
					<xsl:call-template name="defineMode">
						<xsl:with-param name="aStyle" select="$style" />
					</xsl:call-template>
				</xsl:variable>
				<xsl:choose>
					<xsl:when test="$aMode = '1' or $aMode='8' or $aMode = '10' ">
						    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
						    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="upper-case($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>	
					<xsl:when test="$aMode = '2' ">
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="upper-case($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '3'">
					    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="gpo:capitalize($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '4'">
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="gpo:capitalize($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
									<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '5' ">
					    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="upper-case($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '6'">
					    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="gpo:capitalize($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>						
					<xsl:when test="$aMode = '9'">
					    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="gpo:capitalize($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>					
					<xsl:when test="$aMode = '11' ">
					    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="lower-case($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode='12'">
					    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="$phraseToPrint" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '13'">
					    <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="$phraseToPrint" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
				</xsl:choose>
				<xsl:if test="../@level='appropriations-major'">
				    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="../@level='appropriations-intermediate'">
				    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="../@level='appropriations-small'">
				    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
			</xsl:when>
			<xsl:when test="parent::header-in-text">
			    <xsl:variable name="aMode" as="xs:string">
					<xsl:call-template name="defineMode">
						<xsl:with-param name="aStyle" select="$style" />
					</xsl:call-template>
				</xsl:variable>
				<xsl:choose>
					<xsl:when test="$aMode = '1'">
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="upper-case($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '2'">
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="upper-case($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '3'">
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="gpo:capitalize($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '4'">
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="gpo:capitalize($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '5'">
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						<xsl:value-of select="upper-case($phraseToPrint)" />
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>					
					<xsl:when test="$aMode = '6'">
						<xsl:choose>
							<xsl:when test="$isInRamseyer='yes'">
							    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
							</xsl:when>
							<xsl:otherwise>
							    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
							</xsl:otherwise>
						</xsl:choose>						
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="gpo:capitalize($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '8'">
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="upper-case($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '9'">
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="gpo:capitalize($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '10'">
						<xsl:choose>
							<xsl:when test="$isInRamseyer='yes'">
							    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
							    <xsl:variable name="phraseToPrint" as="xs:string">
									<xsl:apply-templates mode="process" />
								</xsl:variable>
								<xsl:value-of select="upper-case($phraseToPrint)" />	
							    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
								<xsl:call-template name="spaceForAddedDeletedPhrase" />
							</xsl:when>
							<xsl:otherwise>
							    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
							    <xsl:variable name="phraseToPrint" as="xs:string">
									<xsl:apply-templates mode="process" />
								</xsl:variable>
								<xsl:value-of select="upper-case($phraseToPrint)" />
							    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
								<xsl:call-template name="spaceForAddedDeletedPhrase" />
							</xsl:otherwise>
						</xsl:choose>												
					</xsl:when>
					<xsl:when test="$aMode = '11' ">
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="upper-case($phraseToPrint)" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode='12'">
						<xsl:choose>
							<xsl:when test="$isInRamseyer='yes'">
							    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
							</xsl:when>
							<xsl:otherwise>
							    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
							</xsl:otherwise>
						</xsl:choose>					
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="$phraseToPrint" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="$aMode = '13'">
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					    <xsl:variable name="phraseToPrint" as="xs:string">
							<xsl:apply-templates mode="process" />
						</xsl:variable>
						<xsl:value-of select="$phraseToPrint" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
				</xsl:choose>				
			</xsl:when>
			<xsl:when test="local-name(../..)='division'   or local-name(../..)='subpart'  or local-name(../..)='subtitle' or local-name(../..)='chapter' or local-name(../..)='part' or local-name(../..)='title' or local-name(../..)='subchapter' ">
				<xsl:choose>
					<xsl:when test="local-name(../..)='subpart' and $style='tax' or $style='Tax'">
						 <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
						<xsl:apply-templates mode="process" />
					    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
						<xsl:call-template name="spaceForAddedDeletedPhrase" />
					</xsl:when>
					<xsl:when test="local-name(../..)='subchapter' and $style='USC' ">
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
						<xsl:apply-templates mode="process" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					</xsl:when>
					<xsl:when test="$billstage='Reported-in-Senate' and not(parent::toc-entry) and  $style='USC' ">
						<xsl:choose>
							<xsl:when test="ancestor::multi-column-toc-entry[@level='chapter']">
							    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
							</xsl:when>
							<xsl:otherwise>
								 <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:apply-templates mode="process" />
						<xsl:choose>
							<xsl:when test="ancestor::chapter or local-name(../..)='subchapter'">
							    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
							</xsl:when>
							<xsl:otherwise>
							    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
								<xsl:call-template name="spaceForAddedDeletedPhrase" />
							</xsl:otherwise>
						</xsl:choose>
					</xsl:when>
					<xsl:when test="$isInRamseyer = 'yes'  and (local-name(../..)='title'  or local-name(../..)='subtitle' )">
					    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
						<xsl:apply-templates mode="process" />
					    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					</xsl:when>
					<xsl:when test="(local-name(../..)='title'  or local-name(../..)='subtitle'  or local-name(../..)='subpart' )and (starts-with($style , 'traditional') or starts-with($style , 'Traditional') or  $style='appropriations' or contains($style, 'archaic'))">
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
						<xsl:apply-templates mode="process" />
					    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					</xsl:when>
					<xsl:when test="local-name(../..)='subtitle' and starts-with($style , 'traditional') or starts-with($style , 'Traditional') "> 
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
						<xsl:apply-templates mode="process" />
					    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>

					</xsl:when>
					<xsl:when test="local-name(../..)='subchapter' and (starts-with($style , 'traditional') or starts-with($style , 'Traditional') or  $style='appropriations' ) ">
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					    <xsl:apply-templates mode="process" />
					    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					</xsl:when>
					<!--<xsl:when
						test="local-name(../..)='subpart' and (starts-with($style , 'traditional') or starts-with($style , 'Traditional' or  $style='appropriations' )) ">
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					    <xsl:apply-templates mode="process"/>
					    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					</xsl:when>-->
					<xsl:when test="local-name(../..)='part' and (starts-with($style , 'traditional') or  $style='appropriations'  or contains($style,'archaic')) ">
					    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
						<xsl:apply-templates mode="process" />
					    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					</xsl:when>
					<xsl:when test="local-name(../..)='chapter' and $style = 'traditional' ">
						 <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
						<xsl:apply-templates mode="process" />
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					</xsl:when>
					<xsl:when test="(local-name(../..)='chapter' and ($style = 'traditional-inline'  or $style='nuclear' or $style='appropriations') or (local-name(../..)='subchapter'  and contains($style, 'archaic')))">
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
						<xsl:apply-templates mode="process" />
					    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
					</xsl:when>
					<xsl:otherwise>
						<xsl:choose>
							<xsl:when test="local-name(../..)='division'  and (contains($style, 'archaic') or $style ='traditional')">
							    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
							</xsl:when>
							<xsl:otherwise>
								 <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:apply-templates mode="process" />
						<xsl:choose>
							<xsl:when test="local-name(../..)='division'  and contains($style, 'archaic')">
							    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
							</xsl:when>
							<xsl:when test="local-name(../..)='chapter'  or local-name(../..)='subchapter' ">
							    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
							</xsl:when>
							<xsl:when test="(local-name(../..)='division'  or local-name(../..)='subdivision') and ($style='traditional-inline' or $style='appropriations')">
							    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
							    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
							</xsl:when>
							<xsl:otherwise>
							    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
								<xsl:call-template name="spaceForAddedDeletedPhrase" />
							</xsl:otherwise>
						</xsl:choose>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="local-name(../..)='subdivision'  and contains($style, 'archaic')">
			    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="(local-name(../..)='subdivision' or  (local-name(../..)='section'  and parent::enum)) and ($style='OLC' or $style='USC' ) and ancestor::existing-law">		    
			    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="(local-name(../..)='subdivision' or  (local-name(../..)='section'  and parent::enum)) and ($style='OLC' or $style='USC' )">
				 <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="local-name(../..)='subdivision'  and parent::enum and ($style = 'traditional-inline' or $style='appropriations')">
			    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="local-name(../..)='subdivision'  and (parent::enum or parent::header) and $style = 'traditional' ">
			    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="parent::toc-entry and $style='USC' and ../@level='subchapter' ">
			    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<!-- this section handles the case when the parent is toc-entry -->
			<xsl:when test="parent::toc-entry and ../@level='title' ">
			    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::toc-entry and ../@level='subtitle' ">
			    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="parent::toc-entry and ../@level='chapter' and starts-with($style , 'traditional') ">
			    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::toc-entry and ../@level='subchapter' and starts-with($style , 'traditional') ">
			    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="parent::toc-entry and  ../@level='part' and starts-with($style , 'traditional') ">
			    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::toc-entry and  ../@level='subpart' and starts-with($style , 'traditional') ">
							<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="parent::toc-entry and ../@level='chapter' or ../@level='subchapter' or ../@level='subpart' or ../@level='part' ">
			    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::toc-entry and ../@level='section' ">
							<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::toc-entry and ($style='USC' or $style='tax' ) ">
							<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<!-- this ends the section where the parent is toc-entry -->
			<xsl:when test="contains($billstage,'Reported') and local-name(..)='level-header' and ../@level='chapter' and  $style='USC' ">
							<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:if test="local-name(../..)='subchapter'">
				    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				</xsl:if>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::text and $style='USC'">
			    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="contains($billstage,'Reported') and parent::enum and local-name(../..)='section' and ($style='OLC' or $style='tax'  or $style='defense' or $style='') ">
				 <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::quote">
			    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="local-name(/*)='resolution' and parent::header and local-name(../..)='section' and (contains($style, 'traditional') or  $style='appropriations')">
			    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="local-name(/*)='resolution' and parent::header and local-name(../..)='section' ">
				<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="local-name(/*)='resolution' and parent::header and local-name(../..)='subsection' and starts-with($style , 'archaic')">
				<xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
			    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::toc-entry">
				<xsl:if test="../@level='subtitle' or ../@level='title'   or ../@level='division' ">
								<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
								<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="../@level='chapter' or ../@level='subchapter' or ../@level='subpart' or ../@level='part' ">
				    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
								<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
			</xsl:when>
			<xsl:when test="parent::text and contains(@reported-display-style,'brackets')">
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:when test="parent::text or parent::continuation-text or parent::enum  or parent::quote or parent::toc-entry or parent::inline-comment">
							<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:if test="local-name(parent::enum/following-sibling::*[1]) ='header' and $style='traditional-inline'">
				    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
				</xsl:if>
				<xsl:if test="../../@vbattFormat">
				    <xsl:processing-instruction name="xpp" />
					<!--<xsl:text disable-output-escaping="yes">&lt;BEL&gt;</xsl:text>-->
					<!--<xsl:value-of select="../../@vbattFormat"/>-->
				</xsl:if>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::header">
				<xsl:if test="local-name(../..)='division'">
								<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
								<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					<!-- SM 4/27/2007 - used new function to add missing space -->
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="local-name(../..)='subdivision' and ($style='tax' or $style='nuclear')">
					 <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
								<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="local-name(../..)='subdivision' and $style='traditional-inline' ">
					 <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="local-name(../..)='section'">
					<xsl:choose>						
						<!--xsl:when test="@style='USC' "-->
						<xsl:when test="$style='USC' and $isInRamseyer='yes' ">
						    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
						    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="$style='USC' ">
							 <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="($style='traditional' or $style='traditional-inline'  or $style='archaic' or $style='archaic-paragraph') and $isInRamseyer='yes'">
						    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
						    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="$style='traditional' or $style='traditional-inline'  or $style='archaic' or $style='archaic-paragraph'">
						    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
						    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="$style = 'nuclear' ">
						    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
						    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="$style = 'OLC' and ancestor-or-self::existing-law  and (parent::header)">
						    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
						    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
						</xsl:when>
						<xsl:otherwise>
						    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
						    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:apply-templates mode="process" />
					<xsl:choose>
						<xsl:when test="$style = 'nuclear'  or $style='traditional-inline'">
						    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
						</xsl:when>
						<xsl:otherwise>
										<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="local-name(../..)='subsection'  and contains($style,'archaic')">
				    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="(local-name(../..)='subsection' and not (contains($style,'archaic'))) or  local-name(../..)='paragraph' or local-name(../..)='subparagraph' or local-name(../..)='clause' or local-name(../..)='subclause' or local-name(../..)='item' or local-name(../..)='subitem'">
					<xsl:choose>
						<xsl:when test="$isInRamseyer='yes'">
						    <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
						    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
						</xsl:when>
						<xsl:otherwise>
						    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
						    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
						</xsl:otherwise>
					</xsl:choose>	
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="local-name(../..)='appropriations-major'">
				    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="local-name(../..)='appropriations-intermediate'">
				    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
				<xsl:if test="local-name(../..)='appropriations-small'">
				    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
			</xsl:when>
			<xsl:when test="parent::subheader">
				<xsl:if test="contains(local-name(../..), 'appropriations')">
				    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:call-template name="spaceForAddedDeletedPhrase" />
				</xsl:if>
			</xsl:when>
			<xsl:when test="parent::list-item">
							<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
				<xsl:call-template name="spaceForAddedDeletedPhrase" />
			</xsl:when>
			<xsl:when test="parent::added-phrase or (parent::proviso and local-name() = 'italic') or (parent::italic and local-name()='provisio') ">
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:otherwise>
							<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
				<xsl:apply-templates mode="process" />
							<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:if test="following-sibling::deleted-phrase">
					<xsl:text> </xsl:text>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="phrase-boldface-roman">
        <xsl:variable name="endCode" as="node()*">
            <xsl:choose>
                <xsl:when test="((parent::header and local-name(../..)='title' ) or (parent::header-in-text and parent::header-in-text/@level='title')) and @reported-display-style='brackets-boldface-roman'">
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                    </xsl:when>
                <!-- <xsl:when test="parent::header and local-name(../..)='title'">&lt;BEL&gt;G1</xsl:when> -->
                <xsl:when test="(parent::header and local-name(../..)='chapter' ) or  (parent::header-in-text and parent::header-in-text/@level='chapter')" />
                <xsl:when test="parent::enum and local-name(../..)='chapter' ">
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                    </xsl:when>
                <xsl:when test="(parent::header and local-name(../..)='subchapter')  or (parent::header-in-text and parent::header-in-text/@level='subchapter') ">
                    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="parent::toc-entry and ../@level='subtitle' ">
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></xsl:when>
                <!--Siakzar:051707-->
                <xsl:when test="parent::text ">
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="local-name(../..)='subsection' or parent::header-in-text/@level='subsection' or  local-name(../..)='paragraph'  or parent::header-in-text/@level='paragraph'  or local-name(../..)='subparagraph' or parent::header-in-text/@level='subparagraph'  or local-name(../..)='clause'  or parent::header-in-text/@level='clause' or local-name(../..)='subclause'  or parent::header-in-text/@level='subclause'  or local-name(../..)='item' or parent::header-in-text/@level='item' or local-name(../..)='subitem' or parent::header-in-text/@level='subitem' ">
                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                    
                </xsl:when>
                <xsl:otherwise>
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                    <xsl:if test="../../@vbattFormat">
                        <xsl:processing-instruction name="xpp">
                        <xsl:value-of select="../../@vbattFormat" />
                        </xsl:processing-instruction>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="beginCode" as="processing-instruction()*">
            <xsl:choose>
                <xsl:when test="parent::text">
                    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="parent::header">
                    <xsl:choose>
                        <xsl:when test="local-name(../..) = 'section'  and  ../../@style='traditional' ">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="local-name(../..) = 'section' or local-name(../..) = 'subchapter'                              or local-name(../..)='title'  or  local-name(../..)='division'                             or local-name(../..)='subtitle'                               or local-name(../..)='subpart'  or  local-name(../..)='chapter'">
                            <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="local-name(../..)='subsection' or  local-name(../..)='paragraph'                              or local-name(../..)='subparagraph' or local-name(../..)='clause'  or  local-name(../..)='part'                             or local-name(../..)='subclause' or local-name(../..)='item' or local-name(../..)='subitem'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise />
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="parent::header-in-text">
                    <xsl:choose>
                        <xsl:when test="parent::header-in-text/@level = 'section'  and  ../../@style='traditional' ">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="parent::header-in-text/@level  = 'section' or parent::header-in-text/@level = 'subchapter'                              or parent::header-in-text/@level ='title'  or  parent::header-in-text/@level ='division'                             or parent::header-in-text/@level ='subtitle'                               or parent::header-in-text/@level ='subpart'  or  parent::header-in-text/@level ='chapter'">
                            <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="parent::header-in-text/@level ='subsection' or parent::header-in-text/@level ='paragraph'                              or parent::header-in-text/@level ='subparagraph' or parent::header-in-text/@level ='clause'  or  parent::header-in-text/@level ='part'                             or parent::header-in-text/@level ='subclause' or parent::header-in-text/@level ='item' or parent::header-in-text/@level ='subitem'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise />
                    </xsl:choose>
                </xsl:when>
                
                <!-- TB 15Oct2007 the commented logic removed. For review see revision #425 of version control -->
                
                <xsl:when test="parent::toc-entry">
                    <xsl:choose>
                        <xsl:when test="../@level='chapter' or ../@level='subchapter' or ../@level='part' or ../@level='subpart' ">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>			
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="$beginCode" />
        <xsl:variable name="intTextToPrint" as="item()+">
            <xsl:apply-templates mode="process" />
        </xsl:variable>     
        <xsl:choose>
            <xsl:when test="parent::header-in-text/@level='subsection' ">
                <xsl:value-of select="gpo:capitalize($intTextToPrint)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$intTextToPrint" />
            </xsl:otherwise>
        </xsl:choose>		
        <xsl:value-of select="$endCode" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="phrase-boldface-italic">
        <xsl:variable name="endCode" as="xs:string">
            <xsl:choose>
                <!-- <xsl:when test="parent::header and local-name(../..)='chapter' ">&lt;BEL&gt;G1&lt;BEL&gt;T2</xsl:when> -->
                <xsl:when test="(parent::header and local-name(../..)='chapter' ) or (parent::header-in-text/@level='chapter')">
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="parent::enum and local-name(../..)='chapter' ">
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="parent::toc-entry and ../@level='subtitle' ">
                    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></xsl:when>
                <xsl:when test="parent::text ">
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="local-name(../..)='subsection' or parent::header-in-text/@level='subsection' or  local-name(../..)='paragraph' or parent::header-in-text/@level='paragraph' or local-name(../..)='subparagraph'  or parent::header-in-text/@level='subparagraph'                      or local-name(../..)='clause' or parent::header-in-text/@level='clause' or local-name(../..)='subclause' or parent::header-in-text/@level='subclause' or local-name(../..)='item' or parent::header-in-text/@level='item' or local-name(../..)='subitem'  or parent::header-in-text/@level='subitem'">
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                </xsl:when>							
                <xsl:otherwise>
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                    <xsl:if test="../../@vbattFormat">
                        <para>
                            <xsl:attribute name="loc">
                        <xsl:value-of select="../../@vbattFormat" />
                            </xsl:attribute>
                        </para>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>        
        <xsl:variable name="beginCode" as="processing-instruction()+">
            <xsl:choose>
                <xsl:when test="parent::text">
                    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="parent::header">
                    <xsl:choose>
                        <xsl:when test="(local-name(../..) = 'section'  and  ../../@style='traditional')                             or  (local-name(../..)='part'  and  ../../@style='traditional') ">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="local-name(../..) = 'section' or local-name(../..)='title'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="local-name(../..)='subsection' or  local-name(../..)='paragraph' or local-name(../..)='subparagraph' or local-name(../..)='clause' or local-name(../..)='subclause' or local-name(../..)='item' or local-name(../..)='subitem'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">f4;3</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="local-name(../..)='appropriations-small'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="local-name(../..)='appropriations-intermediate'">                  
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>3</xsl:when>
                        <xsl:when test="local-name(../..)='part'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        </xsl:when>						
                        <xsl:otherwise>
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>                         
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="parent::header-in-text">
                    <xsl:choose>
                        <xsl:when test="(parent::header-in-text/@level = 'section'  and  ../../@style='traditional')                             or  (parent::header-in-text/@level='part'  and  ../../@style='traditional') ">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="parent::header-in-text/@level = 'section' or parent::header-in-text/@level='title'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="parent::header-in-text/@level='subsection' or  parent::header-in-text/@level='paragraph' or parent::header-in-text/@level='subparagraph' or parent::header-in-text/@level='clause' or parent::header-in-text/@level='subclause' or parent::header-in-text/@level='item' or parent::header-in-text/@level='subitem'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="parent::header-in-text/@level='appropriations-small' ">  
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="parent::header-in-text/@level='appropriations-intermediate' ">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="parent::header-in-text/@level='part'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        </xsl:when>						
                        <xsl:otherwise>
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="parent::toc-entry">
                    <xsl:choose>
                        <xsl:when test="../@level='chapter'  or ../@level='part' ">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="../@level='subchapter' or ../@level='subpart' ">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:when>
                        <!-- NB 11/13/2006 - added condition -->
                        <xsl:when test="parent::toc-entry and ../@level='subtitle'">
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="$beginCode" />
        <xsl:call-template name="printTextWithNumberUpSpecialPhrase" />
        <xsl:value-of select="$endCode" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="printTextWithNumberUpSpecialPhrase">
        <xsl:variable name="intTextAppropIntermediateBolfaceItalic" as="item()*">			
            <xsl:apply-templates mode="process" />
        </xsl:variable>				
        <xsl:choose>
            <xsl:when test="parent::header and local-name(../..)='appropriations-intermediate'  ">				
                <xsl:variable name="textContainsNumbers" as="xs:string">
                    <xsl:call-template name="isContainsNumbers">
                        <xsl:with-param name="aInputText" select="$intTextAppropIntermediateBolfaceItalic" />
                    </xsl:call-template>
                </xsl:variable>	
                <xsl:if test="$textContainsNumbers ='Yes'">
                    <xsl:call-template name="numbersUpForAppropriationHeader">
                        <xsl:with-param name="inputText" select="$intTextAppropIntermediateBolfaceItalic" />
                    </xsl:call-template>
                </xsl:if>
                <xsl:if test="$textContainsNumbers ='No'">
                    <xsl:value-of select="$intTextAppropIntermediateBolfaceItalic" />
                </xsl:if>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="parent::header-in-text/@level='subsection'  ">
                        <xsl:value-of select="gpo:capitalize($intTextAppropIntermediateBolfaceItalic)" />	
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$intTextAppropIntermediateBolfaceItalic" />
                    </xsl:otherwise>
                </xsl:choose>				
            </xsl:otherwise>
        </xsl:choose>		
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="isContainsNumbers">
        <xsl:param name="aInputText" />		
        <xsl:choose>
            <xsl:when test="translate($aInputText,$xsltsl-str-digits, 'xxxxxx') = $aInputText">
                <xsl:text>No</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>Yes</xsl:text>
            </xsl:otherwise>
        </xsl:choose>		
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="inlinehearedlocator"> 
        <xsl:variable name="node" select="." as="node()" />
        <xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
        <xsl:variable name="inQuotedBlock" as="xs:string">
            <xsl:choose>
                <xsl:when test="ancestor::quoted-block">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="isCommented" as="xs:string">
            <xsl:choose>
                <xsl:when test="./@commented='yes'">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="style" as="xs:string">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable> 
       
        <xsl:choose>
            <xsl:when test="parent::rule">
                <para loc="74" />
            </xsl:when>
            <xsl:when test="parent::rules-paragraph or parent::rules-clause">
                <para loc="75"><xsl:apply-templates /></para>
            </xsl:when>
            <xsl:when test="parent::chapter"> 
                <xsl:choose>
                    <xsl:when test="$style= 'traditional' and //bill[@bill-type='appropriations']  ">
                        <para loc="74" />
                    </xsl:when>
                    <xsl:when test="$style= 'nuclear'">
                        <para loc="74" />
                    </xsl:when>
                    <xsl:when test="$style= 'education'">
                        <para loc="73" />
                    </xsl:when>
                    <xsl:otherwise>
                        <para loc="74" />
                        <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>            
                <xsl:choose>                  
                    <xsl:when test="( parent::part or parent::title  or  parent::division or parent::subchapter ) and (starts-with($style , 'traditional') or starts-with($style , 'archaic')  or $style='appropriations')">
                        <para loc="74" />
                    </xsl:when>
                    <xsl:when test="starts-with($style , 'traditional') or starts-with($style , 'archaic')  or $style='appropriations'">
                        <para loc="74" />
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    </xsl:when>
                    
                    <xsl:when test="parent::subchapter  and  $style = 'USC'">
                        <para loc="74" />
                    </xsl:when>
                    <xsl:when test="parent::part  and ($style = 'USC' or  $style = 'OLC') ">
                        <para loc="73" />
                    </xsl:when>                    
                    <xsl:when test="parent::subchapter and  ($style = 'USC' or  $style = 'OLC')">
                        <para loc="74" />
                        <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="parent::subpart  and  ($style = 'USC' or  $style = 'OLC')">
                        <para loc="73" />
                    </xsl:when>
                    <xsl:otherwise>
                       <!-- <para loc="78"/>-->
                    </xsl:otherwise>
                </xsl:choose>             
            </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="$isCommented='yes'">
            <xsl:text>❨</xsl:text>
        </xsl:if>       
        <xsl:if test="$inQuotedBlock='yes'">
            <xsl:value-of select="gpo:QuotedBlockNestingStart($node)" />
        </xsl:if>  
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="lastCharPeriod">
        <xsl:choose>
            <xsl:when test="not (ancestor::ramseyer) and not (ancestor::cordon)">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="substring(normalize-space(.), string-length(normalize-space(.) ) , 1) = '.'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="runSpecialCharsExcEnumInHeader">
        <xsl:variable name="printSpecialChars">
            <xsl:call-template name="toPrintEnumInHeaderInSpecialChars" />
        </xsl:variable>
        <xsl:variable name="printSpecialCharsForSuperScript">
            <xsl:call-template name="toPrintEnumInHeaderInSpecialCharsSuperscript" />
        </xsl:variable>
        <xsl:variable name="isExceptionalHeader">
            <xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />		
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$printSpecialCharsForSuperScript != ''">
                <xsl:value-of select="$printSpecialCharsForSuperScript" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="$printSpecialChars='yes' and $isExceptionalHeader = 'false'">
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                </xsl:if>			
                <xsl:apply-templates select="." mode="process" />
                <xsl:if test="$printSpecialChars='yes' and $isExceptionalHeader = 'false'">
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintEnumInHeaderInSpecialCharsSuperscript">
        <xsl:variable name="node" select="." />
        <!--BH:  These are required for the function but were not defined in the template-->
        <xsl:variable name="sectionStyleOverlapped">false</xsl:variable>
        <xsl:variable name="currElementStyle">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="local-name() != 'superscript'">
                <xsl:text />
            </xsl:when>
            <xsl:when test="contains($currElementStyle, 'traditional') and (local-name(ancestor::*[2]) = 'section' ) ">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:apply-templates select="." mode="process" />
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$currElementStyle= 'traditional' and (local-name(ancestor::*[2]) = 'division'  or                        local-name(ancestor::*[2]) = 'subchapter' ) ">              
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates select="." mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toPrintEnumInHeaderInSpecialChars">
        <xsl:variable name="node" select="." />
        <!--BH:  These are required for the function but were not defined in the template-->
        <xsl:variable name="sectionStyleOverlapped">false</xsl:variable>
        <xsl:variable name="currElementStyle">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="local-name() = 'superscript' ">
                <xsl:choose>
                    <xsl:when test="$currElementStyle='USC' and (local-name(ancestor::*[2]) = 'division' or local-name(ancestor::*[2]) = 'title' or  local-name(ancestor::*[2]) = 'subtitle'  or  local-name(ancestor::*[2]) = 'part' or local-name(ancestor::*[2]) = 'subpart' or local-name(ancestor::*[2]) = 'chapter'   )">
                        <xsl:text>no</xsl:text>
                    </xsl:when>
                    <xsl:when test="$currElementStyle='OLC' and (local-name(ancestor::*[2]) = 'division' or local-name(ancestor::*[2]) = 'title' or  local-name(ancestor::*[2]) = 'subtitle'  or  local-name(ancestor::*[2]) = 'part' or local-name(ancestor::*[2]) = 'subpart' or local-name(ancestor::*[2]) = 'chapter'  or local-name(ancestor::*[2]) = 'subchapter'  or local-name(ancestor::*[2]) = 'section'   )">
                        <xsl:text>no</xsl:text>
                    </xsl:when>					
                    <xsl:when test="contains($currElementStyle, 'archaic') and (local-name(ancestor::*[2]) = 'subpart' or local-name(ancestor::*[2]) = 'subtitle' or local-name(ancestor::*[2]) = 'chapter'  or local-name(ancestor::*[2]) = 'subsection'  )">
                        <xsl:text>no</xsl:text>
                    </xsl:when>
                    <xsl:when test="contains($currElementStyle, 'traditional') and (local-name(ancestor::*[2]) = 'division'  or local-name(ancestor::*[2]) = 'subtitle'  or local-name(ancestor::*[2]) = 'subpart' or  local-name(ancestor::*[2]) = 'subchapter'  )">
                        <xsl:text>no</xsl:text>
                    </xsl:when>
                    <xsl:when test="$currElementStyle='traditional' and local-name(ancestor::*[2]) = 'chapter'">
                        <xsl:text>no</xsl:text>
                    </xsl:when>
                    <xsl:when test="$currElementStyle='appropriations' and local-name(ancestor::*[2]) = 'division'">
                        <xsl:text>no</xsl:text>
                    </xsl:when>
                    <xsl:when test="$currElementStyle='tax' and (contains(local-name(ancestor::*[2]), 'division') or contains(local-name(ancestor::*[2]), 'title') or contains(local-name(ancestor::*[2]), 'part') or  contains(local-name(ancestor::*[2]), 'chapter')  or  local-name(ancestor::*[2]) = 'section')">
                        <xsl:text>no</xsl:text>
                    </xsl:when>
                    <xsl:when test="$currElementStyle='nuclear' and (contains(local-name(ancestor::*[2]), 'title') or contains(local-name(ancestor::*[2]), 'part')  or  local-name(ancestor::*[2]) = 'subchapter')">
                        <xsl:text>no</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>yes</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>				
            </xsl:when>
            <xsl:when test="(local-name(ancestor::*[2]) = 'division' or local-name(ancestor::*[2]) = 'title' or local-name(ancestor::*[2]) = 'subchapter') and ($currElementStyle='traditional' or $currElementStyle='archaic' or $currElementStyle='archaic-paragraph')">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(ancestor::*[2]) = 'subchapter' and $currElementStyle='USC'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(ancestor::*[2]) ='title' and $currElementStyle='traditional-inline'">
                <xsl:text>yes</xsl:text>
            </xsl:when>			
            <xsl:when test="(local-name(ancestor::*[2])='paragraph') and contains($currElementStyle,'archaic')">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="target" mode="process">
        <!--BH:  keeping this comment of appreciation to Michael Kay-->
        <!-- thanks Michael Kay for the parent/preceding-sibling solution -->
        <xsl:if test="@bold='on' or (parent::node()/@bold='on' and not (@bold='off'))">
            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
        </xsl:if>
        <xsl:apply-templates mode="process" />      
        <xsl:if test="(local-name(../../following::*[1]) = 'after-quoted-block' ) and ../following-sibling::* and ancestor::quoted-block">        
            <xsl:choose>
                <xsl:when test="string-length(ancestor::quoted-block/after-quoted-block/text()) =1">
                    <para loc="14" />
                    
                </xsl:when>
                <xsl:when test="string-length(ancestor::quoted-block/after-quoted-block/text()) &gt; 1">
                    <para loc="19" />
                 
                </xsl:when>
                <xsl:when test="string-length(ancestor::quoted-block/after-quoted-block/text()) =0">
                    <para loc="09" />
                </xsl:when>
                <xsl:otherwise> </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="level-header" mode="process">
        <xsl:variable name="node" select="." />
        <xsl:if test="not(preceding-sibling::toc-enum)">
            <para loc="11" />
            <xsl:if test="ancestor::quoted-block">
                <xsl:value-of select="gpo:QuotedBlockNestingStart($node)" />
            </xsl:if>
        </xsl:if>
        <xsl:if test="@bold='on' or (ancestor::multi-column-toc-entry/@bold='on'  and not (@bold='off' ))">
            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
        </xsl:if>
        <xsl:apply-templates mode="process" />

        <xsl:variable name="targetData" as="xs:string?">
            <xsl:value-of select="string(../target[1]/text())" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="($targetData='Sec.') and (/bill[@bill-stage='Reported-in-Senate'] or not(parent::multi-column-toc-entry/preceding-sibling::multi-column-toc-entry) and (parent::multi-column-toc-entry/following-sibling::multi-column-toc-entry) )">
                <para loc="07" />
            </xsl:when>
            <!--Issue #115: Suppress output of para because it is moved outside the para in 'multi-column-toc-entry'.-->
            <xsl:when test="ancestor::multi-column-toc-entry" />            
            <xsl:when test="preceding-sibling::toc-enum">
                <para loc="52" />
            </xsl:when>
            <xsl:otherwise>
                <para loc="07" />
            </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="following-sibling:: page-num and (following-sibling:: page-num/@bold='on' or (parent::node()/@bold='on' and not (following-sibling:: page-num/@bold='off')))">			
            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="list" mode="process">
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:variable name="listLocator">
            <xsl:choose>
                <xsl:when test="$m_isCommitteeReport='Yes' and @list-type='numbered' or @list-type='lettered'">20</xsl:when>
                <xsl:otherwise><xsl:call-template name="locatorForListItem" /></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>		
        
        <xsl:variable name="toCloseTheBracket">
            <xsl:call-template name="toCloseTheBrakets" />	
        </xsl:variable>
        
        <xsl:for-each select="list-item">
            
            <xsl:call-template name="KeepParentsFormatOrSelf" />
           
            <para loc="{translate($listLocator, ' ', '')}">
                <xsl:text>  </xsl:text>
                <xsl:if test="(not (@changed='not-changed') and  @vbattChangedForReported='bold-brackets' and not (parent::list/@changed='not-changed')) or (parent::list/@commented='yes') or @commented='yes'">
                     <xsl:text>❨</xsl:text>
                </xsl:if>           
                <xsl:apply-templates mode="process" />
                <xsl:if test="($toCloseTheBracket = 'yes' and (@vbattChangedForReported='bold-brackets'  or parent::list/@commented='yes' ) and not (parent::list/following-sibling::*[1][@vbattChangedForReported='bold-brackets'])) or @commented='yes'">
                     <xsl:text>❩</xsl:text>
                </xsl:if>
            </para>
        </xsl:for-each>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="list[ancestor::quoted-block]" mode="process">
        <xsl:variable name="node" select="." />
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:variable name="listLocator">
            <xsl:call-template name="locatorForListItem" />
        </xsl:variable>
        <xsl:for-each select="list-item">
            <xsl:variable name="after-quoted-block">
                <xsl:choose>
                    <xsl:when test="not(following-sibling::list-item)">
                        <xsl:choose>
                            <xsl:when test="../following-sibling::after-quoted-block[1]">
                                <xsl:text>”</xsl:text><xsl:value-of select="../following-sibling::after-quoted-block" />
                            </xsl:when>
                            <xsl:otherwise />
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise />
                </xsl:choose>
            </xsl:variable>
            <xsl:call-template name="KeepParentsFormatOrSelf" />
            <para loc="{translate($listLocator, ' ', '')}">  
            <xsl:value-of select="gpo:QuotedBlockNestingStart($node)" />
            <xsl:apply-templates mode="process" /><xsl:value-of select="$after-quoted-block" />
            </para>
        </xsl:for-each>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="isNextSiblingBracketed">
        <xsl:choose>
            <xsl:when test="following-sibling::*">
                <xsl:if test="following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:when test="parent::*/following-sibling::*">
                <xsl:if test="parent::*/following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:when test="ancestor::*[2]/following-sibling::*">
                <xsl:if test="ancestor::*[2]/following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:when test="ancestor::*[3]/following-sibling::*">
                <xsl:if test="ancestor::*[3]/following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:when test="ancestor::*[4]/following-sibling::*">
                <xsl:if test="ancestor::*[4]/following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:when test="ancestor::*[5]/following-sibling::*">
                <xsl:if test="ancestor::*[5]/following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:when test="ancestor::*[6]/following-sibling::*">
                <xsl:if test="ancestor::*[6]/following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:when test="ancestor::*[7]/following-sibling::*">
                <xsl:if test="ancestor::*[7]/following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:when test="ancestor::*[8]/following-sibling::*">
                <xsl:if test="ancestor::*[8]/following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:when test="ancestor::*[9]/following-sibling::*">
                <xsl:if test="ancestor::*[9]/following-sibling::*[1]/@vbattChangedForReported='bold-brackets' ">
                    <xsl:text>yes</xsl:text>
                </xsl:if>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="CloseBracketsForListItem">      
        <xsl:variable name="IAmLastInDeletedBlock">
            <xsl:choose>
                <xsl:when test="((parent::list/@changed='deleted'  and  not(parent::list/parent/@changed='deleted' )) or (parent::list/@commented='yes')) and position()=last()">
                    <xsl:text>yes</xsl:text>
                </xsl:when>	
                <xsl:when test="@reported-display-style='bold-brackets' and following-sibling::*[1]/@reported-display-style != 'bold-brackets'">
                    <xsl:text>yes</xsl:text>
                </xsl:when>	
                <xsl:otherwise>
                    <xsl:text>no</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>     
        <xsl:choose>
            <xsl:when test="parent::list/@commented='yes' and $IAmLastInDeletedBlock = 'yes'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="not (@vbattChangedForReported = 'bold-brackets')">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="@changed='not-changed'">
                <xsl:text>no</xsl:text>
            </xsl:when>			
            <xsl:when test="$IAmLastInDeletedBlock = 'yes'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="checkSiblingsRule">		
        <xsl:variable name="toCloseTheSectionLevel">
            <xsl:call-template name="CloseSiblingSectionLevel" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$toCloseTheSectionLevel='yes'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <!-- Appropriations Major following by appropriations any type -->
            <xsl:when test="ancestor::appropriations-major[1][@changed='deleted' and @vbattChangedForReported='bold-brackets' ]                  and (ancestor::appropriations-major[1]/following-sibling::appropriations-major[1][@changed='deleted' and @vbattChangedForReported='bold-brackets']                 or ancestor::appropriations-major[1]/following-sibling::appropriations-intermediate[1][@changed='deleted' and @vbattChangedForReported='bold-brackets']                 or ancestor::appropriations-major[1]/following-sibling::appropriations-small[1][@changed='deleted' and @vbattChangedForReported='bold-brackets'])                 and not (following-sibling::*) and ( (local-name(parent::*/following-sibling::*) = 'appropriations-major'  or  local-name(parent::*/following-sibling::*) = 'appropriations-intermediate'  or local-name(parent::*/following-sibling::*) = 'appropriations-small' ) or not (parent::*/following-sibling::*))">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <!-- Appropriations intermediate following by appropriations any type -->
            <xsl:when test="ancestor::appropriations-intermediate[1][@changed='deleted' and @vbattChangedForReported='bold-brackets' ]                  and (ancestor::appropriations-intermediate[1]/following-sibling::appropriations-major[1][@changed='deleted' and @vbattChangedForReported='bold-brackets']                 or ancestor::appropriations-intermediate[1]/following-sibling::appropriations-intermediate[1][@changed='deleted' and @vbattChangedForReported='bold-brackets']                 or ancestor::appropriations-intermediate[1]/following-sibling::appropriations-small[1][@changed='deleted' and @vbattChangedForReported='bold-brackets'])                 and not (following-sibling::*) and ( (local-name(parent::*/following-sibling::*) = 'appropriations-major'  or  local-name(parent::*/following-sibling::*) = 'appropriations-intermediate'  or local-name(parent::*/following-sibling::*) = 'appropriations-small' ) or not (parent::*/following-sibling::*))">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <!-- Appropriations small following by appropriations any type -->
            <xsl:when test="ancestor::appropriations-small[1][@changed='deleted' and @vbattChangedForReported='bold-brackets' ]                  and (ancestor::appropriations-small[1]/following-sibling::appropriations-major[1][@changed='deleted' and @vbattChangedForReported='bold-brackets']                 or ancestor::appropriations-small[1]/following-sibling::appropriations-intermediate[1][@changed='deleted' and @vbattChangedForReported='bold-brackets']                 or ancestor::appropriations-small[1]/following-sibling::appropriations-small[1][@changed='deleted' and @vbattChangedForReported='bold-brackets'])                 and not (following-sibling::*) and ( (local-name(parent::*/following-sibling::*) = 'appropriations-major'  or  local-name(parent::*/following-sibling::*) = 'appropriations-intermediate'  or local-name(parent::*/following-sibling::*) = 'appropriations-small' ) or not (parent::*/following-sibling::*))">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <!-- Title following by title-->
            <xsl:when test="ancestor::title[1][@changed='deleted' and @vbattChangedForReported='bold-brackets' ] and ancestor::title[1]/following-sibling::title[1][@changed='deleted' and @vbattChangedForReported='bold-brackets'] and not (following-sibling::*) and ( local-name(parent::*/following-sibling::*) = 'title'  or contains(local-name(parent::*/following-sibling::*), 'appropriations') or not (parent::*/following-sibling::*))">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>                     
        </xsl:choose>     
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="isLastInSection">	
        <xsl:choose>	
            <xsl:when test="following-sibling::* and not (local-name(following-sibling::*[1]) = 'after-quoted-block' and not(following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(parent::*) = 'section' or contains (local-name(parent::*), 'appropriations')">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[1]/following-sibling::*   and not (local-name(ancestor::*[1]/following-sibling::*[1]) = 'after-quoted-block' and not(ancestor::*[1]/following-sibling::*[2])) ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(ancestor::*[2]) = 'section' or contains (local-name(ancestor::*[2]), 'appropriations')">
                <xsl:text>true</xsl:text>
            </xsl:when>           
            <xsl:when test="ancestor::*[2]/following-sibling::*   and not (local-name(ancestor::*[2]/following-sibling::*[1]) = 'after-quoted-block' and not(ancestor::*[2]/following-sibling::*[2])) ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(ancestor::*[3]) = 'section' or contains (local-name(ancestor::*[3]), 'appropriations')">
                <xsl:text>true</xsl:text>
            </xsl:when>            
            <xsl:when test="ancestor::*[3]/following-sibling::*   and not (local-name(ancestor::*[3]/following-sibling::*[1]) = 'after-quoted-block' and not(ancestor::*[3]/following-sibling::*[2])) ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(ancestor::*[4]) = 'section' or contains (local-name(ancestor::*[4]), 'appropriations')">
                <xsl:text>true</xsl:text>
            </xsl:when>            
            <xsl:when test="ancestor::*[4]/following-sibling::*   and not (local-name(ancestor::*[4]/following-sibling::*[1]) = 'after-quoted-block' and not(ancestor::*[4]/following-sibling::*[2])) ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(ancestor::*[5]) = 'section' or contains (local-name(ancestor::*[5]), 'appropriations')">
                <xsl:text>true</xsl:text>
            </xsl:when>            
            <xsl:when test="ancestor::*[5]/following-sibling::*   and not (local-name(ancestor::*[5]/following-sibling::*[1]) = 'after-quoted-block' and not(ancestor::*[5]/following-sibling::*[2])) ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(ancestor::*[6]) = 'section' or contains (local-name(ancestor::*[6]), 'appropriations')">
                <xsl:text>true</xsl:text>
            </xsl:when>            
            <xsl:when test="ancestor::*[6]/following-sibling::*   and not (local-name(ancestor::*[6]/following-sibling::*[1]) = 'after-quoted-block' and not(ancestor::*[6]/following-sibling::*[2])) ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(ancestor::*[7]) = 'section' or contains (local-name(ancestor::*[7]), 'appropriations')">
                <xsl:text>true</xsl:text>
            </xsl:when>        
            <xsl:when test="ancestor::*[7]/following-sibling::*   and not (local-name(ancestor::*[7]/following-sibling::*[1]) = 'after-quoted-block' and not(ancestor::*[7]/following-sibling::*[2])) ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="local-name(ancestor::*[8]) = 'section' or contains (local-name(ancestor::*[8]), 'appropriations')">
                <xsl:text>true</xsl:text>
            </xsl:when>        
            <xsl:otherwise>
                <xsl:text>false</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="CloseSiblingSectionLevel">
        <xsl:variable name="selfOrParentDeleted">
            <xsl:choose>
                <xsl:when test="self::*/@vbattChangedForReported = 'bold-brackets' or ancestor::section[1]/@changed='deleted' or (ancestor::title/@changed='deleted' and not(ancestor::section[1]/@changed))">
                    <xsl:text>true</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>false</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="followingOrParentDeleted">
            <xsl:choose>
                <xsl:when test="ancestor::section[1]/following-sibling::section[1]/@changed='deleted' or (ancestor::title/@changed='deleted' and not(ancestor::sectioon[1]/following-sibling::section/@changed))">
                    <xsl:text>true</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>false</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="lastInSection">
            <xsl:call-template name="isLastInSection" />
        </xsl:variable>
        
        <xsl:choose>
            <xsl:when test="local-name(following-sibling::*[1]) = 'after-quoted-block' or (not(following-sibling::*) and local-name(parent::*/following-sibling::*[1]) = 'after-quoted-block')">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:when test="$selfOrParentDeleted='true'  and (ancestor::section[1]/@vbattChangedForReported='bold-brackets'  or self::*/@vbattChangedForReported='bold-brackets' )  and not (following-sibling::*) and ( $lastInSection='true')">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>       
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="processing-instruction('LEXA-Enum')" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="processing-instruction('xm-replace_text')" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="after-quoted-block" mode="process">
        <!--BH:  Removing the logic for this element because the closing character need to be in included in the <text> element.-->
      <!--  <xsl:variable name="previousElementName">
            <xsl:value-of select="local-name(../*[position()=(count(../*)-1)])"/>
        </xsl:variable>
        <xsl:variable name="pos">
            <xsl:value-of select="count(preceding-sibling::*[1]/*)"/>
        </xsl:variable>
        <xsl:variable name="previousSubElementName">
            <xsl:value-of select="local-name(preceding-sibling::*[1]/*[position()=$pos])"/>
        </xsl:variable>
        <xsl:variable name="previousSubSubElementName">
            <xsl:value-of
                select="local-name(preceding-sibling::*[1]/child::*[position()=last()]/child::*[position()=last()])"
            />
        </xsl:variable>
        <xsl:variable name="testName">
            <xsl:choose>
                <xsl:when test="$previousElementName='toc-entry' or $previousElementName='toc'">
                    <xsl:text>toc</xsl:text>
                </xsl:when>
                <xsl:when
                    test="$previousSubElementName='toc-entry' or $previousSubElementName='toc'">
                    <xsl:text>toc</xsl:text>
                </xsl:when>
                <xsl:when
                    test="$previousSubSubElementName='toc-entry' or $previousSubSubElementName='toc'">
                    <xsl:text>toc</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>other</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:if
            test="not(string-length(local-name(following::*[1]))=0 and local-name(preceding::*[1])='entry')">
            <xsl:if test="string-length(normalize-space(.)) &gt; 0 and not( $testName='toc')">
                <xsl:call-template name="QuotedBlockNestingEnd"/>				
                <xsl:if test="not($previousElementName='table')">
                    <xsl:apply-templates mode="process"/>
                </xsl:if>
                <xsl:call-template name="addClosingCharacterForChildElements">
                    <xsl:with-param name="source"><xsl:text>afterQuotedBlock</xsl:text></xsl:with-param>
                </xsl:call-template>
            </xsl:if>
            <xsl:if test="string-length(normalize-space(.)) = 0 and not($testName='toc')">
                <xsl:call-template name="QuotedBlockNestingEnd"/>	
                <!-\- TB 3May2010  bug fixing #1115-\->
                <xsl:call-template name="addClosingCharacterForChildElements">
                    <xsl:with-param name="source"><xsl:text>afterQuotedBlock</xsl:text></xsl:with-param>
                </xsl:call-template>
            </xsl:if>
            <xsl:if
                test="($previousElementName='table'  or $previousElementName='toc' ) and child::pagebreak">
                <xsl:apply-templates select="pagebreak"/>
            </xsl:if>
        </xsl:if>
        <xsl:variable name="nbJunk1">
            <xsl:value-of select="name(preceding::*[1])"/>
        </xsl:variable>
        <xsl:if test="preceding-sibling::*[1]/@commented='yes' or preceding::text[1]/../@commented='yes'  ">
            <xsl:text disable-output-escaping="yes">&lt;ASC20&gt;</xsl:text>
        </xsl:if>

        <xsl:if
            test="not(string-length(local-name(following::*[1]))=0 and local-name(preceding::*[1])='entry')">
            <xsl:if test="string-length(normalize-space(.)) &gt; 0 and not( $testName='toc')">
                <xsl:choose>
                    <xsl:when
                        test="contains($billstage,'Reported') or contains(//resolution/@resolution-stage,'Reported') and ancestor::legis-body/@changed">
                        <xsl:variable name="currentFormat">
                            <xsl:call-template name="LegisBodyWithChangedAttribute"/>
                        </xsl:variable>
                        <xsl:value-of select="$currentFormat"/>
                    </xsl:when>
                </xsl:choose>
            </xsl:if>
        </xsl:if>     -->
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quoted-block-continuation-text[@commented='yes']" mode="process">
        <xsl:variable name="node" select="." />
        <!--BH:  These are required for the function but were not defined in the template-->
        <xsl:variable name="sectionStyleOverlapped">false</xsl:variable>
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:variable name="style">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>
        <xsl:variable name="levelLocator">
            <xsl:call-template name="locatorForQBContText">
                <xsl:with-param name="style" select="$style" />
            </xsl:call-template>
        </xsl:variable>
        <para>
            <xsl:attribute name="loc">
        <xsl:value-of select="$levelLocator" />
            </xsl:attribute>❨<xsl:apply-templates mode="process" />❩</para>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quoted-block-continuation-text" mode="process">
        <xsl:variable name="node" select="." />
        <!--BH:  These are required for the function but were not defined in the template-->
        <xsl:variable name="sectionStyleOverlapped">false</xsl:variable>
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:variable name="style">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
            <!--<xsl:call-template name="GetNearestAncestorStyleRecursive"/>-->
        </xsl:variable>
        <xsl:variable name="levelLocator">
            <xsl:call-template name="locatorForQBContText">
                <xsl:with-param name="style" select="$style" />
            </xsl:call-template>
        </xsl:variable>	
        <para>
            <xsl:attribute name="loc"><xsl:value-of select="$levelLocator" /></xsl:attribute>
            
        <!-- fixes issue #305 -->
        <!-- the LXL code was just testing if there was not a preceding-sibling of type node(). That was failing in the
            case where there is a whitespace node (such as a carriage return). Since we know that there can not be any significant
            text in a quoted-block, we can allow the case where a preceding-sibling is text(). -->
        <xsl:if test="not(preceding-sibling::node()) or preceding-sibling::text()">
              <xsl:value-of select="gpo:QuotedBlockNestingStart($node)" />
        </xsl:if>
            <xsl:apply-templates mode="process" />
            <!-- fixes issue #305 -->
            <!-- -->
            <xsl:if test="local-name(following::*[1]) = 'after-quoted-block'">
                <xsl:if test="not(following::after-quoted-block/@display = 'no')">
                    <xsl:call-template name="QuotedBlockNestingEnd" />
                    
                    <xsl:value-of select="following::*[1]" />
                    
                    <xsl:call-template name="addClosingCharacterForChildElements">
                        <xsl:with-param name="source">
                            <xsl:text>afterQuotedBlock</xsl:text>
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:if>
            </xsl:if>
        </para>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="instruction-subparagraph[ancestor::amendment-instruction]" mode="process">
        <xsl:variable name="node" select="." />
        <!--BH:  These are required for the function but were not defined in the template-->
        <xsl:variable name="sectionStyleOverlapped">false</xsl:variable>
        <xsl:variable name="noDot">no</xsl:variable>
        <xsl:variable name="style">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
           <!-- <xsl:call-template name="GetNearestAncestorStyleRecursive"/>-->
        </xsl:variable>
        <xsl:variable name="levelLocator">
            <xsl:call-template name="calculateLocator">
                <xsl:with-param name="level">
                    <xsl:text>subparagraph</xsl:text>
                </xsl:with-param>				
            </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="$levelLocator" />
        <xsl:if test="./enum">
            <xsl:apply-templates select="./enum" mode="go" />
            <xsl:if test="(./header or ./text) and not(string(./enum)='')">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:if>
        <xsl:if test="./header">
            <xsl:choose>
                <xsl:when test="contains($levelLocator,'I20')  or contains(substring-before(.,' '),'&amp;') ">
                    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                </xsl:otherwise>
            </xsl:choose>			
            <xsl:apply-templates select="header" mode="Special">
                <xsl:with-param name="level" select="$levelLocator" />
            </xsl:apply-templates>
            <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            <xsl:value-of select="gpo:getmdash($style, $noDot)" />
        </xsl:if>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="title-amends" mode="process">
        <xsl:if test="(/amendment-doc/@amend-type='senate-amendment') or (count(preceding-sibling::amendment-body) &gt; 0)  and (not( ./official-title-amendment))     ">
            <xsl:call-template name="pagebreak" />
        </xsl:if>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="preamble-amends" mode="process">		
        <xsl:if test="preceding-sibling::amendment-body">
            <xsl:call-template name="pagebreak" />
        </xsl:if>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:function xmlns:dc="http://purl.org/dc/elements/1.1" name="gpo:actualPutLocatorWithIndent" as="xs:integer">
        <xsl:param name="node" as="node()" />
        <xsl:param name="pageBreakMode" as="xs:string?" />
        <xsl:param name="level" as="xs:string?" />
        <xsl:choose>	
            <xsl:when test="$node/@indent='subsection'">
                <xsl:sequence select="20" />
            </xsl:when>
            <xsl:when test="$node/@indent='paragraph'">
                <xsl:sequence select="22" />
            </xsl:when>
            <xsl:when test="$node/@indent='subparagraph'">
                <xsl:sequence select="24" />
            </xsl:when>
            <xsl:when test="$node/@indent='clause'">
                <xsl:sequence select="26" />
            </xsl:when>
            <xsl:when test="$node/@indent='subclause'">
                <xsl:sequence select="28" />
            </xsl:when>
            <xsl:when test="$node/@indent='item'">
                <xsl:sequence select="30" />
            </xsl:when>
            <xsl:when test="$node/@indent='subitem'">
                <xsl:sequence select="31" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="indent">
                    <xsl:choose>
                        <xsl:when test="$pageBreakMode='yes'">
                            <xsl:value-of select="$node/ancestor::*[2]/@indent" />
                        </xsl:when>
                        <xsl:otherwise>	
                            <xsl:variable name="pnode" select="$node/parent::node()" />
                            <xsl:variable name="level" select="$level" />
                            <xsl:value-of select="gpo:GetIndent($pnode, $level)" />					
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                
                <xsl:choose>
                    <xsl:when test="$level = 'subitem'">
                        <xsl:variable name="default">31</xsl:variable>
                        <xsl:variable name="down">31</xsl:variable>
                        <xsl:variable name="up">30</xsl:variable>
                        <xsl:variable name="indent-string" select="$indent" />
                        <xsl:sequence select="gpo:GetIndentValue($default, $down, $up, $indent-string)" />
                    </xsl:when>
                    <xsl:when test="$level = 'item'">
                        <xsl:variable name="default">31</xsl:variable>
                        <xsl:variable name="down">31</xsl:variable>
                        <xsl:variable name="up">28</xsl:variable>
                        <xsl:variable name="indent-string" select="$indent" />
                        <xsl:sequence select="gpo:GetIndentValue($default, $down, $up, $indent-string)" />
                    </xsl:when>
                    <xsl:when test="$level = 'subclause'">
                        <xsl:variable name="default">28</xsl:variable>
                        <xsl:variable name="down">30</xsl:variable>
                        <xsl:variable name="up">26</xsl:variable>
                        <xsl:variable name="indent-string" select="$indent" />
                        <xsl:sequence select="gpo:GetIndentValue($default, $down, $up, $indent-string)" />
                    </xsl:when>
                    <xsl:when test="$level = 'clause'">
                        <xsl:variable name="default">26</xsl:variable>
                        <xsl:variable name="down">28</xsl:variable>
                        <xsl:variable name="up">24</xsl:variable>
                        <xsl:variable name="indent-string" select="$indent" />
                        <xsl:sequence select="gpo:GetIndentValue($default, $down, $up, $indent-string)" />
                    </xsl:when>
                    <xsl:when test="$level = 'subparagraph'">
                        <xsl:variable name="default">24</xsl:variable>
                        <xsl:variable name="down">26</xsl:variable>
                        <xsl:variable name="up">22</xsl:variable>
                        <xsl:variable name="indent-string" select="$indent" />
                        <xsl:sequence select="gpo:GetIndentValue($default, $down, $up, $indent-string)" />
                    </xsl:when>
                    <xsl:when test="$level = 'paragraph'">
                        <xsl:variable name="default">22</xsl:variable>
                        <xsl:variable name="down">24</xsl:variable>
                        <xsl:variable name="up">20</xsl:variable>
                        <xsl:variable name="indent-string" select="$indent" />
                        <xsl:sequence select="gpo:GetIndentValue($default, $down, $up, $indent-string)" />
                    </xsl:when>
                    <xsl:when test="$level = 'subsection' or $level = 'section'">
                        <xsl:variable name="default">20</xsl:variable>
                        <xsl:variable name="down">22</xsl:variable>
                        <xsl:variable name="up">20</xsl:variable>
                        <xsl:variable name="indent-string" select="$indent" />
                        <xsl:sequence select="gpo:GetIndentValue($default, $down, $up, $indent-string)" />
                    </xsl:when>
                    <xsl:when test="$level='whereas'">
                        <xsl:sequence select="29" />
                    </xsl:when>
                    <xsl:when test="$level='whereasPlus'">
                        <xsl:sequence select="27" />
                    </xsl:when>
                    <xsl:when test="$level = 'committee-report-para'">
                        <xsl:sequence select="21" />
                    </xsl:when>
                    <xsl:when test="contains($level, 'appropriations')">
                        <xsl:sequence select="20" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:sequence select="20" />
                    </xsl:otherwise>
                </xsl:choose>          
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="callOutAfternewPageOnConfReportDraft">
        <xsl:variable name="style">
            <xsl:value-of select="//amendment-doc/@style" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="not (//amendment-doc/@amend-type='conference-report')">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="not ($style='appropriations') ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="not(//conference-report-form/@conference-report-style='draft')">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="not(local-name() = 'amendment-instruction')">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="not(ancestor-or-self::*/preceding::amendment-block)">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="preceding::amendment-instruction =  ancestor::*/preceding::amendment-block/following::amendment-instruction ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>true</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="newPageOnConfReportDraft">
        <xsl:variable name="style">
            <xsl:value-of select="//amendment-doc/@style" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="not (//amendment-doc/@amend-type='conference-report')">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="not ($style='appropriations') ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="not(//conference-report-form/@conference-report-style='draft')">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="not(ancestor-or-self::amendment-block)">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor-or-self::*/preceding::amendment-block">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="not(local-name()='amendment-block') and preceding-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="local-name()='amendment-block' and preceding-sibling::amendment-block">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>true</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="legis-comment" mode="process">
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:variable name="levelLocator">
            <xsl:call-template name="calculateLocator">
                <xsl:with-param name="level">
                    <xsl:text>subsection</xsl:text>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="$levelLocator" />
        <xsl:text>❨</xsl:text>
        <xsl:apply-templates mode="process" />
        <xsl:text>❩</xsl:text>		
 	       
        <xsl:if test="not(parent::text) and footnote">			
            <xsl:for-each select="footnote">
                <xsl:apply-templates select="self::*" mode="process">
                    <xsl:with-param name="forceFootnote">yes</xsl:with-param>
                </xsl:apply-templates>
            </xsl:for-each>
        </xsl:if>
        <xsl:call-template name="GetParentsFormat" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="distribution-code" mode="process">
        <xsl:choose>
        <xsl:when test="not(@display='no') and text() and not(contains($docstage, 'Enrolled'))">
            <para loc="60"><xsl:value-of select="." /></para>
      </xsl:when>
        <xsl:otherwise /> 
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="conversion-notes|holc-attorney|holc-contact|holc-contact-phone|holc-creation-date|holc-creator|holc-filename|holc-last-author|holc-last-saved" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="inline-comment" mode="process">❨<xsl:apply-templates mode="process" />❩</xsl:template><xsl:function xmlns:dc="http://purl.org/dc/elements/1.1" name="gpo:isContainsNumbers" as="xs:string">
        <xsl:param name="aInputText" as="xs:string" />
       
        <xsl:choose>
            <xsl:when test="translate($aInputText,$xsltsl-str-digits, 'xxxxxx') = $aInputText">
                <xsl:text>No</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>Yes</xsl:text>
            </xsl:otherwise>
        </xsl:choose>		
    </xsl:function><xsl:function xmlns:dc="http://purl.org/dc/elements/1.1" name="gpo:isStandAloneNumber">
        <xsl:param name="aInputText" />     
        <xsl:choose>
            <xsl:when test="translate($aInputText,$xsltsl-str-digits, 'a') = 'a'">
                <xsl:text>Yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>No</xsl:text>
            </xsl:otherwise>
        </xsl:choose>		
    </xsl:function><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="numbersUpForAppropriationHeader">
        <xsl:param name="inputText" />	
        <xsl:variable name="textContainsNumbers">
            <xsl:value-of select="gpo:isContainsNumbers($inputText)" />
        </xsl:variable>	
        <xsl:choose>
            <xsl:when test="$textContainsNumbers='Yes'">
                <!--Take first letter of the string-->	
                <xsl:variable name="tempFirstPartString">
                    <xsl:choose>
                        <xsl:when test="contains(normalize-space($inputText), ' ')">
                            <xsl:value-of select="substring-before(normalize-space($inputText),' ')" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="normalize-space($inputText)" />
                        </xsl:otherwise>
                    </xsl:choose>	
                </xsl:variable>
                <xsl:variable name="firstPartContainsNumber">
                    <xsl:value-of select="gpo:isContainsNumbers($tempFirstPartString)" />
                </xsl:variable>
                <xsl:variable name="firstPartNumberOnly">
                    <xsl:value-of select="gpo:isStandAloneNumber($tempFirstPartString)" />
                </xsl:variable>	
                <xsl:variable name="firstPartString">
                    <xsl:choose>
                        <xsl:when test="$firstPartContainsNumber='Yes' and $firstPartNumberOnly = 'Yes' ">
                            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction> 
                            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="concat($tempFirstPartString, ' ')" />
                        </xsl:otherwise>
                    </xsl:choose>					
                </xsl:variable>
                <xsl:variable name="lastPartString">
                    <xsl:value-of select="substring-after($inputText, $tempFirstPartString)" />
                </xsl:variable>				              
                <!--generate the reast of the string recursively-->
                <xsl:variable name="generatedString">
                    <xsl:call-template name="numbersUpForAppropriationHeader">
                        <xsl:with-param name="inputText" select="$lastPartString" />
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="concat ($firstPartString, $generatedString)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$inputText" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="fraction" mode="process">
      <xsl:variable name="enumerator">
            <xsl:choose>
                <xsl:when test="contains(., '/')"><xsl:value-of select="substring-before(., '/')" /></xsl:when>
                <xsl:when test="contains(., '⁄')"><xsl:value-of select="substring-before(., '⁄')" /></xsl:when>
                <xsl:otherwise />
            </xsl:choose>
            </xsl:variable>
        <xsl:variable name="denominator"> <xsl:choose>
            <xsl:when test="contains(., '/')"><xsl:value-of select="substring-after(., '/')" /></xsl:when>
            <xsl:when test="contains(., '⁄')"><xsl:value-of select="substring-after(., '⁄')" /></xsl:when>
            <xsl:otherwise />
        </xsl:choose></xsl:variable>
        <xsl:processing-instruction name="xpp">
            <xsl:choose>
                <xsl:when test=". = '½'">frax;1;2</xsl:when>
                <xsl:otherwise><xsl:value-of select="concat('frax;', $enumerator, ';', $denominator)" /></xsl:otherwise>
            </xsl:choose>
            </xsl:processing-instruction>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="bold" mode="process">
        <xsl:choose>
            <xsl:when test="parent::text">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>               
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header and local-name(../..)='section'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::header and (local-name(../..)='subsection' or local-name(../..)='paragraph' or local-name(../..)='subparagraph' or local-name(../..)='clause' or local-name(../..)='subclause' or local-name(../..)='item' or local-name(../..)='subitem')">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
               <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::deleted-phrase">
                <xsl:processing-instruction name="xpp">ff;23</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                <xsl:apply-templates mode="process" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="parent::italic">
                <xsl:choose>
                    <xsl:when test="../parent::header and local-name(../../..)='section'">
                        <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        <xsl:apply-templates mode="process" />
                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="../parent::header and (local-name(../../..)='subsection' or local-name(../../..)='paragraph' or local-name(../../..)='subparagraph' or local-name(../../..)='clause' or local-name(../../..)='subclause' or local-name(../../..)='item' or local-name(../../..)='subitem')">
                        <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        <xsl:apply-templates mode="process" />
                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:otherwise><xsl:apply-templates mode="process" /></xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise><xsl:apply-templates mode="process" /></xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="action-instruction" exclude-result-prefixes="#all" mode="process">
        <xsl:if test="not(@display='no')">
            <para loc="78">[<xsl:apply-templates mode="process" />]</para>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="official-title-amendment" exclude-result-prefixes="#all" mode="process">
        <xsl:variable name="node" select="." />
        <xsl:choose>
            <xsl:when test="//bill[@bill-stage='Enrolled-Bill'] " exclude-result-prefixes="#all">
                <para format="6501" loc="20">  <xsl:apply-templates mode="process" /></para>
            </xsl:when>           
            <xsl:when test="child::pagebreak[1]">
                    <para format="6201" />
                <xsl:for-each select="node()">
                    <xsl:apply-templates select="." mode="process" />
                    <xsl:if test="local-name(.)='pagebreak'">
                        <para loc="12">  </para>
                    </xsl:if>
                </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="conferenceReportStyle"> 
                    <xsl:value-of select="gpo:GetConferenceReportStyle($node)" />
                </xsl:variable>
                <para>
                <xsl:choose>               
                    <xsl:when test="/amendment-doc[@amend-type='conference-report']">                     
                      <xsl:choose>
                          <xsl:when test="$conferenceReportStyle='draft'">
                              <xsl:attribute name="format">6201</xsl:attribute>
                            </xsl:when>       
                            <xsl:when test="$conferenceReportStyle='bill'">
                                <xsl:attribute name="format">6203</xsl:attribute>
                            </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="format">6201</xsl:attribute>
                            </xsl:otherwise> 
                        </xsl:choose>
                        <xsl:attribute name="loc">20</xsl:attribute>
                        <xsl:text>  </xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:attribute name="format">6201</xsl:attribute>
                        <xsl:attribute name="loc">12</xsl:attribute>
                        <xsl:text>  </xsl:text>                   
                    </xsl:otherwise>
                </xsl:choose>
               <xsl:apply-templates mode="process" />
                </para>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="meta-house" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="meta-senate" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="slc-for" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="slc-for-office|slc-for-sponsor|slc-for-staffer" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="slc-subject" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="slc-subject-field1 |         slc-subject-field2 |          slc-subject-field3 |          slc-subject-field4 |          slc-subject-field5 |          slc-subject-field6 |          slc-subject-field7 |          slc-subject-field8 |          slc-subject-field9" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="slc-type" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="slc-description" mode="process">
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="slc-received" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="slc-delivered | slc-staff | slc-reviewed-by" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="committee-name" mode="process">
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="getOpenAndCloseCode">
        <xsl:param name="aMode" />		
        <xsl:param name="isNumbersIncluded" />
        <xsl:choose>
            <xsl:when test="$aMode='2conf'">
                <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
            </xsl:when>
            <xsl:when test="$aMode='2comm'">
                <xsl:processing-instruction name="xpp">ff;711</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <!--The  original looks like it might be an error
                    <xsl:text>&lt;BEL&gt;g711=</xsl:text>-->
            </xsl:when>
            <xsl:when test="$aMode='1' or $aMode='8'  or $aMode='3' or $aMode='9' or $aMode='13'">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aMode='101' or $aMode='801' or $aMode='301'  or $aMode='901' or $aMode='1301'">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
            </xsl:when>	
            <xsl:when test="$aMode='101i' or $aMode = '301i' or $aMode='801i' or $aMode='901i' ">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>	
            <xsl:when test="$aMode='501i'">
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aMode='101b'  or $aMode = '301b' or $aMode='801b' or $aMode='901b' or $aMode='501b' or $aMode='1301b'">
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aMode='5' or $aMode='10'">
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aMode='10b'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aMode='10n'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aMode='1001b'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>			
            </xsl:when>
            <xsl:when test="$aMode='1001r'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>			
            </xsl:when>
            <xsl:when test="$aMode='501' or $aMode='1001' ">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>	
            </xsl:when>			
            <xsl:when test="($aMode='12' or  $aMode='11' ) and $isNumbersIncluded='yes'">
                <!-- TB 22Jun2012 bug fixing #1260 -->
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;#</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>	
                <!--This may be wrong.  The T# doesn't look right.
                    <xsl:text>&lt;BEL&gt;G3&lt;BEL&gt;T#=&lt;BEL&gt;G3&lt;BEL&gt;T1</xsl:text>-->
            </xsl:when>
            <xsl:when test="$aMode='6' or $aMode='12' or $aMode='11'">
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$aMode='1101ram' or $aMode='601ram'">
                <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="($aMode='1201' or  $aMode='1101' ) and $isNumbersIncluded='yes'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;#</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                <!--<xsl:text>&lt;BEL&gt;G2&lt;BEL&gt;T#=&lt;BEL&gt;G1&lt;BEL&gt;T3</xsl:text>-->
            </xsl:when>
            <xsl:when test="$aMode='601' or $aMode='1201' or $aMode='1101'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>	
            <xsl:when test="$aMode='601i' or $aMode='1201i' or $aMode='1101i'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>	
            <xsl:when test="$aMode='601b' or $aMode='1201b' or $aMode='1101b'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:text>=</xsl:text>
                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>	
            <xsl:otherwise />       
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="defineModeForInlineHeader">
		<xsl:param name="aStyle" />
		<xsl:variable name="isInAddedPhrase">
			<xsl:choose>
				<xsl:when test="parent::added-phrase or (parent::quote and local-name(ancestor::*[2]) = 'added-phrase') or (parent::inline-comment  and local-name(ancestor::*[2]) = 'added-phrase')">
					<xsl:text>Y</xsl:text>
				</xsl:when>				
				<xsl:otherwise>
					<xsl:text>N</xsl:text>
				</xsl:otherwise>
			</xsl:choose>	
		</xsl:variable>
		<xsl:variable name="isInDeletedPhrase">
			<xsl:choose>
				<xsl:when test="parent::deleted-phrase or (parent::quote and local-name(ancestor::*[2]) = 'deleted-phrase') or (parent::inline-comment and local-name(ancestor::*[2]) = 'deleted-phrase')">
					<xsl:text>Y</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>N</xsl:text>
				</xsl:otherwise>
			</xsl:choose>	
		</xsl:variable>
		<xsl:variable name="isInRamseyer">
			<xsl:call-template name="isRamseyerCordon" />
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="($isInDeletedPhrase='Y' and (@level = 'division' or @level ='subdivision' or @level ='title'))       and ($aStyle='USC' or $aStyle='OLC' or $aStyle='tax' or $aStyle='nuclear')">
				<xsl:choose>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>1n</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='boldface-roman'">
						<xsl:text>1b</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='boldface-italic'">
						<xsl:text>1i</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>1</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>				
			</xsl:when>
			<xsl:when test=" ($isInAddedPhrase='Y' and (@level = 'division' or @level ='subdivision' or @level ='title'))       and ($aStyle='USC' or $aStyle='OLC' or $aStyle='tax' or $aStyle='nuclear')">
				<xsl:choose>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>101n</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='boldface-roman'">
						<xsl:text>101b</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='boldface-italic'">
						<xsl:text>101i</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>101</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>			
			</xsl:when>
			<!-- TB July232012 confer3ence report problem -->
			<xsl:when test=" $aStyle='OLC'  and (@level = 'part' or @level = 'section' or not(@level)) and  //amendment-doc[@amend-type='conference-report'] and not (//conference-report-form/@conference-report-style='draft') and not (//conference-report-form/@conference-report-style='bill')">
				<!-- TB Aug 2011 Bug# 1267 -->
				<xsl:text>2conf</xsl:text>
			</xsl:when>
			<xsl:when test=" $aStyle='OLC'  and (@level = 'part'  or @level = 'section' or not(@level)) and ancestor::amendment-block and ancestor::committee-report">
				<!-- TB Aug 2011 Bug# 1217 -->
				<xsl:text>2comm</xsl:text>
			</xsl:when>
			<xsl:when test="(($isInDeletedPhrase='Y' and @level = 'division' )      and ($aStyle='traditional' or contains($aStyle, 'archaic')))     or(($isInDeletedPhrase='Y' and @level = 'title' )       and (contains($aStyle,'traditional') or $aStyle='appropriations'  or contains($aStyle, 'archaic')))     or(($isInDeletedPhrase='Y' and @level = 'chapter' )      and ($aStyle='traditional-inline' or $aStyle='appropriations' or $aStyle='nuclear'))     or(($isInDeletedPhrase='Y' and @level = 'subchapter' )      and ($aStyle='traditional'  or $aStyle='USC' or contains($aStyle, 'archaic')))">
				<xsl:choose>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>2n</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='boldface-roman'">
						<xsl:text>2b</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='boldface-italic'">
						<xsl:text>2i</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>2</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>				
			</xsl:when>
			<xsl:when test="(($isInAddedPhrase='Y' and @level = 'division' )      and ($aStyle='traditional'  or contains($aStyle, 'archaic')))     or(($isInAddedPhrase='Y' and @level = 'title' )       and (contains($aStyle,'traditional') or $aStyle='appropriations' or contains($aStyle, 'archaic')))     or(($isInAddedPhrase='Y' and @level = 'chapter' )      and ($aStyle='traditional-inline' or $aStyle='appropriations' or $aStyle='nuclear'))     or(($isInAddedPhrase='Y' and @level = 'subchapter' )      and ($aStyle='traditional'  or $aStyle='USC' or contains($aStyle, 'archaic')))">
				<xsl:choose>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>201r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>201b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>201r</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>201</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
				
			</xsl:when>
			<xsl:when test="( ($isInDeletedPhrase='Y' and @level = 'subtitle'))       and ($aStyle='USC' or $aStyle='OLC' or $aStyle='tax'  or $aStyle='nuclear')">
				<xsl:choose>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>3r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>3i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>3b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>3</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>				
			</xsl:when>
			<xsl:when test="( ($isInAddedPhrase='Y' and @level = 'subtitle'))       and ($aStyle='USC' or $aStyle='OLC' or $aStyle='tax'  or $aStyle='nuclear')">
				<xsl:choose>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>301r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>301i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>301b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>301</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>				
			</xsl:when>
			<xsl:when test="(($isInDeletedPhrase='Y' and @level = 'subpart' )       and ($aStyle='OLC' or $aStyle='USC' or $aStyle='tax'  or $aStyle='nuclear'))">
				<xsl:choose>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>3r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>3i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>3b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>3</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(($isInAddedPhrase='Y' and @level = 'subpart' )       and ($aStyle='OLC' or $aStyle='USC' or $aStyle='tax'  or $aStyle='nuclear'))">
				<xsl:choose>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>301r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>301i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>301b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>301</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>		
			</xsl:when>
			<xsl:when test="(($isInDeletedPhrase='Y' and (@level = 'subtitle' or @level ='subpart')      and (contains($aStyle,'traditional') or $aStyle='appropriations' or contains($aStyle, 'archaic'))))     or (($isInDeletedPhrase='Y' and @level = 'subdivision')           and ($aStyle='traditional' or contains($aStyle, 'archaic')))     or (($isInDeletedPhrase='Y' and @level ='subchapter')  and ($aStyle='traditional-inline' or $aStyle='appropriations'))     or (($isInDeletedPhrase='Y' and @level ='subsection')  and contains($aStyle, 'archaic'))">
				<xsl:choose>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>4r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>4i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>4b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>4</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(($isInAddedPhrase='Y' and (@level = 'subtitle' or @level ='subpart')      and (contains($aStyle,'traditional') or $aStyle='appropriations' or contains($aStyle, 'archaic'))))     or (($isInAddedPhrase='Y' and @level = 'subdivision')           and ($aStyle='traditional' or contains($aStyle, 'archaic')))     or (($isInAddedPhrase='Y' and @level ='subchapter')  and ($aStyle='traditional-inline'  or $aStyle='appropriations'))     or (($isInAddedPhrase='Y' and @level ='subsection')  and contains($aStyle, 'archaic'))">
				<xsl:choose>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>401r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>401i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>401b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>401</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="($isInDeletedPhrase='Y' and @level = 'part' )           and ($aStyle='OLC' or $aStyle='USC' or $aStyle='tax'  or $aStyle='nuclear')">
				<xsl:choose>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>5r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>5i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>5b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>5</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="($isInAddedPhrase='Y' and @level = 'part' )           and ($aStyle='OLC' or $aStyle='USC' or $aStyle='tax'  or $aStyle='nuclear')">
				<xsl:choose>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>501r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>501i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>501b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>501</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(($isInDeletedPhrase='Y' and @level = 'part' )          and (contains($aStyle,'traditional') or $aStyle='appropriations' or contains($aStyle, 'archaic')))     or (($isInDeletedPhrase='Y' and (@level = 'section' or not(@level)))       and ($aStyle = 'traditional-inline'  or $aStyle='nuclear'))     or (($isInDeletedPhrase='Y' and (@level = 'subsection'  or @level='appropriations-intermediate'))          and not(contains($aStyle, 'archaic')))">
				<xsl:choose>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>6r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>6i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>6b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>6</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(($isInAddedPhrase='Y' and @level = 'part' )          and (contains($aStyle,'traditional') or $aStyle='appropriations' or contains($aStyle, 'archaic')))     or (($isInAddedPhrase='Y' and  (@level = 'section' or not(@level)))       and ($aStyle='traditional-inline' or $aStyle='nuclear'))     or (($isInAddedPhrase='Y' and (@level = 'subsection'  or @level='appropriations-intermediate'))          and not(contains($aStyle, 'archaic')))">
				<xsl:choose>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>601r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>601i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>601b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'italic') and $isInRamseyer='yes'">
						<xsl:text>601ram</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>601</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>				
			</xsl:when>
			<xsl:when test="(($isInDeletedPhrase='Y' and @level = 'chapter' )           and (contains($aStyle, 'archaic') or $aStyle='traditional'or $aStyle='tax'  or $aStyle='USC' or $aStyle='OLC'))     or (($isInDeletedPhrase='Y' and @level  = 'division' )           and ($aStyle='traditional-inline' or $aStyle='appropriations'))">
				<xsl:choose>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>8r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>8i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>8b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>8</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(($isInAddedPhrase='Y' and @level = 'chapter' )           and (contains($aStyle, 'archaic') or $aStyle='traditional' or $aStyle='tax'  or $aStyle='USC' or $aStyle='OLC'))     or (($isInAddedPhrase='Y' and @level  = 'division' )           and ($aStyle='traditional-inline' or $aStyle='appropriations'))">
				<xsl:choose>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>801r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>801i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>801b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>801</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(($isInDeletedPhrase='Y' and @level = 'subchapter' )           and ($aStyle='tax'  or $aStyle='nuclear' or $aStyle='OLC'))     or (($isInDeletedPhrase='Y' and @level = 'subdivision' )      and ($aStyle='traditional-inline' or $aStyle='appropriations'))">
				<xsl:choose>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>9r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>9i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>9b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>9</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(($isInAddedPhrase='Y' and @level = 'subchapter' )           and ($aStyle='tax'  or $aStyle='nuclear' or $aStyle='OLC'))     or (($isInAddedPhrase='Y' and @level = 'subdivision' )      and ($aStyle='traditional-inline' or $aStyle='appropriations'))">
				<xsl:choose>
					<xsl:when test="ancestor::added-phrase[1]/@reported-display-style ='bold-brackets'">
						<xsl:text>901r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>901i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>901b</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>901</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="($isInDeletedPhrase='Y' and  (@level = 'section' or not(@level)) )           and ($aStyle='tax' or $aStyle='OLC')">
				<xsl:choose>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>10b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>10i</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style='bold-brackets'">
						<xsl:text>10n</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>10</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>				
			</xsl:when>
			<xsl:when test="($isInAddedPhrase='Y' and  (@level = 'section'  or not(@level)) )           and ($aStyle='tax' or $aStyle='OLC')">
				<xsl:choose>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'bold-brackets')">
						<xsl:text>1001n</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>1001b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>1001r</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>1001</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="(($isInDeletedPhrase='Y' and  (@level = 'section' or not(@level)) )           and (contains($aStyle, 'archaic') or $aStyle = 'traditional' or $aStyle='appropriations') )     or (($isInDeletedPhrase='Y' and @level='paragraph') and $aStyle='archaic-paragraph') or ($isInDeletedPhrase='Y' and @level='appropriations-small') ">
				<xsl:choose>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>11b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>11i</xsl:text>
					</xsl:when>
					<xsl:when test="ancestor::deleted-phrase[1]/@reported-display-style='bold-brackets'">
						<xsl:text>11n</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>11</xsl:text>
						<!--TB have to check that point -->
						<!--xsl:text>11b</xsl:text-->
					</xsl:otherwise>					
				</xsl:choose>		
			</xsl:when>
			<xsl:when test="(($isInAddedPhrase='Y' and  (@level = 'section' or not(@level)) )           and (contains($aStyle, 'archaic') or $aStyle = 'traditional' or $aStyle='appropriations'))     or (($isInAddedPhrase='Y' and @level='paragraph') and $aStyle='archaic-paragraph') or ($isInAddedPhrase='Y' and @level='appropriations-small') ">
				<xsl:choose>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'bold-brackets')">
						<xsl:text>1101r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>1101b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>1101i</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'italic') and $isInRamseyer = 'yes'">
						<xsl:text>1101ram</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>1101</xsl:text>						
					</xsl:otherwise>					
				</xsl:choose>				
			</xsl:when>
			<xsl:when test="($isInDeletedPhrase='Y' and (@level='subparagraph' or @level='clause'       or @level='subclause' or @level='item' or @level='subitem'))          or (($isInDeletedPhrase='Y' and @level='paragraph')  and $aStyle != 'archaic-paragraph')">
				<xsl:choose>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'bold-brackets')">
						<xsl:text>12r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>12b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>12i</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>12</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>		
				
			</xsl:when>
			<xsl:when test="($isInAddedPhrase='Y' and (@level='subparagraph' or @level='clause'      or @level='subclause' or @level='item' or @level='subitem'))         or (($isInAddedPhrase='Y' and @level='paragraph')  and $aStyle != 'archaic-paragraph')">
				<xsl:choose>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'bold-brackets')">
						<xsl:text>1201r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>1201b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>1201i</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>1201</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>
			</xsl:when>
			<xsl:when test="($isInDeletedPhrase='Y' and  (@level = 'section' or not(@level)) )           and  $aStyle = 'USC'">
				<xsl:choose>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'bold-brackets')">
						<xsl:text>13r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>13b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::deleted-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>13i</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>13</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>					
			</xsl:when>
			<xsl:when test="($isInAddedPhrase='Y' and  (@level = 'section' or not(@level)) )           and  $aStyle = 'USC'">
				<xsl:choose>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'bold-brackets')">
						<xsl:text>1301r</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-roman')">
						<xsl:text>1301b</xsl:text>
					</xsl:when>
					<xsl:when test="contains(ancestor::added-phrase[1]/@reported-display-style,'boldface-italic')">
						<xsl:text>1301i</xsl:text>
					</xsl:when>					
					<xsl:otherwise>
						<xsl:text>1301</xsl:text>
					</xsl:otherwise>					
				</xsl:choose>		
				
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>NoMode</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="header-in-text" mode="process">
        <xsl:variable name="node" select="." />
        <xsl:variable name="style">
            <xsl:choose>
                <!--Issue #510-->
                <xsl:when test="parent::text">
                    <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                    <xsl:apply-templates mode="process" />
                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>   
                </xsl:when>
                <xsl:when test="attribute::style and attribute::style != 'other'">
                    <xsl:value-of select="@style" />
                </xsl:when>
                <xsl:otherwise>
                    <!--BH:  Not sure what gets passed for 'billStyle' and 'restype'.  I assume that resolution type is optional.-->
                    <xsl:variable name="billStyle"> </xsl:variable>
                    <xsl:variable name="restype"> </xsl:variable>
                    <xsl:value-of select="gpo:GetNearestAncestorStyleValue($node, $billStyle, $restype)" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>	
        <xsl:variable name="level" select="@level" />
        <xsl:variable name="typeface">
            <xsl:call-template name="getInlineHeaderStyle">
                <xsl:with-param name="returnval" select="'typeface'" />
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="aMode">
            <xsl:call-template name="defineModeForInlineHeader">
                <xsl:with-param name="aStyle" select="$style" />
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="lettermode">
            <xsl:choose>
                <!-- last condition added TB Dec2010  if first char is typed in lower case in header-in text - print it in lower case -->
                <xsl:when test="$style='archaic-paragraph' and                      ($level='subparagraph'  or $level='clause'  or $level='subclause' or $level='item'  or $level='subitem' )                      and (not (lower-case(substring(., 1, 1)) = substring(., 1, 1) ) and local-name() = 'header-in-text') ">
                    <xsl:text>FirstWord</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="getInlineHeaderStyle">
                        <xsl:with-param name="returnval" select="'mode'" />
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>			
        </xsl:variable>
        <!-- issue #166, #167 -->
      <!--  <xsl:if test="@vbattTypeface='T5'">
            <xsl:text> </xsl:text>
        </xsl:if>-->
        <xsl:if test="normalize-space($typeface) != '' and not ($aMode='2comm') and not ($aMode='2conf')">
            <xsl:analyze-string select="$typeface" regex="(G|T)([0-9]+|#)">
                <xsl:matching-substring>
                    <xsl:choose>
                        <xsl:when test="regex-group(1)='G'">
                            <xsl:processing-instruction name="xpp">
                                <xsl:text>ff;</xsl:text>
                                <xsl:value-of select="normalize-space(regex-group(2))" />
                            </xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="regex-group(1)='T'">
                          <xsl:processing-instruction name="xpp">
                                <xsl:text>fv;</xsl:text>
                                <xsl:value-of select="if (regex-group(2) = '#') then '4' else normalize-space(regex-group(2))" />
                            </xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message>ERROR in getInlineHeaderStyle with mode=typeface processing <xsl:value-of select="local-name($node)" />: <xsl:value-of select="$node" /></xsl:message>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:matching-substring>
            </xsl:analyze-string>
        </xsl:if>
        <xsl:variable name="isNumberIncluded">
            <xsl:choose>
                <xsl:when test="translate (.,'1234567890()[]{}','') != .">
                    <xsl:text>yes</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>no</xsl:text>
                </xsl:otherwise>
            </xsl:choose> 
        </xsl:variable>
        
        <xsl:variable name="openAndCloseCode">
            <xsl:call-template name="getOpenAndCloseCode">
                <xsl:with-param name="aMode" select="$aMode" />
                <xsl:with-param name="isNumbersIncluded" select="$isNumberIncluded" />
            </xsl:call-template>
        </xsl:variable>
        
        <xsl:variable name="theOpenCode" select="substring-before($openAndCloseCode, '=')" />
        <xsl:variable name="theCloseCode" select="substring-after($openAndCloseCode, '=')" />
    
        <!-- if no @typeface, use default values; this might not be needed. Leave asis for now
            and we will modify, if needed 
            -->
        <xsl:if test="$typeface = ''">
         <xsl:choose>
             <xsl:when test="parent::text[@display-inline='yes-display-inline'][parent::quoted-block[@display-inline='yes-display-inline']]" />
             <!-- fixes issue #345 -->
             <xsl:when test="@level='subchapter' and $style='USC'" />
             <!-- issue #167 -->
             <xsl:when test="@level='section' and $style='traditional'">
                 <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
             </xsl:when>
             <xsl:when test="@level='title' and $style='OLC'">
                 <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
             </xsl:when>
             <xsl:when test="@level='appropriations-major'">
                 <!-- Issue #531. no PI for appropriations-major -->
             </xsl:when>
             <xsl:otherwise>
                 <!--Issue #44-->
              <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
             </xsl:otherwise>
         </xsl:choose>
        </xsl:if>
        
        
        <xsl:if test="$theOpenCode != ''">
            <xsl:value-of select="$theOpenCode" />
        </xsl:if>
        <xsl:for-each select="node()">
            <xsl:choose>
                <xsl:when test="self::text()">
                    <!-- text node -->
                    <xsl:choose>
                        <xsl:when test="$lettermode != ''">
                            <!--<xsl:value-of select="$lettermode"/>-->
                            <xsl:call-template name="applyTemplatesWithMode">
                                <xsl:with-param name="mode">
                                    <xsl:value-of select="$lettermode" />
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <!--<xsl:value-of select="gpo:capICHeader(string(.))"/>-->
                            <!-- issue #416 -->
                            <!-- The original LXL code does NOT process the text in any mode
                                so I am commenting the code above and replacing it with the code below -->
                            <xsl:apply-templates select="." mode="process" />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="." mode="process" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>
        <!--Issue #44-->
       <xsl:if test="$typeface != '' ">
            <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
        </xsl:if>
        <xsl:if test="$theCloseCode != ''">
            <xsl:value-of select="$theCloseCode" />
        </xsl:if>
        <!--Issue #44-->
        <!--<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>-->
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="getInlineHeaderStyle">
        <xsl:param name="returnval" />
        <xsl:variable name="attGrid" as="xs:string?" select="@vbattGrid" />
        <xsl:variable name="attType" as="xs:string?" select="@vbattTypeface" />
        <xsl:variable name="attMode" as="xs:string?" select="@vbattMode" />
        
        <xsl:variable name="typefaceAndMode">
            <xsl:if test="not($attGrid='' or $attGrid=' ')">
                <xsl:value-of select="$attGrid" />
            </xsl:if>
            <xsl:if test="not($attType='' or $attType=' ')">
                <xsl:value-of select="$attType" />
            </xsl:if>
            <xsl:text>|</xsl:text>
            <xsl:if test="not($attMode='' or $attMode=' ')">
                <xsl:value-of select="$attMode" />
            </xsl:if>
        </xsl:variable>
        <xsl:if test="$returnval='typeface'">
            <xsl:value-of select="substring-before($typefaceAndMode,'|')" />
        </xsl:if>
        <xsl:if test="$returnval='mode'">
            <xsl:value-of select="substring-after($typefaceAndMode,'|')" />
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="subscript" mode="process">
        <xsl:processing-instruction name="xpp">ff;5</xsl:processing-instruction>
        <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
        <xsl:apply-templates mode="process" />
        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
        <xsl:choose>
            <xsl:when test="parent::header">
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            </xsl:when>
        </xsl:choose>
        <!--NOTE:  Not sure what this means or does.  Creating another processing instruction -->
        <xsl:call-template name="subinhead" />       
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="subinhead">
        <!--<xsl:processing-instruction name="OREVERT"/>-->
       <!-- <xsl:text>&lt;BEL&gt;OREVERT</xsl:text>-->
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="openingSuperscriptHITPhrase">
        <xsl:variable name="currStyle">
            <xsl:choose>
                <xsl:when test="@style = 'other'">
                    <xsl:value-of select="@other-style" />
                </xsl:when>
                <xsl:when test="@style != 'other'">
                    <xsl:value-of select="@style" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="ancestor::*[@style][1]/@style" />
                   <!--This template/function is more complicated than the requirement to find the nearest style-->
<!--                    <xsl:call-template name="GetNearestAncestorStyleRecursive"/>					-->
                </xsl:otherwise>
            </xsl:choose>          
        </xsl:variable>
        <xsl:variable name="parentLevel">
            <xsl:choose>
                <xsl:when test="parent::header-in-text/@level">
                    <!--BH: Can't find an occurance when this would be fullfilled 'header-in-text' is just plain text
                    so it never is a parent.  Some of the scenarios below cannot be tested because it never tests the 
                    parent element.  It is always the 'header-in-text'.-->
                    <xsl:value-of select="parent::header-in-text/@level" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>section</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="IAmInLowLevelStructure">
            <xsl:call-template name="isLowLevelStructure" />
        </xsl:variable>
        <!--Anything that is not a parent is not resolved. Only testing the templates that can be resolved.-->
        <xsl:choose>
            <xsl:when test="$currStyle='OLC' and ($parentLevel='part' or $parentLevel='section')">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>            
            </xsl:when>
            <xsl:when test="$currStyle='USC' and $parentLevel='part'">
                <!--Never resolved-->
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$currStyle='archaic-paragraph' and $parentLevel='section'">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="($currStyle='OLC'  or $currStyle='USC') and $parentLevel='subsection'">
                <!--Never resolved-->
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="contains($currStyle,'archaic' ) and ($parentLevel='part'  or $parentLevel='section')">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="contains($currStyle,'traditional' ) and contains($parentLevel,'section' )">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="contains($currStyle,'traditional' ) and $parentLevel='part' ">
                <!--Never resolved-->
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$IAmInLowLevelStructure='yes'">
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise />         
        </xsl:choose>		
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="closingSuperscriptHITPhrase">
        <xsl:variable name="currStyle">
            <xsl:choose>
                <xsl:when test="attribute::style and attribute::style = 'other'">
                    <xsl:value-of select="@other-style" />
                </xsl:when>
                <xsl:when test="attribute::style and attribute::style != 'other'">
                    <xsl:value-of select="@style" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="ancestor::*[@style]/@style" />
                    <!--This template/function is more complicated than the requirement to find the nearest style-->
                    <!--<xsl:call-template name="GetNearestAncestorStyleRecursive"/>-->
                </xsl:otherwise>
            </xsl:choose>         
        </xsl:variable>
        <xsl:variable name="parentLevel">
            <xsl:choose>
                <xsl:when test="parent::header-in-text/@level">
                    <!--BH:   This will never happen because a header-in-text is text-->
                    <xsl:value-of select="parent::header-in-text/@level" />
                </xsl:when>				
                <xsl:otherwise>
                    <xsl:text>section</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="IAmInLowLevelStructure">
            <xsl:call-template name="isLowLevelStructure" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$currStyle='OLC' and ($parentLevel='part' or $parentLevel='section')">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$currStyle='USC' and $parentLevel='part'">
                <!--BH:  This will never be resolved-->
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$currStyle='archaic-paragraph' and $parentLevel='section'">
                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="($currStyle='OLC' or $currStyle='USC') and $parentLevel='subsection'">
                <!--BH:  This will never be resolved-->
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="contains($currStyle,'archaic' ) and ($parentLevel='part'  or $parentLevel='section')">
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="contains($currStyle,'traditional' ) and contains($parentLevel,'section' )">
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="contains($currStyle,'traditional' ) and $parentLevel='part' ">
                <!--BH:  This will never be resolved-->
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="contains($currStyle,'traditional' ) and $parentLevel='chapter' ">
                <!--BH:  This will never be resolved-->
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:when test="$IAmInLowLevelStructure='yes'">
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise />
        </xsl:choose>		
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="superscript" mode="process">
        <xsl:variable name="theSuperscriptContent">
            <xsl:apply-templates mode="process" />
        </xsl:variable>
        <xsl:variable name="tempContentCheck">
            <!--BH:  Not sure what this is used for because the string-length should always be '0'-->
            <xsl:value-of select="string-length(translate(lower-case($theSuperscriptContent), '1234567890',''))" />
        </xsl:variable>		
        <xsl:choose>	
            <!--I am commenting this out because the value is always '0'.  This is true even with the original code -->
                <!--<xsl:when test="$tempContentCheck = 0">
                
                <xsl:if test="ancestor::header-in-text">
                    <xsl:call-template name="openingSuperscriptHITPhrase"/>
                </xsl:if>
                &#x2216;
                <xsl:value-of select="$theSuperscriptContent"/>
                &#x2216;
                <xsl:if test="ancestor::header-in-text">
                    <xsl:call-template name="closingSuperscriptHITPhrase"/>
                </xsl:if>
            </xsl:when>-->
             <xsl:when test="parent::*/@vbattChangedForReported='italic'">
                <xsl:processing-instruction name="xpp">ff;5</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                <xsl:value-of select="$theSuperscriptContent" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
           
            <xsl:otherwise>
                <xsl:processing-instruction name="xpp">ff;5</xsl:processing-instruction>
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                <xsl:value-of select="$theSuperscriptContent" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:if test="ancestor::header-in-text">
                    <xsl:call-template name="closingSuperscriptHITPhrase" />
                </xsl:if>
                <xsl:if test="ancestor::header">
                    <xsl:call-template name="closingSuperscriptHeaderPhrase" />
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose> 
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="closingSuperscriptHeaderPhrase">
        <xsl:variable name="currStyle">
            <xsl:choose>
                <xsl:when test="attribute::style and attribute::style = 'other'">
                    <xsl:value-of select="@other-style" />
                </xsl:when>
                <xsl:when test="attribute::style and attribute::style != 'other'">
                    <xsl:value-of select="@style" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="ancestor::*[@style]/@style" />
                    <!--Do not need this complex template to find the style-->
                    <!--<xsl:call-template name="GetNearestAncestorStyleRecursive"/>-->
                </xsl:otherwise>
            </xsl:choose>           
        </xsl:variable>
        <xsl:variable name="parentLevel">
            <xsl:value-of select="local-name(ancestor::header/parent::*)" />				
        </xsl:variable>
        <xsl:variable name="IAmInLowLevelStructure">
            <xsl:call-template name="isLowLevelStructure" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="contains($currStyle,'traditional' ) and $parentLevel='chapter' ">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise />       
        </xsl:choose>		
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="constitution-article" mode="process">
        <xsl:if test="parent::quoted-block">
            <xsl:if test="./@changed and not (./@changed='not-changed')">
                <xsl:call-template name="AddorDelete" />
            </xsl:if>
            <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
            <xsl:text>Article</xsl:text>
            <xsl:value-of select="./enum" />
        </xsl:if>
        <xsl:if test="not(parent::quoted-block)">
            <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            <xsl:value-of select="./enum" />
        </xsl:if>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="committee-appointment-paragraph" mode="process">
        <para loc="20">  </para>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="committee-appointment-paragraph/header" mode="process">
        <xsl:variable name="text"><xsl:value-of select="." /></xsl:variable>
        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
        <xsl:value-of select="gpo:capitalize($text)" />
        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="iAmALastSiblingNoQoutedBlock">
        <xsl:choose>
            <xsl:when test="following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[1]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[2]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[3]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[4]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[5]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[6]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[7]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[8]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[9]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[10]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[11]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[12]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor::*[13]/following-sibling::*">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>true</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="term" mode="process">
        <xsl:variable name="termContent" as="node()*"><xsl:apply-templates mode="process" /></xsl:variable>
        <!--Issue #201 -->
        <xsl:variable name="depth" select="count(ancestor-or-self::quoted-block) + count(ancestor-or-self::quote) + count(ancestor-or-self::term)" />
        <xsl:if test="$depth &gt; 0">
            <xsl:choose>
                <!--Issue #406 - The depth count takes into account any ancestor which results in counting everything up 
                    the hierarchy.  These template matched what was in LXL so the modification might be in the VB code.-->
                <xsl:when test="ancestor::text and count(ancestor::quote) = 1">
                    <xsl:text>‘</xsl:text>
                     <xsl:call-template name="processTermContent">
                         <xsl:with-param name="termContent" select="$termContent" />
                     </xsl:call-template>
                    <xsl:text>’</xsl:text>
                </xsl:when>
                <xsl:when test="($depth mod 2) = 1">
                    <xsl:text>“</xsl:text>   
                    <xsl:call-template name="processTermContent">
                        <xsl:with-param name="termContent" select="$termContent" />
                    </xsl:call-template>
                   <xsl:text>”</xsl:text>
                </xsl:when>
                <xsl:when test="($depth mod 2) = 0">
                    <xsl:text>‘</xsl:text>
                    <xsl:call-template name="processTermContent">
                        <xsl:with-param name="termContent" select="$termContent" />
                    </xsl:call-template>
                    <xsl:text>’</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>“</xsl:text>  
                    <xsl:call-template name="processTermContent">
                        <xsl:with-param name="termContent" select="$termContent" />
                    </xsl:call-template>
                    <xsl:text>”</xsl:text>  
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="processTermContent">
        <xsl:param name="termContent" as="node()*" />
            <xsl:choose>
                <xsl:when test="child::*">
                    <xsl:sequence select="$termContent" />
                </xsl:when>
                <xsl:when test="ends-with($termContent, ' ')">
                    <xsl:value-of select="normalize-space($termContent)" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:sequence select="$termContent" />
                </xsl:otherwise>
            </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="text()" mode="process">
    <!--    <xsl:variable name="content">
        <xsl:call-template name="replace-string">
            <xsl:with-param name="text" select="."/>
            <xsl:with-param name="from">[[[mdash]]]</xsl:with-param>
            <xsl:with-param name="to" select="'&#x2014;'"/>
        </xsl:call-template>
        </xsl:variable>-->
        <!-- issue #546 -->
        <xsl:analyze-string select="." regex="½">
            <xsl:matching-substring>
                <xsl:processing-instruction name="xpp">frax;1;2</xsl:processing-instruction>
            </xsl:matching-substring>
            <xsl:non-matching-substring>
                <xsl:value-of select="." />
            </xsl:non-matching-substring>
        </xsl:analyze-string>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="replace-string">
        <xsl:param name="text" />
        <xsl:param name="from" />
        <xsl:param name="to" />
        <xsl:choose>
            <xsl:when test="contains($text, $from)">
                <xsl:variable name="before" select="substring-before($text, $from)" />
                <xsl:variable name="after" select="substring-after($text, $from)" />
                <xsl:variable name="prefix" select="concat($before, $to)" />
                <xsl:copy-of select="$before" />
                <xsl:value-of select="$to" />
                <xsl:call-template name="replace-string">
                    <xsl:with-param name="text" select="$after" />
                    <xsl:with-param name="from" select="$from" />
                    <xsl:with-param name="to" select="$to" />
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$text" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="createSlugLine">
        <xsl:variable name="legis-num" as="xs:string+">
            <xsl:choose>
                <xsl:when test="starts-with($m_legisNumber, 'H. CON.')">HCON<xsl:text> </xsl:text></xsl:when>
                <xsl:when test="starts-with($m_legisNumber, 'H')">HR<xsl:text> </xsl:text><xsl:value-of select="substring-after($m_legisNumber, 'R. ')" /></xsl:when>
                <xsl:when test="starts-with($m_legisNumber, 'S')">S<xsl:text> </xsl:text><xsl:value-of select="substring-after($m_legisNumber, 'S. ')" /></xsl:when>
                <xsl:when test="ancestor::amendment-doc and not(//legis-num)">
                    <xsl:call-template name="createLegisNum" />
                </xsl:when>
                <xsl:otherwise>UNHANDLED</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="doc-stage"> 
            <xsl:call-template name="PrintBillStageCalculation">
                <xsl:with-param name="docstage">
                    <xsl:choose>
                        <xsl:when test="/bill/@bill-stage">
                            <xsl:value-of select="/bill/@bill-stage" />
                        </xsl:when>
                        <xsl:when test="/amendment-doc/@amamend-stage">
                            <xsl:value-of select="/amendment-doc/@amend-stage" />
                        </xsl:when>
                        <xsl:otherwise />
                    </xsl:choose>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="$legis-num" />
        <xsl:text> </xsl:text>
        <xsl:value-of select="normalize-space($doc-stage)" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="iAmALastSibling">
        <xsl:param name="source" />
        <xsl:choose>
            <xsl:when test="(following-sibling::* and not(local-name(following-sibling::*[1]) ='after-quoted-block')) or  following-sibling::*[2]">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <!-- TB 8Apr-2011 - this condition is incorrect being quoted block does not mean that I am a last sibling -->
            <!--xsl:when
				test="local-name(ancestor::*[1])='quoted-block'  and $source != 'toc'">
				<xsl:text>true</xsl:text>
			</xsl:when-->
            <xsl:when test="(ancestor::*[1]/ following-sibling::* and not(local-name(ancestor::*[1]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[1]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>	
            <xsl:when test="local-name(ancestor::*[2])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[2]/ following-sibling::* and not(local-name(ancestor::*[2]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[2]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>	
            <xsl:when test="local-name(ancestor::*[3])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[3]/ following-sibling::* and not(local-name(ancestor::*[3]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[3]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>	
            <xsl:when test="local-name(ancestor::*[4])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[4]/ following-sibling::* and not(local-name(ancestor::*[4]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[4]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>		
            <xsl:when test="local-name(ancestor::*[5])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[5]/ following-sibling::* and not(local-name(ancestor::*[5]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[5]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>	
            <xsl:when test="local-name(ancestor::*[6])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[6]/ following-sibling::* and not(local-name(ancestor::*[6]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[6]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>	
            <xsl:when test="local-name(ancestor::*[7])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[7]/ following-sibling::* and not(local-name(ancestor::*[7]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[7]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>		
            <xsl:when test="local-name(ancestor::*[8])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[8]/ following-sibling::* and not(local-name(ancestor::*[8]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[8]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>	
            <xsl:when test="local-name(ancestor::*[9])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[9]/ following-sibling::* and not(local-name(ancestor::*[9]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[9]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>	
            <xsl:when test="local-name(ancestor::*[10])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[10]/ following-sibling::* and not(local-name(ancestor::*[10]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[10]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>		
            <xsl:when test="local-name(ancestor::*[11])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[11]/ following-sibling::* and not(local-name(ancestor::*[11]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[11]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>	
            <xsl:when test="local-name(ancestor::*[12])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[12]/ following-sibling::* and not(local-name(ancestor::*[12]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[12]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>	
            <xsl:when test="local-name(ancestor::*[13])='quoted-block'  and $source != 'toc'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="(ancestor::*[13]/ following-sibling::* and not(local-name(ancestor::*[13]/following-sibling::*[1]) ='after-quoted-block') or (ancestor::*[13]/following-sibling::*[2]))">
                <xsl:text>false</xsl:text>
            </xsl:when>			
            <xsl:otherwise>
                <xsl:text>true</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="PrintBillStageCalculation">
        <xsl:param name="docstage" />
        <xsl:variable name="theSlugNumber" />
        <xsl:variable name="current-chamber" />
    <xsl:sequence select="if (lower-case($docstage) ='printed-as-passed') then 'PAP'         else if ($docstage='Public-Print' or $bill-public-print='yes') then 'PP'         else if ($docstage='Additional-Sponsors-House') then 'ASH'         else if ($docstage='Additional-Sponsors-Senate') then 'SAS'         else if ($docstage='Agreed-to-House') then 'ATH'         else if ($docstage='Agreed-to-Senate') then 'ATS'         else if ($docstage='Amendment-in-House') then 'AH'         else if ($docstage='Amendment-in-Senate') then 'AS'         else if ($docstage='Committee-Discharged-House') then 'CDH'         else if ($docstage='Committee-Discharged-Senate') then 'CDS'         else if ($docstage='Considered-and-Passed-House') then 'CPH'         else if ($docstage='Considered-and-Passed-Senate') then 'CPS'         else if ($docstage='Engrossed-Amendment-House') then concat('EAH', $theSlugNumber)         else if ($docstage='Engrossed-Amendment-Senate') then concat('EAS', $theSlugNumber)         else if ($docstage='Engrossed-in-House') then concat('EH', $theSlugNumber)         else if ($docstage='Engrossed-in-Senate') then concat('ES', $theSlugNumber)         else if ($docstage='Enrolled-Bill') then 'ENR'         else if ($docstage='Failed-Amendment-House') then 'FAH'         else if ($docstage='Failed-Passage-House') then 'FPH'         else if ($docstage='Failed-Amendment-Senate') then 'FAS'         else if ($docstage='Failed-Passage-Senate') then 'FPS'         else if ($docstage='Held-at-Desk-House') then 'HDH'         else if ($docstage='Held-at-Desk-Senate') then 'HDS'         else if ($docstage='Indefinitely-Postponed-House') then 'IPH'         else if ($docstage='Indefinitely-Postponed-Senate') then 'IPS'         else if ($docstage='Introduced-in-House') then 'IH'         else if ($docstage='Introduced-in-Senate') then 'IS'         else if ($docstage='Laid-on-Table-House') then 'LTH'         else if ($docstage='Laid-on-Table-Senate') then 'LTS'         else if ($docstage='Ordered-to-be-Printed-House') then 'OPH'         else if ($docstage='Ordered-to-be-Printed-Senate') then 'OPS'         else if ($docstage='Placed-on-Calendar-House') then 'PCH'         else if ($docstage='Placed-on-Calendar-Senate') then 'PCS'         else if ($docstage='Pre-Introduction') then ''         else if ($docstage='Re-Enrolled-Bill') then 'RENR'         else if ($docstage='Received-in-House') then 'RDH'         else if ($docstage='Received-in-Senate') then 'RDS'         else if ($docstage='Reengrossed-Amendment-House') then concat('REAH', $theSlugNumber)         else if ($docstage='Reengrossed-Amendment-Senate') then concat('REAS', $theSlugNumber)         else if ($docstage='Reference-Change-House') then 'RCH'         else if ($docstage='Reference-Change-Senate') then 'RCS'         else if ($docstage='Referral-Instructions-House') then 'RIH'         else if ($docstage='Referral-Instructions-Senate') then 'RIS'         else if ($docstage='Referred-in-House') then 'RFH'         else if ($docstage='Referred-in-Senate') then 'RFS'         else if ($docstage='Referred-to-Committee-House') then 'RTH'         else if ($docstage='Referred-to-Committee-Senate') then 'RTS'         else if ($docstage='Referred-w-Amendments-House') then 'RAH'         else if ($docstage='Referred-w-Amendments-Senate') then 'RAS'         else if ($docstage='Reported-in-House') then 'RH'         else if ($docstage='Reported-in-Senate') then 'RS'         else if ($docstage='Sponsor-Change') then 'SC'         else if ($docstage='Engrossed-House' or $docstage='Engrossed-in-House') then concat('EH', $theSlugNumber)         else if ($docstage='Reported-House') then 'RH'         else if ($docstage='Enrolled-House') then 'ENR'         else if ($docstage='Introduced-House') then 'IH'         else if ($docstage='Pre-Introduction') then ''         else if ($docstage='Enrolled-in-Senate') then 'ENR'         else if ($docstage='Re-Enrolled-in-Senate') then 'RENR'         else if (contains($current-chamber,'House')) then concat('EAH', $theSlugNumber)         else if (contains($current-chamber,'Senate')) then concat('EAS', $theSlugNumber)         else ''" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="NoTextBefore">
        <xsl:param name="aCurrentText" as="xs:string" />
        
        <xsl:variable name="aWholeText" as="xs:string">
            <xsl:for-each select="parent::node()">
                <xsl:value-of select="." />
            </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="stringPartToProceed_1" as="xs:string" select="normalize-space(substring-before($aWholeText, $aCurrentText))" />
        
        
        <xsl:choose>
            <xsl:when test="parent::subparagraph or parent::clause or parent::subclause or parent::item or parent::subitem">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$stringPartToProceed_1 = ''">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>false</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="text" mode="process">
        <xsl:choose>
            <!--Issue 221-->
            <xsl:when test="parent::paragraph[quoted-block[@display-inline = 'yes-display-inline']]" />
            <xsl:when test="ancestor::quoted-block">
                <para loc="20">
                    <xsl:text>  “</xsl:text>
                    <!--Issue #518 - space after period in text-->
                    <xsl:choose>
                        <xsl:when test="ends-with(., ' ')  and not(child::*)">
                            <xsl:value-of select="normalize-space(.)" />
                        </xsl:when>
                        <xsl:otherwise><xsl:apply-templates mode="process" /></xsl:otherwise>
                    </xsl:choose>
                    <xsl:if test="following-sibling::quoted-block/text[@display-inline='yes-display-inline'] or                          following-sibling::quoted-block[@display-inline='yes-display-inline']/text">       
                        <xsl:call-template name="includeQuotedBlockText" />
                    </xsl:if>
                    <xsl:call-template name="calculateQuotedBlockEnd" />
                </para>
            </xsl:when>
            <xsl:otherwise>
                <para loc="20">
                    <xsl:text>  </xsl:text>
                    <xsl:apply-templates mode="process" />
                    <xsl:if test="following-sibling::quoted-block/text[@display-inline='yes-display-inline'] or                          following-sibling::quoted-block[@display-inline='yes-display-inline']/text">       
                        <xsl:call-template name="includeQuotedBlockText" />
                    </xsl:if>
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:call-template name="calculateQuotedBlockEnd" />
                    </xsl:if>
                </para>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="includeQuotedBlockText">
        <xsl:choose>
            <!--Issue #257-->
            <xsl:when test="following-sibling::quoted-block[1]/text[@display-inline='yes-display-inline']/child::header-in-text">
                <xsl:apply-templates select="following-sibling::quoted-block[1]/text[@display-inline='yes-display-inline']" mode="inline-quoted-block" />
            </xsl:when>
            <xsl:when test="(parent::quoted-block and                  (../*/descendant::enum or ../*/descendant::header or ../*/descendant::text or ../*/descendant::continuation-text))" />
            <xsl:otherwise>
               <xsl:text> </xsl:text><xsl:text>“</xsl:text>
                <!--Issue #509 modified 'value-of' to 'apply-templates'-->
                  <xsl:apply-templates select="following-sibling::quoted-block[1]/text" mode="inline" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quote/short-title" mode="process"><xsl:apply-templates mode="process" /></xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="quoted-block[1][@display-inline='yes-display-inline']/text[@display-inline='yes-display-inline']" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="calculateQuotedBlockEnd">
        <xsl:variable name="style" as="xs:string" select="gpo:GetNearestAncestorStyleRecursive(., true())" />
        <xsl:variable name="qb-id" as="xs:string?">
            <xsl:value-of select="ancestor::quoted-block/@id" />
        </xsl:variable>
        <xsl:variable name="textCount" as="xs:integer">
            <xsl:value-of select="count(ancestor::quoted-block/descendant::text)" />
        </xsl:variable>
        <xsl:variable name="currentCount" as="xs:integer">
            <xsl:value-of select="count(preceding::text[ancestor::quoted-block/@id = $qb-id]) + 1" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="following-sibling::toc" />
            <xsl:when test="not(ancestor::quoted-block/descendant::continuation-text) and not(following-sibling::toc)">
                <!--Issue #238 -->
                <xsl:if test="not(../following-sibling::continuation-text)">
                    
                    <xsl:if test="$textCount = $currentCount">
                        <xsl:text>”</xsl:text>
                        <!-- fixes issue #285 -->
                        <xsl:if test="/bill[@bill-stage='Introduced-in-House'] and $style='USC'">
                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        </xsl:if>
                        <xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
                    </xsl:if>
                </xsl:if>
            </xsl:when>
            <xsl:when test="$textCount = $currentCount">
                <xsl:text>”</xsl:text>
                <!-- fixes issue #285 -->
                <xsl:if test="/bill[@bill-stage='Introduced-in-House'] and $style='USC'">
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                </xsl:if>
                <xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
                <!--<xsl:text>&#x201D;</xsl:text>-->
            </xsl:when>
            <xsl:otherwise />
        </xsl:choose>
       
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="createEnum">
        <xsl:param name="enum" />
        <xsl:variable name="alphabet">abcdefghijklmnopqrustvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</xsl:variable>
        <xsl:variable name="enum-length"><xsl:value-of select="string-length($enum)" /></xsl:variable>
        <xsl:variable name="revised-string-length"><xsl:value-of select="translate($enum, $alphabet, '')" /></xsl:variable>
        <xsl:choose>
            <xsl:when test="$enum-length != $revised-string-length">
        <xsl:analyze-string select="$enum" regex="([0-9]+)([a-zA-Z])+(.)?">
            <xsl:matching-substring>
                Sec.
                <xsl:processing-instruction name="xpp">fv:5</xsl:processing-instruction>
                <xsl:value-of select="regex-group(1)" />
                <xsl:processing-instruction name="xpp">fv:1</xsl:processing-instruction>
                <xsl:value-of select="regex-group(2)" /><xsl:value-of select="regex-group(3)" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:matching-substring>
            <xsl:non-matching-substring />
        </xsl:analyze-string>
            </xsl:when>
            <xsl:otherwise><xsl:value-of select="$enum" />enum = <xsl:value-of select="$enum" /></xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="enum" mode="inline">
           <xsl:apply-templates mode="process" />
           <!--Issue #415-->
           <xsl:choose>
               <xsl:when test="ancestor::quoted-block and  not(following-sibling::header) and not(following-sibling::text) and                     (not(../*/enum) and not(../*/text) and not(../*/header) and not(ancestor::quoted-block/continuation-text))">
                   <xsl:text>”</xsl:text><xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
               </xsl:when>
               <xsl:otherwise />
           </xsl:choose>
       </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="createQuotedBlock">
        <xsl:param name="qb-id" />
        <xsl:param name="textCount" />
        <xsl:param name="currentCount" />
        <xsl:param name="levelLocator" />
        <xsl:param name="actualLevelLocator" />
     
        <xsl:choose>
            <xsl:when test="text[@display-inline='yes-display-inline']">
                <xsl:call-template name="KeepParentsFormatOrSelf" />
                <para>
                    <xsl:attribute name="loc" select="$actualLevelLocator" /><xsl:text>  “</xsl:text><xsl:value-of select="enum" /><xsl:text> </xsl:text>
                    <xsl:if test="header">
                        <xsl:call-template name="createHeader" /><xsl:text> </xsl:text>
                    </xsl:if>               
                        <xsl:apply-templates select="text" mode="inline" />
                        <xsl:if test="$textCount = $currentCount">”<xsl:value-of select="ancestor::quoted-block/after-quoted-block" /></xsl:if>
                    </para>  
            </xsl:when>
            <xsl:when test="text[not(@display-inline)]">
                <xsl:call-template name="KeepParentsFormatOrSelf" />
            <para>
                <xsl:attribute name="loc" select="$actualLevelLocator" /><xsl:text>  “</xsl:text><xsl:value-of select="enum" /><xsl:text> </xsl:text>
                <xsl:if test="header">
                    <xsl:call-template name="createHeader" /><xsl:text> </xsl:text>
                </xsl:if>               
                <xsl:apply-templates select="text" mode="inline" />
                <xsl:if test="$textCount = $currentCount">”<xsl:value-of select="ancestor::quoted-block/after-quoted-block" /></xsl:if>
            </para>  
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="KeepParentsFormatOrSelf" />
                <para>
                    <xsl:attribute name="loc" select="$actualLevelLocator" />  “<xsl:value-of select="enum" /><xsl:text> </xsl:text>
                    <xsl:if test="header">
                        <xsl:call-template name="createHeader" /><xsl:text> </xsl:text>
                    </xsl:if>
                </para>
                <para loc="20"><xsl:apply-templates select="text" mode="inline" /><xsl:if test="$textCount = $currentCount">”<xsl:value-of select="../after-quoted-block" /></xsl:if></para>
            </xsl:otherwise>
        </xsl:choose>
     
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="text" mode="inline">
          <xsl:choose>
              <xsl:when test="ends-with(., ' ')  and not(child::*)">
                  <xsl:value-of select="normalize-space(.)" />
              </xsl:when>
              <xsl:otherwise><xsl:apply-templates mode="process" /></xsl:otherwise>
          </xsl:choose>
        <xsl:if test="following-sibling::quoted-block/text[@display-inline='yes-display-inline'] or                        following-sibling::quoted-block[@display-inline='yes-display-inline']/text">       
            <xsl:call-template name="includeQuotedBlockText" />
        </xsl:if>
        <!--Issue #112:  end quotes were not being output when the text node was in-line-->
        <xsl:choose>
            <xsl:when test="parent::quoted-block">
                
                <xsl:choose>
                    <xsl:when test="parent::quoted-block/descendant::enum or parent::quoted-block/descendant::header or                          parent::quoted-block/descendant::text or parent::quoted-block/descendant::continuation-text                         or ancestor::quoted-block/descendant::quoted-block-continuation-text" />
                    <xsl:otherwise><xsl:call-template name="calculateQuotedBlockEnd" /></xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        <xsl:when test="ancestor::quoted-block and (not(../*/enum) and not(../*/header) and not(../*/text)             and not(../following-sibling::continuation-text))">
         <xsl:call-template name="calculateQuotedBlockEnd" />
        </xsl:when>
            <xsl:otherwise />
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="createClosingBlockPunctuation">
        <xsl:choose>
            <xsl:when test="text or subsection or toc or paragraph" />
            <xsl:otherwise>
                <xsl:if test="local-name(following::*[1]) = 'after-quoted-block'">
                    <xsl:if test="not(following::after-quoted-block/@display = 'no')">
                        <xsl:call-template name="QuotedBlockNestingEnd" />
                        
                        <xsl:value-of select="following::*[1]" />
                        
                        <xsl:call-template name="addClosingCharacterForChildElements">
                            <xsl:with-param name="source">
                                <xsl:text>afterQuotedBlock</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:if>
                </xsl:if></xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="continuation-text" mode="process">
        <xsl:variable name="level" select="@continuation-text-level" />
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        
        <xsl:variable name="locatorCode" as="xs:integer" select="gpo:actualPutLocatorWithIndent(., 'no', $level)" />
      <!--  <xsl:variable name="locatorCode">
            <xsl:call-template name="actualPutLocatorWithIndent">
                <xsl:with-param name="level" select="$level"/>
                <xsl:with-param name="pageBreakMode">no</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>
      subsfection it will always be a bell I20
		paragraph it will always be a bell I22
		subparagraph it will always be a bell I24
		clause it will always be a bell I26
		subclause it will always be a bell I28
		item it will always be a bell I30
		subitem it will always be a bell I31
      -->
        <para>
            <!--Issue #360 and #412-->
            <xsl:attribute name="loc">
            <xsl:choose>
                <xsl:when test="@continuation-text-level='subsection'">20</xsl:when>
                <xsl:when test="@continuation-text-level='paragraph'">22</xsl:when>        
                <xsl:when test="@continuation-text-level='subparagraph' and @style='USC'">22</xsl:when>
                <xsl:when test="@indent='subparagraph'">24</xsl:when>
                <xsl:when test="@continuation-text-level='subparagraph'">24</xsl:when>
                <xsl:when test="@continuation-text-level='clause'">26</xsl:when>
                <xsl:when test="@continuation-text-level='subclause'">28</xsl:when>
                <xsl:when test="@continuation-text-level='item'">30</xsl:when>
                <xsl:when test="@continuation-text-level='subitem'">31</xsl:when>
                <xsl:otherwise><xsl:value-of select="$locatorCode" /></xsl:otherwise>
            </xsl:choose>
            </xsl:attribute>
          <xsl:if test="@commented='yes'">
              <!-- and the next node is not inline -->
              <xsl:if test="not(following-sibling::*[@display-inline='yes-display-inline'] or local-name(following::*[1]) = 'after-quoted-block')">
                  <xsl:text>❨</xsl:text>
              </xsl:if>
          </xsl:if>
          <xsl:apply-templates mode="process" />
          <xsl:if test="@commented='yes'">
              <!-- and the next node is not inline -->
              <xsl:if test="not(following-sibling::*[@display-inline='yes-display-inline'] or local-name(following::*[1]) = 'after-quoted-block')">
                  <xsl:text>❩</xsl:text>
              </xsl:if>
          </xsl:if>
          <xsl:if test="local-name() = 'continuation-text' and @vbattChangedForReported ='bold-brackets' ">
              <!-- and the next node is not inline -->
              <xsl:variable name="toCloseBrackets" as="xs:string">
                  <xsl:call-template name="toCloseTheBrakets" />
              </xsl:variable>
              <xsl:if test="$toCloseBrackets='yes'">
                  <xsl:text>❩</xsl:text>
              </xsl:if>
          </xsl:if>
            <!-- fixes issue #311 -->
            <!-- the code below is commented out because it adds extra punctuation when it is needed
                I have checked the original LXL code and it is NOT there so I am not sure how it made it in here
                Please do not uncomment. If you need it needs to be put back, please let everyone know because
                it will re-introduce issue #311
                -->
         
         
              <xsl:if test="ancestor::quoted-block">
<!--                  <xsl:call-template name="calculateQuotedBlockEnd"/>-->
                 <!-- <xsl:if test="text()[. is
                      (ancestor::quoted-block/descendant::*)[last()]]">
                  <xsl:text>&#x201D;</xsl:text>
                  <xsl:value-of select="ancestor::quoted-block/after-quoted-block"/>       
              </xsl:if> -->
                  <!-- Issue #337 -->
                  <xsl:if test="name() = 'continuation-text' and ancestor::quoted-block">
                      <xsl:variable name="qb-id" select="ancestor::quoted-block[1]/@id" />
                      <xsl:choose>
                          <xsl:when test="following::text[ancestor::quoted-block[@id = $qb-id]]" />
                          <xsl:otherwise>
                              <xsl:text>”</xsl:text>
                              <!-- fixes issue #285 -->
                              <xsl:if test="/bill[@bill-stage='Introduced-in-House'] and @style='USC'">
                                  <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                              </xsl:if>
                              
                              <xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
                          </xsl:otherwise>
                      </xsl:choose>
                      
                  </xsl:if>
              </xsl:if>
            
          
         </para>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toCloseTheBrakets">
        <xsl:variable name="isSiblingsRuleTrue" as="xs:string">
            <xsl:call-template name="checkSiblingsRule" />
        </xsl:variable>
        <xsl:variable name="nextSiblingBracketed" as="xs:string?">
            <xsl:call-template name="isNextSiblingBracketed" />
        </xsl:variable>
        <!-- TB Feb-12-2013 removing changed='deleted from the decision. leave only bold-brackets reported-display-style as part of the decision' -->
        <xsl:choose>
            <xsl:when test="$isSiblingsRuleTrue='yes'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="local-name()='list-item'">
                <xsl:call-template name="CloseBracketsForListItem" />
            </xsl:when>			
            <xsl:when test="$nextSiblingBracketed !='yes'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="not (following::*)">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="findActualLocator">
        <xsl:param name="levelLocator" as="xs:double" />
        <xsl:variable name="level"><xsl:value-of select="local-name()" /></xsl:variable>
        <xsl:variable name="updownNumber">
            <xsl:choose>
                <xsl:when test="contains(@indent, 'up')"><xsl:value-of select="xs:double(substring-after(@indent, 'up'))" /></xsl:when>
                <xsl:when test="contains(@indent, 'down')"><xsl:value-of select="xs:double(substring-after(@indent, 'down'))" /></xsl:when>
                <xsl:otherwise>0</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="oddOrEven">
            <xsl:choose>
                <xsl:when test="$updownNumber != 0">
                    <xsl:choose>
                        <xsl:when test="$updownNumber mod 2 = 0">even</xsl:when>
                        <xsl:otherwise>odd</xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise />
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="realLocator">
            
            <xsl:choose>
                <xsl:when test="contains(@indent, 'up')">
                    <xsl:choose>
                        <!--BH - this is the formula described in lxl but it is wrong
                   In the event the indent-string starts with 'up', the formula is
	(up - ((value - 1) * 2))
	
	In the event the indent-string starts with 'down', the formula is
	(down + ((value - 1) * 2))
	
	The range of acceptable values is 20-31-->
                        <!--  <xsl:when test="name() = 'item'">
                            <xsl:value-of select="(28 + 1 - ($updownNumber  *2))"/>
                        </xsl:when>-->   
                        <!--Issue #264 -->
                        <xsl:when test="name() = 'clause'">
                            <xsl:choose>
                                <xsl:when test="@indent = 'up1'">24</xsl:when>
                                <xsl:when test="@indent = 'up2'">22</xsl:when>
                                <xsl:when test="@indent = 'up3'">20</xsl:when>
                                <xsl:when test="$updownNumber = 3">22</xsl:when>      
                                <xsl:when test="$oddOrEven = 'odd'">
                                    <xsl:value-of select="$levelLocator - $updownNumber - 1" />
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="$levelLocator - ($updownNumber * 2)" /></xsl:otherwise>
                            </xsl:choose>
                            <!-- <xsl:when test="name() = 'clause' and @indent = 'up1'">24</xsl:when>
                        <xsl:when test="name() = 'clause' and @indent = 'up2'">22</xsl:when>
                        <!-\-Issue #382 and 395-\->
                        <xsl:when test="name() = 'clause' and @indent = 'up3'">20</xsl:when>  -->  
                        </xsl:when>
                        <!--Issue ##331-->
                        <xsl:when test="name() = 'subclause'">
                            <xsl:choose>
                                <xsl:when test="@indent = '1'">26</xsl:when>
                                <xsl:when test="@indent = 'up1'">26</xsl:when>
                                <xsl:when test="@indent = 'up2'">24</xsl:when>
                                <xsl:when test="@indent = 'up3'">22</xsl:when>
                                <xsl:when test="@indent = 'up4'">20</xsl:when>
                                <xsl:when test="$oddOrEven = 'odd'">
                                    <xsl:value-of select="$levelLocator - $updownNumber * 2" />
                                </xsl:when>
                                <xsl:otherwise><xsl:value-of select="$levelLocator - $updownNumber" /></xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <!--Issue #380 - modified to look at the @indent instead of the calculation.  The '1'
                        results in a different locator and the 'up1' can use the standard calculation.-->
                        <!--Issue #525-->
                        <xsl:when test="name() = 'item'">
                            <xsl:choose>
                                <xsl:when test="@indent = '1'">28</xsl:when>
                                <xsl:when test="@indent = 'up1'">28</xsl:when>
                                <xsl:when test="@indent = 'up2'">26</xsl:when>
                                <xsl:when test="@indent = 'up3'">24</xsl:when>
                                <xsl:when test="@indent = 'up4'">22</xsl:when>
                                <xsl:when test="$oddOrEven = 'odd'">
                                    <xsl:value-of select="$levelLocator - $updownNumber * 2" />
                                </xsl:when>
                            </xsl:choose>
                        </xsl:when>
                        <!--Issue #302-->
                        <xsl:when test="name() = 'subitem' and @indent = '1'">20</xsl:when>
                        <xsl:when test="name() = 'subitem'">
                            <xsl:value-of select="(31 + 1 - ($updownNumber  *2))" />
                        </xsl:when>
                        <xsl:when test="$oddOrEven = 'even'">
                            <xsl:value-of select="$levelLocator - ($updownNumber * 2)" />
                            <!--                                <xsl:value-of select="$levelLocator - $updownNumber"/>-->
                        </xsl:when>
                        <xsl:when test="$oddOrEven = 'odd'">
                            <xsl:choose>
                                <xsl:when test="name() = 'item' and $updownNumber = 1">24</xsl:when>
                                <xsl:when test="name() = 'subitem' and $updownNumber = 1">20</xsl:when>
                                <xsl:otherwise><xsl:value-of select="$levelLocator - ($updownNumber + 1)" /></xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="name() = 'subparagraph'">
                            <xsl:value-of select="$updownNumber" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$levelLocator - ($updownNumber * 2)" />
                        </xsl:otherwise>
                    </xsl:choose>        
                </xsl:when>
                <xsl:when test="contains(@indent, 'down')">
                    <xsl:variable name="downlevel"><xsl:value-of select="number(substring-after(@indent, 'down'))" /></xsl:variable>
                    <xsl:choose>
                        <xsl:when test="name() = 'subclause' and @indent='down1'">30</xsl:when>
                        <xsl:when test="name() = 'item'"><xsl:value-of select="30 + $downlevel" /></xsl:when>
                        <xsl:otherwise> <xsl:value-of select="xs:integer($levelLocator) + ($downlevel -1 * 2)" /></xsl:otherwise>
                    </xsl:choose>     
                </xsl:when>
                <xsl:otherwise><xsl:value-of select="$levelLocator" /></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:choose>
            <!--Issue #335-->
            <xsl:when test="name() = 'subitem' and @indent = '1'">20</xsl:when>
            <xsl:when test="$realLocator &lt; 20">20</xsl:when>
            <xsl:otherwise><xsl:value-of select="$realLocator" /></xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="external-xref" mode="process">
        <xsl:apply-templates mode="process" />
        <!-- remove extra space per issue #50 -->
        <!-- <xsl:text> </xsl:text> -->
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="table" mode="process">
            <table>
                <xsl:copy-of select="@*" />
               <xsl:apply-templates mode="process" />
            </table>
            <!-- TASSOS: needed per Deb's comment -->
            <para format="6999" loc="20" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="tgroup" mode="process">
        <tgroup>
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="process" />
        </tgroup>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="tfoot" mode="process">
        <tfoot>
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="process" />
        </tfoot>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="colspec" mode="process">
        <colspec>
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="process" />
        </colspec>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="tbody" mode="process">
        <tbody>
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="process" />
        </tbody>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="thead" mode="process">
        <thead>
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="process" />
        </thead>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="row" mode="process">
        <row>
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="process" />
        </row>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="entry" mode="process">
        <entry>
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="process" />
            <xsl:if test="ancestor::quoted-block">
                <xsl:call-template name="createLastEntryQuotedBlock" />
            </xsl:if>
        </entry>      
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="ttitle" mode="process">
        <ttitle>
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="process" />
        </ttitle>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="tdesc" mode="process">
        <tdesc>
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="process" />
        </tdesc>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="createLastEntryQuotedBlock">
        <xsl:variable name="rowcount"><xsl:value-of select="count(ancestor::tbody/row)" /></xsl:variable>
        <xsl:variable name="afterTableCount"><xsl:value-of select="count(ancestor::table/following-sibling::*)" /></xsl:variable>
        <xsl:choose>
            <xsl:when test="$afterTableCount = 2">
                <xsl:variable name="preceding-row-count"><xsl:value-of select="count(ancestor::row/preceding-sibling::row) + 1" /></xsl:variable>
                <xsl:if test="(position() = last()) and $rowcount = $preceding-row-count">
                    <xsl:text>“</xsl:text>
                    <xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
                </xsl:if>
            </xsl:when>
            <xsl:otherwise />
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="processing-instruction()" mode="process">
                <xsl:copy />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="form" mode="process">
		<xsl:choose>
			<xsl:when test="@display='no'" />
			<xsl:otherwise>
				<xsl:apply-templates mode="process" />
			</xsl:otherwise>
		</xsl:choose>
	    <!-- comment out; doesn't exist in LXL code and the PI is inserted from processing legis-num -->
	   <!-- <xsl:if test="//official-title/pagebreak">
	        <xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>
	    </xsl:if>-->
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="congress" as="item()*" mode="process">
		
		<xsl:sequence select="gpo:outputComment('start congress')" />
		
		<xsl:if test="not(@display = 'No') and string-length(text()) != 0">
			<xsl:choose>
				<xsl:when test="$docstage = 'Enrolled-Bill'       or $resstage = 'Enrolled-House'       or $resstage = 'Enrolled-in-Senate'">
					
					<!-- TA: Why is the replacement happening twice? -->
				    <!--BH:  The characters aren't correct. Can't determine what character the Upconversion is working against
				        so I copied the straight characters from the Upconversion-->
					<para loc="07">
					    <!--<xsl:value-of select="gpo:rawRegexReplace(gpo:capFW(string($m_legisNumber)), '[ \t]', '&#x2007;&#x2007;&#x2007;')"/>-->
					    <xsl:value-of select="gpo:rawRegexReplace(gpo:capFW(string($m_legisNumber)), '[ \t]', '   ')" />
						<xsl:text>—</xsl:text>
					</para>  
					<para loc="15">
						<xsl:text>    </xsl:text>
						<!--<xsl:value-of         
							select="gpo:rawRegexReplace(gpo:capFW(string($m_legisNumber)), '[ \t]', '&#x2007;&#x2007;&#x2007;')"/>-->
					    <xsl:value-of select="gpo:rawRegexReplace(gpo:capFW(string($m_legisNumber)), '[ \t]', '   ')" />
					</para>
					<xsl:if test="//action/action-desc">
						<para loc="16">
							<xsl:value-of select="//action/action-desc" />
							<xsl:text> </xsl:text>
							<xsl:value-of select="//action/action-date" />
							<xsl:if test="($restype = 'senate-concurrent' or $restype = 'house-concurrent') and $resstage = 'Enrolled-Bill'">
								<xsl:text>    </xsl:text>
							</xsl:if>
						</para>
					</xsl:if>
					<xsl:choose>
						<xsl:when test="contains(., 'of')">
							<para loc="02">
								<xsl:value-of select="substring-before(., 'of')" />
							</para>
						</xsl:when>
						<xsl:otherwise>
							<para loc="02">
								<xsl:value-of select="." />
							</para>
						</xsl:otherwise>
					</xsl:choose>
				    <para loc="02">
				        <xsl:processing-instruction name="xpp">lp;&amp;2q</xsl:processing-instruction>
				        <xsl:text>of the</xsl:text>
				    </para>
				    <para loc="02">
				        <xsl:processing-instruction name="xpp">lp;&amp;2q</xsl:processing-instruction>
				        <xsl:text>United States of America</xsl:text>
				    </para>
				</xsl:when>
				<xsl:otherwise>
					<para loc="41">
						<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
						<xsl:value-of select="text()" />
					</para>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
		
		<xsl:sequence select="gpo:outputComment('end congress')" />
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="session" as="item()*" mode="process">
		<xsl:sequence select="gpo:outputComment('session')" />
		<xsl:if test="not(@display = 'No') and string-length(text()) != 0">
			<xsl:choose>
				<xsl:when test="($docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-House' or $resstage = 'Enrolled-in-Senate')">
					<para loc="03">
						<xsl:sequence select="gpo:SessionTextAll(.)" />
					</para>
				</xsl:when>
				<xsl:otherwise>
					<para loc="42">
						<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
						<xsl:value-of select="text()" />
					</para>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="enrolled-dateline" as="item()*" mode="process">
		<xsl:sequence select="gpo:outputComment('start enrolled-dateline')" />
	
		<xsl:if test="not(@display = 'no')">
		    <!--Issue #111 - modified locator from 03 to 04-->
			<para loc="04"><xsl:sequence select="normalize-space(substring-before(., ', '))" />,<xsl:text> </xsl:text></para>
			<para loc="04"><xsl:sequence select="normalize-space(substring-after(., ', '))" /></para>
		</xsl:if>
		
		<xsl:sequence select="gpo:outputComment('end enrolled-dateline')" />
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="associated-doc" as="item()*" mode="process">
		<xsl:if test="not(@display = 'no')">
			<para loc="51">
				<xsl:value-of select="." />
			</para>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="associated-doc" mode="Final">
		<xsl:if test="not(@display = 'no') and not(//form/@display = 'no')">
			<para loc="40">
				<xsl:value-of select="." />
			</para>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="legis-type" as="item()*" mode="process">
		<xsl:choose>
			<xsl:when test="($docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-House' or $resstage = 'Enrolled-in-Senate')">
				<para loc="05">
					<xsl:value-of select="gpo:capFW(.)" />
				</para>
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="not($docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-in-Senate')       and not(contains($resstage, 'Engrossed')        and ($restype = 'house-resolution' or $restype = 'senate-resolution' or $restype = 'house-order' or $restype = 'senate-order'))">
					<para loc="48" />
					<xsl:if test="//pre-form">
						<command>Rule</command><!-- 10/27/2015 mharcourt Simplifed output from <xsl:text>&lt;command&gt;Rule;&lt;/command&gt;</xsl:text> -->
					</xsl:if><!-- 10/27/2015 mharcourt Fixed misplaced end xsl:if tag discovered during QC checking -->
					
					<xsl:choose>
						<xsl:when test="($resstage = 'Engrossed-in-Senate') and ($restype = 'house-resolution')" />
						<xsl:when test="$restype = 'house-order' or $restype = 'senate-order'" />
						<xsl:when test="lower-case(.) = 'concurrent resolution'">
							<para loc="49">
								<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
								<xsl:value-of select="." />
							</para>
						</xsl:when>
						<xsl:otherwise>
							<para loc="49">
								<xsl:value-of select="." />
							</para>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:choose>
						<xsl:when test="$resstage = 'Engrossed-House' and $restype = 'house-concurrent'" />
						<xsl:when test="$resstage = 'Engrossed-in-House' and $restype = 'house-concurrent'" />
						<xsl:when test="$resstage = 'Engrossed-in-Senate' and $restype = 'house-concurrent'" />
						<xsl:when test="$resstage = 'Engrossed-in-Senate' and $restype = 'senate-concurrent'" />
						<xsl:when test="$resstage = 'Engrossed-in-Senate' and $restype = 'house-resolution'" />
						<xsl:when test="$resstage = 'Engrossed-in-Senate' and $restype = 'senate-concurrent'" />
						<xsl:when test="not($resstage = 'Engrossed-in-Senate') or //pre-form">
							<xsl:call-template name="HidePart2" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:call-template name="HidePart2" />
						</xsl:otherwise>
					</xsl:choose>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="official-title" as="item()*" mode="process">
		<xsl:param name="noPageBreak" as="xs:string?" />
		<xsl:param name="openingStatementorEndors" as="xs:string?" />
		
		<xsl:choose>
			<xsl:when test="not(@display = 'no')">
				<xsl:choose>
					<xsl:when test="not($restype = 'house-concurrent')         and ($docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-House' or $resstage = 'Enrolled-in-Senate')">
						<para loc="11">
							<xsl:apply-templates mode="process" />
						</para>
						<xsl:if test="//resolution-body and not(//resolution/preamble)">
						    <xsl:processing-instruction name="xpp">lp;&amp;08q</xsl:processing-instruction>
						</xsl:if>
					</xsl:when>
					<xsl:when test="$restype = 'house-concurrent'          and ($docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-House' or $resstage = 'Enrolled-in-Senate')">
						<xsl:text />
					</xsl:when>
					<xsl:otherwise>
						<xsl:if test="$openingStatementorEndors != 'true'         and not($docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-in-Senate')         and not(contains($resstage, 'Engrossed') and ($restype = 'house-resolution' or $restype = 'senate-resolution' or $restype = 'house-order' or $restype = 'senate-order'))        and preceding-sibling::legis-type/@display = 'no'">
							<para loc="48" />
							
						</xsl:if>
						<para loc="53">
							<xsl:apply-templates mode="process" />
						</para>
						
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<para>
					<xsl:apply-templates mode="process" />
				</para>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="action" as="item()*" mode="process">
		
		<!-- TA: always returns yes or no. toPrintAnOpeningRuler needs to turn into a function instead of template -->
		<xsl:variable name="isOpeningRulerToBePrinted" as="xs:string">
			<xsl:call-template name="toPrintAnOpeningRuler" />
		</xsl:variable>
		
		<xsl:if test="$isOpeningRulerToBePrinted = 'yes'     and ((local-name(preceding-sibling::*[1]) = 'current-chamber' and preceding-sibling::current-chamber/@display = 'no')    or (local-name(preceding-sibling::*[2]) = 'current-chamber' and preceding-sibling::current-chamber/@display = 'no' and preceding-sibling::*[1]/action/@display = 'no'))    and not(lower-case($docstage) = 'engrossed-in-senate' and ancestor::*/@public-print = 'yes') and not($doctype = 'house-order' or $doctype = 'senate-order') and not($doctype = 'senate-resolution' and contains($docstage, 'Engrossed'))">
			<para loc="44" />
		</xsl:if>
		<xsl:if test="not(@display = 'no')">
			<xsl:choose>
				<xsl:when test="(lower-case($docstage) = 'engrossed-in-senate' or lower-case($docstage) = 'engrossed-amendment-senate') and (//bill/@public-print = 'yes' or //resolution/@public-print = 'yes')">
					<!-- Nothing in that case -->
				</xsl:when>
				<xsl:when test="($resstage = 'Engrossed-in-Senate' or $resstage = 'Engrossed-House' or $resstage = 'Engrossed-in-House') and ($restype = 'house-resolution' or $restype = 'house-order' or $restype = 'senate-order' or $restype = 'senate-resolution') and (not(./action-date/@display = 'no') and ./action-date)">
					<para loc="49">
						<xsl:value-of select="normalize-space(./action-date)" />
					</para>
					<xsl:if test="not(contains(./action-date, '.')) and normalize-space(./action-date) != ''">
						<xsl:value-of select="'.'" />
					</xsl:if>
					<xsl:if test="following::*[@section-type = 'ordered'] or $restype = 'house-order' or $restype = 'senate-order' or $restype = 'senate-order'">
					    <xsl:processing-instruction name="xpp">lp;&amp;04q</xsl:processing-instruction>
					</xsl:if>
				</xsl:when>
				<xsl:when test="($resstage = 'Engrossed-House' or $resstage = 'Engrossed-in-House') and (not(./action-date) or ./action-date/@display = 'no')" />
				<xsl:when test="$resstage = 'Engrossed-in-Senate' and (not(./action-date) or ./action-date/@display = 'no')" />
				<xsl:when test="($docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-House' or $resstage = 'Enrolled-in-Senate')" />
				<xsl:when test="$billstage = 'Printed-as-Passed'" />
				<xsl:otherwise>
					<xsl:if test="(not(./action-date/@display = 'no') and ./action-date)">
						<para loc="46">
						    <!-- fixes for issue #271 -->
						    <!-- add the stirng before the first space followed by the xpp fv1 PI -->
							<xsl:sequence select="normalize-space(substring-before(action-date, ' '))" />
							<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						    <!-- add the space -->
						    <xsl:text> </xsl:text>
							<!-- Add the rest of the string after the first space but add an xpp fv5 
							before any spelled-out month (January, February, etc.) -->
							<xsl:sequence select="gpo:ActionDateText(substring-after(action-date, ' '))" />
						    <!-- OLD CODE
							<xsl:sequence select="concat(' ', normalize-space(substring-after(action-date, ' ')))"/>
							-->
						</para>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:apply-templates mode="process" />
		</xsl:if>
	    <!-- comment out; doesn't exist in LXL code and the PI is inserted from processing legis-num -->
	   <!-- <xsl:if test="action-desc/pagebreak">
	            <xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>        
	    </xsl:if>-->
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="printActionDateForBills" as="item()*">
		<xsl:sequence select="gpo:outputComment('calling printActionDateForBills')" />
		
		<xsl:if test="(lower-case($docstage) = 'engrossed-in-senate' or lower-case($docstage) = 'engrossed-amendment-senate')     and (//bill/@public-print = 'yes' or //resolution/@public-print = 'yes')">
			<xsl:for-each select="//form/action">
				<xsl:if test="not(@display = 'no')">
					<xsl:choose>
						<xsl:when test="(position() = last() and count(//form/action) &gt; 1) or (count(//form/action) = 1)">
							<!-- nothing - not to print it is printed above -->
						</xsl:when>
						<xsl:otherwise>
							<xsl:if test="position() = 1">
								<para loc="44" />
							</xsl:if>
							<para loc="46">
								<xsl:value-of select="substring-before(action-date, ' ')" />
								<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
								
								<!-- TA: original code. this doesn't seem to be correct based on Upconversion output; replace with code below
								<xsl:sequence select="gpo:ActionDateText(string(./action-date))"/>
								-->
								<xsl:sequence select="concat(' ', normalize-space(substring-after(action-date, ' ')))" />
							</para>
							<xsl:if test="action-desc">
								<para loc="47">
									<xsl:value-of select="action-desc" />
								</para>
							</xsl:if>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:if>
			</xsl:for-each>
		</xsl:if>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="sponsor | cosponsor | nonsponsor" mode="process">
          <xsl:variable name="text" as="xs:string">
              <xsl:value-of select="normalize-space(.)" />
          </xsl:variable>	
		<xsl:choose>
			<xsl:when test="$text = ''" />
			<xsl:when test="/amendment-doc/@amend-type = 'house-amendment' and local-name(..) = 'action-desc'">
				<xsl:value-of select="." />
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="contains($text, ' of ')">
					<xsl:value-of select="substring-before($text, ' ')" />
				    <xsl:text> </xsl:text>
					<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:value-of select="substring-before(substring-after($text, ' '), ' of ')" />
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					<xsl:text> of </xsl:text>
					<xsl:value-of select="substring-after(substring-after($text, ' '), ' of ')" />
				</xsl:if>
				<xsl:if test="not(contains($text, ' of '))">
					<xsl:value-of select="substring-before($text, ' ')" />
				    <xsl:text> </xsl:text>
					<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:value-of select="substring-after($text, ' ')" />
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="preamble" as="item()*" mode="process">
		<xsl:choose>
			<xsl:when test="$docstage = 'Enrolled-Bill'        or $resstage = 'Enrolled-House'        or $resstage = 'Enrolled-in-Senate'">
				<para format="6501">
				    <xsl:processing-instruction name="xpp">lp;&amp;08q</xsl:processing-instruction>
					<xsl:apply-templates mode="process" />
				</para>
			</xsl:when>
			<xsl:when test="//committee-report and ancestor-or-self::amendment-block">
				<para format="6621" />
					<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:otherwise>
				<para format="6300" />
					<xsl:apply-templates mode="process" />
			</xsl:otherwise>
		</xsl:choose>
		
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="whereas" mode="process">

		<xsl:variable name="isPreceedingList" as="xs:string" select="gpo:IsPreceedingListElement(.)" />
	
		<xsl:if test="preceding-sibling::whereas[1]/text/pagebreak or $isPreceedingList = 'true'">
		    <xsl:processing-instruction name="xpp">lp;&amp;04q</xsl:processing-instruction>
		</xsl:if>
		<xsl:choose>
			<xsl:when test="$docstage = 'Enrolled-Bill'         or $resstage = 'Enrolled-House'         or $resstage = 'Enrolled-in-Senate'">
				<para format="6501" />
			</xsl:when>
			<xsl:when test="//committee-report and ancestor::amendment">
				<para format="6621" />
			</xsl:when>
			<xsl:otherwise>
				<para format="6300" />
			</xsl:otherwise>
		</xsl:choose>
		
		<xsl:choose>
			<xsl:when test="@reported-display-style = 'strikethrough' or @vbattChangedForReported = 'strikethrough'">
				
				<para loc="27">
					<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
					<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					<xsl:if test="@commented = 'yes'">
						<xsl:text>❨</xsl:text>
					</xsl:if>
				</para>
			</xsl:when>
			<xsl:when test="@reported-display-style = 'italic' or @vbattChangedForReported = 'italic'">
				<para loc="27">
					<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					<xsl:if test="@commented = 'yes'">
						<xsl:text>❨</xsl:text>
					</xsl:if>
				</para>
			</xsl:when>
			<xsl:when test="@reported-display-style = 'boldface-italic' or @vbattChangedForReported = 'boldface-italic'">
				<para loc="27">
					<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
					<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					<xsl:if test="@commented = 'yes'">
						<xsl:text>❨</xsl:text>
					</xsl:if>
				</para>
			</xsl:when>
			<xsl:when test="@reported-display-style = 'boldface-roman' or @vbattChangedForReported = 'boldface-roman'">
				<para loc="27">
					<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					<xsl:if test="@commented = 'yes'">
						<xsl:text>❨</xsl:text>
					</xsl:if>
				</para>
			</xsl:when>
			<xsl:when test="text/pagebreak and not(text/pagebreak/preceding-sibling::text())">
				<xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
			</xsl:when>
		    <!--Issue 114: embedded defaulting locator-->
		    <xsl:when test="not(@reported-display-style)">
		        <para loc="27">
		            <xsl:apply-templates mode="process" />
		        </para>
		    </xsl:when>
			<xsl:otherwise>
				<para loc="76">
					<xsl:if test="@commented = 'yes'">
						<xsl:text>❨</xsl:text>
					</xsl:if>
					<xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
				    <xsl:apply-templates mode="process" />
				</para>
			</xsl:otherwise>
		</xsl:choose>
		<!-- NB 6/21/2006 - The Q03 should only go out if it is an enrolled bill -->
		<xsl:if test="lower-case($docstage) = 'enrolled-bill'        or lower-case($resstage) = 'enrolled-house'        or lower-case($resstage) = 'enrolled-in-senate'">
		    <xsl:processing-instruction name="xpp">lp;&amp;03q</xsl:processing-instruction>
		</xsl:if>		
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="preamble/whereas/text" mode="process">
        <xsl:apply-templates />
        <xsl:if test="ancestor::quoted-block">
            <xsl:call-template name="calculateQuotedBlockEnd" />
        </xsl:if>
    </xsl:template><xsl:function xmlns:dc="http://purl.org/dc/elements/1.1" name="gpo:IsPreceedingListElement" as="xs:string">
		<xsl:param name="node" as="element()" />
		
		<xsl:sequence select="    if (($node/preceding-sibling::*[1]/list[position() = last()] or $node/preceding-sibling::*[1]/paragraph[position() = last()])      and not(contains(lower-case($docstage), 'enrolled'))) then 'true'    else 'false'" />
	</xsl:function><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="current-chamber" mode="process">
		<xsl:variable name="isOpeningRulerToBePrinted" as="xs:string?">
			<xsl:call-template name="toPrintAnOpeningRuler" />
		</xsl:variable>
		
		<xsl:choose>
			<xsl:when test="contains($docstage, 'Engrossed')">
				<xsl:if test="$isOpeningRulerToBePrinted = 'yes' and not(lower-case($docstage) = 'engrossed-in-senate' and //bill/@public-print = 'yes') and not($doctype = 'house-order' or $doctype = 'senate-order') and not($doctype = 'senate-resolution' and contains($docstage, 'Engrossed'))">
					<para loc="44" />
				</xsl:if>
				<xsl:if test="$restype = 'senate-resolution' or $restype = 'house-resolution' or $restype = 'house-order' or $restype = 'senate-order'">
					<para loc="02">
						<xsl:value-of select="." />
					</para>
					<xsl:if test="following::*[@section-type = 'ordered'] or $restype = 'house-order'">
					    <xsl:processing-instruction name="xpp">lp;&amp;12q</xsl:processing-instruction>
					</xsl:if>
					
				</xsl:if>
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="$gvLegisNumChamber = $gvStageChamber or $docstage = 'Pre-Introduction'">
					<para loc="30">
					    <!-- issue #73; process all nodes under official-title and not just text nodes since some
					        of these nodes might contain formatting, such as a <quote> element -->
					    <!--Issue #79: modified mode to 'inline' so that the extra paragraph from official-title
					        doesn't get included -->
					    <xsl:apply-templates select="//official-title" mode="inline" />
						<!--<xsl:apply-templates select="//official-title/text()" mode="process"/>-->
					</para>
				</xsl:if>
				<xsl:if test="not(contains($docstage, 'Enrolled'))">
					<para loc="44" />
					<xsl:if test="$resstage = 'Pre-Introduction'">
						<command>Rule</command><!-- 10/27/2015 mharcourt Simplifed output from <xsl:text>&lt;command&gt;Rule;&lt;/command&gt;</xsl:text> -->
					</xsl:if>
					<para loc="45">
						<xsl:value-of select="normalize-space(.)" />
					</para>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="official-title" mode="inline">
        <!-- issue #291 -->
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="legis-body" as="item()*" mode="process">
		<xsl:choose>
		    <xsl:when test="parent::amendment-block">
		        <xsl:apply-templates mode="process" />
		    </xsl:when>
			<xsl:when test="not($amendtype = 'conference-report')">
				
				<xsl:element name="para">
					<xsl:choose>
						<xsl:when test="./@reported-display-style = 'italic'">
							<xsl:attribute name="format" select="6203" />
						</xsl:when>
						<xsl:when test="./@reported-display-style = 'strikethrough'">
							<xsl:attribute name="format" select="6201" />
						</xsl:when>
						<xsl:when test="./@reported-display-style = 'boldface-roman'">
							<xsl:attribute name="format" select="6201" />
						</xsl:when>
						<xsl:when test="$docstage = 'Enrolled-Bill'         or $resstage = 'Enrolled-House'         or $resstage = 'Enrolled-in-Senate'">
							<xsl:attribute name="format" select="6501" />
							<xsl:attribute name="qcode" select="08" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:attribute name="format" select="6201" />
						</xsl:otherwise>
					</xsl:choose>
				</xsl:element>
			    
			    
			    <xsl:choose>
			        <xsl:when test="child::pagebreak">
			            <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Be it enacted by the Senate and House of Representa-<xsl:processing-instruction name="xpp">j</xsl:processing-instruction>tives of the United States of America in Congress assembled,
			            <xsl:if test="child::*[1]/@display-inline = 'yes-display-inline'"><xsl:text> </xsl:text>
			                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			            </xsl:if>
			            <xsl:if test="child::*[1]/name() = 'section' and section[1][@section-type='undesignated-section']                    and not(section[1]/enum) and not(section[1]/header)">
			                <xsl:apply-templates select="section[1]/text" mode="inline" />
			            </xsl:if>
			        </xsl:when>
			        <xsl:otherwise>
			            <xsl:if test="not(/amendment-doc) and not(child::pagebreak)">
			                <xsl:if test="@display-enacting-clause='yes-display-enacting-clause'  or  not (@display-enacting-clause) ">
			                    <xsl:if test="(string-length(//official-title) &gt; 270) ">
			                        <xsl:choose>
			                            <xsl:when test="starts-with($billstage,'Engrossed')">
			                                <xsl:if test="not(//official-title/pagebreak) or  ($restype='house-concurrent' or $restype='house-joint')">
			                                    <xsl:call-template name="pagebreak" />
			                                </xsl:if>
			                            </xsl:when>
			                            <xsl:when test="starts-with(//legis-num,'S') and($docstage='Referred-in-House' or $docstage='Received-in-House' or $docstage='Placed-on-Calendar-House')">
			                                <xsl:call-template name="pagebreak" />
			                            </xsl:when>
			                            <xsl:when test="starts-with(//legis-num,'H') and($docstage='Referred-in-Senate' or $docstage='Received-in-Senate' or $docstage='Placed-on-Calendar-Senate')">
			                                <xsl:call-template name="pagebreak" />
			                            </xsl:when>
			                        </xsl:choose>
			                    </xsl:if>
			                    <xsl:call-template name="insertPageBreakBeforeEnactingClause" />
			                    <xsl:element name="para">
      			                    <xsl:if test="ancestor-or-self::amendment-block/ancestor::committee-report-segment or ancestor-or-self::amendment-block/ancestor::committee-report-part">
      			                       <xsl:attribute name="format" select="6621" />                                                                                                                        
      			                    </xsl:if>
			                        <xsl:attribute name="loc" select="20" />
			                        <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Be it enacted by the Senate and House of Representa-<xsl:processing-instruction name="xpp">j</xsl:processing-instruction>tives of the United States of America in Congress assembled,<!--<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>-->
       			                    <xsl:if test="child::*[1]/@display-inline = 'yes-display-inline'"><xsl:text> </xsl:text>
       			                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
       			                    </xsl:if>
			                        <!--Issue #348-->
			                        <xsl:if test="child::*[1]/name() = 'section' and section[1][@section-type='undesignated-section']                                and not(section[1]/enum) and not(section[1]/header)">
			                            <xsl:apply-templates select="section[1]/text" mode="inline" />
			                        </xsl:if>
       			                    <xsl:if test="not(string-length(//official-title) &gt; 270) and not(preceding::pagebreak)">
       			                        <xsl:choose>
       			                            <xsl:when test="starts-with(//legis-num,'S') and (( contains($docstage,'Engrossed')  or $docstage='Referred-in-House' or $docstage='Received-in-House' or $docstage='Placed-on-Calendar-House'))">
       			                                <xsl:if test="not(//section[1]/@section-type='undesignated-section') ">
       			                                    <xsl:call-template name="pagebreak" />
       			                                </xsl:if>
       			                            </xsl:when>
       			                            <xsl:when test="starts-with(//legis-num,'H') and ((contains($docstage,'Engrossed')  or $docstage='Referred-in-Senate' or $docstage='Received-in-Senate' or $docstage='Placed-on-Calendar-Senate'))">
       			                                <xsl:if test="not(//section[1]/@section-type='undesignated-section') ">
       			                                    <xsl:call-template name="pagebreak" />
       			                                </xsl:if>
       			                            </xsl:when>
       			                        </xsl:choose>
       			                    </xsl:if>
			                     </xsl:element>
			                </xsl:if>
			                </xsl:if>
			        </xsl:otherwise>
			    </xsl:choose>
			    
			    
			    
<!--					<xsl:choose>
						<xsl:when test="child::pagebreak">
						    <!-\- issue #87. remove the xpp qj PI -\->
							<para loc="20">
							    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>&#x2003;&#x2003;Be it enacted by the Senate and House of Representa&#x2d;<xsl:processing-instruction name="xpp">j</xsl:processing-instruction>tives of the United States of America in Congress assembled,<!-\-<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>-\->
								<xsl:if test="child::*[1]/@display-inline = 'yes-display-inline'"><xsl:text> </xsl:text>
									<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
								</xsl:if>
							    <!-\-Issue #348-\->
							    <xsl:if test="child::*[1]/name() = 'section' and section[1][@section-type='undesignated-section']
							        and not(section[1]/enum) and not(section[1]/header)">
							        <xsl:apply-templates select="section[1]/text" mode="inline"/>
							    </xsl:if>
							    <!-\- fixes issue #442 and undoes issue #53. According to Deb, the PI should be inside the para element -\->
							    <xsl:if test="$billstage='Referred-in-Senate' or $billstage = 'Placed-on-Calendar-Senate'
							        or $billstage='Engrossed-in-Senate'">
							        <xsl:processing-instruction name="xpp">eb</xsl:processing-instruction>
							    </xsl:if>
							</para>
						    <!-\- issue #53. the PI should be outside the para element -\->
						    <!-\-<xsl:if test="$billstage='Referred-in-Senate' or $billstage = 'Placed-on-Calendar-Senate'
						        or $billstage='Engrossed-in-Senate'">
						        <xsl:processing-instruction name="xpp">eb</xsl:processing-instruction>
						    </xsl:if>-\->
						</xsl:when>
						<xsl:otherwise>
							<xsl:if test="not(/amendment-doc) and not(child::pagebreak)">
								<xsl:if test="@display-enacting-clause = 'yes-display-enacting-clause' or not(@display-enacting-clause)">
									<xsl:if test="(string-length(//official-title) > 270)">
										<xsl:choose>
											<xsl:when test="starts-with($billstage, 'Engrossed')">
												<xsl:if test="not(//official-title/pagebreak) or ($restype = 'house-concurrent' or $restype = 'house-joint')">
													<xsl:call-template name="pagebreak"/>
												</xsl:if>
											</xsl:when>
											<xsl:when
												test="starts-with(//legis-num, 'S') 
												and ($docstage = 'Referred-in-House' or $docstage = 'Received-in-House' or $docstage = 'Placed-on-Calendar-House')">
												<xsl:call-template name="pagebreak"/>
											</xsl:when>
											<xsl:when
												test="starts-with(//legis-num, 'H') and ($docstage = 'Referred-in-Senate' or $docstage = 'Received-in-Senate' or $docstage = 'Placed-on-Calendar-Senate')">
												<xsl:call-template name="pagebreak"/>
											</xsl:when>
										</xsl:choose>
									</xsl:if>
									<xsl:call-template name="insertPageBreakBeforeEnactingClause"/>
									<xsl:element name="para">
									<xsl:if
										test="ancestor-or-self::amendment-block/ancestor::committee-report-segment or ancestor-or-self::amendment-block/ancestor::committee-report-part">
										<xsl:attribute name="format" select="6621"/>
									</xsl:if>
									<xsl:attribute name="loc" select="20"/>
									    <!-\- issue #87. remove the xpp qj PI -\->
									    <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>&#x2003;&#x2003;Be it enacted by the Senate and House of Representa&#x2d;<xsl:processing-instruction name="xpp">j</xsl:processing-instruction>tives of the United States of America in Congress assembled,
									    <!-\-<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>-\->
									<xsl:if test="child::*[1]/@display-inline = 'yes-display-inline'"><xsl:text> </xsl:text>
										<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
									</xsl:if>
									    <!-\-Issue #348-\->
									    <xsl:if test="child::*[1]/name() = 'section' and section[1][@section-type='undesignated-section']
									        and not(section[1]/enum) and not(section[1]/header)">
									        <xsl:apply-templates select="section[1]/text" mode="inline"/>
									    </xsl:if>
									    <!-\- fixes issue #442 and undoes issue #53. According to Deb, the PI should be inside the para element -\->
									    <xsl:if test="$billstage='Referred-in-Senate' or $billstage = 'Placed-on-Calendar-Senate'
									        or $billstage='Engrossed-in-Senate'">
									        <xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>
									    </xsl:if>
									</xsl:element>
								    <!-\-
								    <xsl:choose>
								        <xsl:when test="$billstage = 'Enrolled-Bill'"/>
								        <xsl:when test="$billstage = 'Reference-Change-Senate'"/>
								        <xsl:when test="$billstage = 'Introduced-in-House'"></xsl:when>
								        <xsl:otherwise><xsl:processing-instruction name="xpp">ep</xsl:processing-instruction></xsl:otherwise>
								    </xsl:choose> -\->
								    <!-\-Issue #53:  Moved 'xsl:if' to outside paragraph element -\->
								   <!-\- <xsl:if test="$billstage='Referred-in-Senate' or $billstage = 'Placed-on-Calendar-Senate'
								        or $billstage='Engrossed-in-Senate'">
								        <xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>
								    </xsl:if>-\->
									<xsl:if test="not(string-length(//official-title) > 270) and not(preceding::pagebreak)">
										<xsl:choose>
											<xsl:when test="starts-with(//legis-num, 'S') and 
											                 ((contains($docstage, 'Engrossed') or $docstage = 'Referred-in-House' or $docstage = 'Received-in-House' or $docstage = 'Placed-on-Calendar-House'))">
												<xsl:if test="not(//section[1]/@section-type = 'undesignated-section')">
												    <!-\- issue #170. Remove the page break (xpp ep) PI  per Deb's instruction -\->
												    <xsl:call-template name="pagebreak"/>
												</xsl:if>
											</xsl:when>
											<xsl:when test="starts-with(//legis-num, 'H') and 
											                 ((contains($docstage, 'Engrossed') or $docstage = 'Referred-in-Senate' or $docstage = 'Received-in-Senate' or $docstage = 'Placed-on-Calendar-Senate'))">
												<xsl:if test="not(//section[1]/@section-type = 'undesignated-section')">
												    <!-\- issue #40 -\->
												    <!-\- issue #170. Remove the page break (xpp ep) PI  per Deb's instruction -\->
													<xsl:call-template name="pagebreak"/>
												</xsl:if>
											</xsl:when>
										</xsl:choose>
									</xsl:if>
								</xsl:if>
							</xsl:if>
						</xsl:otherwise>
					</xsl:choose>
			-->	
				<xsl:if test="attribute::changed">
					<xsl:element name="para">
						<xsl:choose>
							<xsl:when test="./@reported-display-style = 'italic'">
								<xsl:choose>
									<xsl:when test="ancestor::amendment-block[@line-numbers = 'off']">
										<xsl:attribute name="format" select="6303" />
									</xsl:when>
									<xsl:otherwise>
										<xsl:attribute name="format" select="6203" />
									</xsl:otherwise>
								</xsl:choose>
							</xsl:when>
							<xsl:when test="./@reported-display-style = 'strikethrough'">
								<xsl:attribute name="format" select="6401" />
							</xsl:when>
							<xsl:when test="./@reported-display-style = 'boldface-roman'">
								<xsl:attribute name="format" select="6202" />
							</xsl:when>
							<xsl:when test="($docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-House' or $resstage = 'Enrolled-in-Senate')">
								<xsl:attribute name="qcode" select="08" />
								<xsl:attribute name="format" select="6501" />
							</xsl:when>
						</xsl:choose>
					</xsl:element>
				</xsl:if>
				
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates mode="process" />
			</xsl:otherwise>
		</xsl:choose>	
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="appropriations-major/text | appropriations-intermediate/text | appropriations-small/text" mode="process">
        <para loc="20"><xsl:text>  </xsl:text><xsl:apply-templates mode="process" /></para>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="appropriations-small/header" mode="process">
	    <para loc="74">
	        <!--Issue #358 - The wrong format was being output-->
	        <xsl:choose>
	        <xsl:when test="@vbattChangedForReported = 'italic'">
	            <xsl:attribute name="format">6203</xsl:attribute>
	        </xsl:when>
	            <xsl:otherwise><xsl:attribute name="format">6201</xsl:attribute>
	            </xsl:otherwise>
	        </xsl:choose>
	        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
	        <xsl:apply-templates mode="AllLower" />
	    </para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="appropriations-major" mode="process">
	    <xsl:if test="header">
	        <para loc="74"> <xsl:apply-templates select="header" mode="AllCaps" /></para>
	    </xsl:if>
	   <xsl:apply-templates select="* except header" mode="process" />
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="appropriations-intermediate" mode="process">
        <xsl:if test="header">
            <para loc="74"> <xsl:apply-templates select="header" mode="InitialCaps" /></para>
        </xsl:if>
        <xsl:apply-templates select="* except header" mode="process" /> 
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="prepareProcessedContent">
		<xsl:param name="notToTurnUpper" as="xs:string" />
		<xsl:param name="origContent" as="xs:string" />
		
		<!-- tassos: rewrite the whole thing to use the new gpo:TocEntry() function that takes an extra boolean parameter to
			indicate whether the string should be turn to upper case or not -->
		
		<!-- turn the string into a boolean -->
		<xsl:variable name="doUpper" as="xs:boolean" select="    if ($notToTurnUpper = 'true') then false()    else true()" />
		
		<xsl:choose>
			<xsl:when test="starts-with($origContent, 'Sec')">
				<xsl:value-of select="gpo:TocEntry($origContent, $doUpper)" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="gpo:TocEntry(normalize-space($origContent), $doUpper)" />
			</xsl:otherwise>
		</xsl:choose>
		
		<!--
			<xsl:variable name="preProcessedContennt" as="xs:string">
			<xsl:if test="$notToTurnUpper = 'true'">
			<xsl:value-of select="concat('notTurnToUpperCase', $origContent)"/>
			</xsl:if>
			<xsl:if test="not($notToTurnUpper = 'true')">
			<xsl:value-of select="$origContent"/>
			</xsl:if>
			</xsl:variable>
			<xsl:choose>
			<xsl:when test="starts-with(., 'Sec')">
			<xsl:value-of         
			select="gpo:TocEntry(string($preProcessedContennt))"/>
			</xsl:when>
			<xsl:otherwise>
			<xsl:value-of         
			select="gpo:TocEntry(normalize-space($preProcessedContennt))"/>
			</xsl:otherwise>
			</xsl:choose>
		-->
		<!--New rule.  we need to always send this to the function TocEntry() -->
		
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="printEndorsement">
        <xsl:variable name="isAmendment" as="xs:string?">
            <xsl:choose>
                <xsl:when test="contains(local-name(),  'amendment')">
                    <xsl:text>Yes</xsl:text>
                </xsl:when>
                <xsl:when test="contains(preceding::*/local-name(), 'amendment')">
                    <xsl:text>Yes</xsl:text>
                </xsl:when>
                <xsl:when test="contains(following::*/local-name(), 'amendment')">
                    <xsl:text>Yes</xsl:text>
                </xsl:when>
                <!--	<xsl:when
					test="contains(local-name(ancestor-or-self::*), 'amendment') or contains(local-name(descendant-or-self::*), 'amendment')">
					<xsl:text>Yes</xsl:text>
				</xsl:when>-->
                <xsl:otherwise>
                    <xsl:text>No</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <para format="6651" />
        <xsl:if test="//endorsement and not(//endorsement[@display = 'no'])">
            <xsl:processing-instruction name="xpp">ep</xsl:processing-instruction>
            <xsl:processing-instruction name="xpp">ps;2</xsl:processing-instruction>
            <xsl:if test="//first-page-header/text() != '' and //first-page-header and ((not(//first-page-header/@display = 'no') and not(//form/@display = 'no')))">
                <para loc="34">
                    <xsl:value-of select="//first-page-header" />
                </para>	
            </xsl:if>
            <xsl:if test="//calendar">
                <xsl:if test="(not(//calendar/@display = 'no') and not(//form/@display = 'no')) and $isAmendment = 'No'"> 
                    <para loc="35">
                        <xsl:value-of select="substring-before(//calendar, 'No.')" />
                        <xsl:text>No. </xsl:text>
                        <xsl:processing-instruction name="xpp">ff;4</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                        <xsl:value-of select="substring-after(//calendar, 'No. ')" />
                    </para>
                </xsl:if>
            </xsl:if>
            <xsl:if test="(not(//congress/@display = 'no') and not(//form/@display = 'no') or $isAmendment = 'Yes') and string-length(//congress/text()) != 0 and not($billstage = 'Enrolled-Bill')">
                <para loc="41">
                    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                    <xsl:value-of select="//congress/text()" />
                </para>	
            </xsl:if>
            <xsl:if test="(not(//session/@display = 'no') and not(//form/@display = 'no') or $isAmendment = 'Yes') and string-length(//session/text()) != 0 and not($billstage = 'Enrolled-Bill')">
                <para loc="42">
                    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                    <xsl:value-of select="//session/text()" />
                </para>
            </xsl:if>
            <!-- Changed bunch of if to Choose statement 102406 -->
            <!-- SM 1/9/2007 space is interduced between the text in I43 -->
            <xsl:variable name="I43" as="xs:string">
                <xsl:value-of select="normalize-space(lower-case(substring-before(substring-after(//engrossed-amendment-body/section/text, '('), ')')))" />
                
            </xsl:variable>
            <!--BH:  Added legis-num because it wasn't getting output-->
            <para loc="43">
                <xsl:processing-instruction name="xpp">tj;11</xsl:processing-instruction>
                <xsl:value-of select="//legis-num" />
            </para>
            <xsl:if test="//associated-doc and (not(//associated-doc/@display = 'no') and not(//form/@display = 'no') and $isAmendment = 'No')">
                <xsl:apply-templates mode="Final" select="//associated-doc" />
            </xsl:if>
            <xsl:if test="not($billstage = 'Enrolled-Bill')">
                <para loc="44" />
            </xsl:if>
            <xsl:choose>
                <xsl:when test="(//legis-type/@display = 'no' or //form/@display = 'no') and $isAmendment = 'No'">
                    <!-- nothing -->
                </xsl:when>
                <!--if Enrolled Bill then do not print anything here-->
                <xsl:when test="$billstage = 'Enrolled-Bill'">
                    <xsl:text />
                </xsl:when>
                <xsl:otherwise>
                    <para loc="45">
                        <xsl:choose>
                            <xsl:when test="string-length(//legis-type) &gt; 20">
                                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>	
                            </xsl:when>
                            <xsl:otherwise />
                        </xsl:choose> 	
                        <xsl:choose>
                            <xsl:when test="(//legis-type/@display = 'no' or //form/@display = 'no') and $isAmendment = 'No'">
                                <!-- nothing -->
                            </xsl:when>
                            <xsl:when test="contains(//legis-type, ':') and //amendment-doc">
                                <xsl:value-of select="upper-case(substring-before(//legis-type, ':'))" />
                            </xsl:when>
                            <xsl:when test="contains(//legis-type, ':')">
                                <xsl:value-of select="substring-before(//legis-type, ':')" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="//legis-type" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </para>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="//official-title">
                <xsl:if test="(not(//official-title/@display = 'no') and not(//form/@display = 'no')) and $isAmendment = 'No'">
                    <xsl:if test="not($billstage = 'Enrolled-Bill')">
                        <para loc="37">
                            <!--BH:  Commenting this out because it is putting double paragraphs.-->
                            <!--<xsl:apply-templates select="//official-title">
								<xsl:with-param name="noPageBreak">
									<xsl:text>true</xsl:text>
								</xsl:with-param>
								<xsl:with-param name="openingStatementorEndors">
									<xsl:text>true</xsl:text>
								</xsl:with-param>
							</xsl:apply-templates>-->
                            <xsl:value-of select="//official-title" /> 
                        </para>
                    </xsl:if>
                </xsl:if>
                <xsl:if test="(//official-title/@display = 'no')">
                    <xsl:variable name="printOficialTitleInEndorsment" as="xs:string?">
                        <xsl:call-template name="toPrintOficialTitleInEndorsment" />
                    </xsl:variable>
                    <xsl:if test="string-length(//official-title) &gt; 0 and ($printOficialTitleInEndorsment = 'yes')">
                        <para loc="37">
                            <xsl:apply-templates select="//official-title" mode="dispalyno" />
                        </para>
                    </xsl:if>
                </xsl:if>
            </xsl:if>
            <xsl:if test="//endorsement/action-date">
                <xsl:if test="not(//endorsement/@display = 'no')">
                    <para loc="48" />
                    <xsl:for-each select="//endorsement/action-date">
                        <!-- TB 2-Oct-2008  -->
                        <xsl:choose>
                            <xsl:when test="lower-case($docstage) = 'engrossed-in-senate' or $docstage = 'engrossed-amendment-senate' and (//bill/@public-print = 'yes' or //resolution/@public-print = 'yes')">
                                <xsl:call-template name="ActualPrintEndorsmentActionForPP" />
                            </xsl:when>
                            <xsl:when test="/amendment-doc[@public-print = 'yes' and @amend-type = 'engrossed-amendment'] and contains(//current-chamber, 'Senate')">
                                <xsl:call-template name="ActualPrintEndorsmentActionForPP" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:call-template name="ActualPrintEndorsmentAction" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:for-each>
                </xsl:if>
            </xsl:if>
        </xsl:if>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="isLowLevelStructure" as="xs:string">
        <xsl:choose>
            <xsl:when test="ancestor-or-self::header-in-text and (contains(ancestor-or-self::header-in-text/@level, 'paragraph') or  contains(ancestor-or-self::header-in-text/@level, 'clause') or contains(ancestor-or-self::header-in-text/@level, 'item'))">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor-or-self::subparagraph">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor-or-self::clause">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor-or-self::subclause">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor-or-self::item">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor-or-self::subitem">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="ancestor-or-self::rules-subparagraph or  ancestor-or-self::rules-subdivision  or ancestor-or-self::rules-item or ancestor-or-self::rules-subitem">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="getBegginingOfThePhraseLiseOff">
		<xsl:param name="aBeginingFor" as="xs:string" />
		<xsl:param name="aReportingStyle" as="xs:string" />
		<xsl:param name="aStyle" as="xs:string" />
		<xsl:choose>
			<xsl:when test="$aBeginingFor='enumText' and $aReportingStyle='strikethrough'">
				<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='enumText' and $aReportingStyle='boldface-roman'">
				<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='enumText' and $aReportingStyle='boldface-italic'">
				<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='enumNumber' and $aReportingStyle='strikethrough'">
				<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='enumNumber' and $aReportingStyle='boldface-roman'">
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='enumNumber' and $aReportingStyle='boldface-italic'">
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='text' and $aReportingStyle='strikethrough'">
				<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='text' and $aReportingStyle='boldface-roman'">
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='text' and $aReportingStyle='boldface-italic'">
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
			</xsl:when>
			<xsl:otherwise />
		</xsl:choose>	
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="getEndOfThePhraseLiseOff">
		<xsl:param name="aBeginingFor" as="xs:string" />
		<xsl:param name="aReportingStyle" as="xs:string" />
		<xsl:param name="aStyle" as="xs:string" />		
		<!-- for now aStyle not in use -->
		<xsl:choose>				
			<xsl:when test="$aBeginingFor='enumText' and $aReportingStyle='boldface-roman'">
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='enumText' and $aReportingStyle='boldface-italic'">
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$aBeginingFor='enumNumber' and $aReportingStyle='strikethrough'">
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>			
			<xsl:when test="$aBeginingFor='enumNumber' and $aReportingStyle='boldface-italic'">
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>			
			<xsl:otherwise>
				<xsl:text />
			</xsl:otherwise>
		</xsl:choose>
		
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="lowerCaseExceptEnumInHeader">
		<xsl:param name="aHeaderText" />
		<xsl:variable name="secondSeparator" as="xs:string">
			<xsl:choose>
				<xsl:when test="matches($aHeaderText, '[^&lt;]*&lt;\?xpp fv;1\s*\?&gt;') and matches($aHeaderText, '[^&lt;]*&lt;\?xpp fv;T\s*\?&gt;')">
					<xsl:processing-instruction name="xpp">fv:T</xsl:processing-instruction>
				</xsl:when>
				<xsl:when test="matches($aHeaderText, '[^&lt;]*&lt;\?xpp fv;1\s*\?&gt;') and matches($aHeaderText, '[^&lt;]*&lt;\?xpp fv;T\s*\?&gt;')">
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>NotDefined</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
			
		</xsl:variable>		
		<xsl:choose>
			<xsl:when test="$secondSeparator='NotDefined'">
				<xsl:value-of select="lower-case($aHeaderText)" />
			</xsl:when>			
			<xsl:otherwise>
				<xsl:variable name="firstPartStr" select="lower-case(replace($aHeaderText,'([^&lt;]+)(&lt;\?xpp fv;1\s*\?&gt;.*)','$1'))" as="xs:string" /> 
				<xsl:variable name="lastPartStr" as="xs:string">
					<xsl:value-of select="lower-case(substring-after($aHeaderText,$secondSeparator))" />
				</xsl:variable>				
				<xsl:variable name="enumInHeaderValue" select="substring-before(substring-after ($aHeaderText , '&lt;?xpp fv;T ?&gt;'),$secondSeparator)" as="xs:string" />			
				<xsl:variable name="middlePartStr" select="concat(concat('&lt;?xpp fv;1?',$enumInHeaderValue),$secondSeparator)" as="xs:string" />		
				<xsl:value-of select="concat(concat($firstPartStr,$middlePartStr),$lastPartStr)" />
			</xsl:otherwise>
		</xsl:choose>	
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="GenerateEmDash" as="xs:string">
        <xsl:param name="IsForFollowingSibling" as="xs:string" />
    	<xsl:param name="currentStyle" as="xs:string" />
    	<xsl:variable name="node" select="." as="item()" />
        <xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
        <xsl:variable name="IAmInLowLevelStructure" as="item()">
            <xsl:call-template name="isLowLevelStructure" />
        </xsl:variable>
    	<xsl:variable name="style" as="xs:string">
            <xsl:choose>
                <xsl:when test="not($currentStyle='')">
                    <xsl:value-of select="$currentStyle" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable> 
    	<xsl:variable name="isNoTextBefore" as="xs:string">
            <xsl:call-template name="NoTextBefore">
                <xsl:with-param name="aCurrentText" select="." />
            </xsl:call-template>	
        </xsl:variable>   
    	<xsl:variable name="isInRamseyerGenerate" as="item()*">
            <xsl:call-template name="isRamseyerGenerateOn" />
        </xsl:variable>    
    	<xsl:variable name="isInCordonGenerate" as="item()*">
            <xsl:call-template name="isInCordonGenerateOn" />
        </xsl:variable>
        
        <xsl:choose>
            <xsl:when test="$isInRamseyerGenerate = 'no'  and ($IAmInLowLevelStructure='yes' or local-name(ancestor::*[1] )= 'section') ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="$isInCordonGenerate = 'no' and ($IAmInLowLevelStructure='yes' or local-name(ancestor::*[1] )= 'section') ">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="$IsForFollowingSibling = 'true'  and (string(parent::header)!='' and not(parent::header[@display-inline='no-display-inline']) and (not(ancestor::section[1]/@level-type='undesignated') or (ancestor::section[1]/@level-type='undesignated' and string(ancestor::section[1]/enum) !=''))) and $isNoTextBefore='true'"> 
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="string(./header)!='' and not(./header[@display-inline='no-display-inline']) and (not(./@level-type='undesignated') or (./@level-type='undesignated' and string(./enum) !=''))"> 
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$IsForFollowingSibling = 'true' and ancestor::section and $style = 'nuclear' and (parent::header or parent::text) and $isNoTextBefore='true'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="local-name()='section' and $style = 'nuclear' and (./header or ./text)">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$IsForFollowingSibling = 'true' and ancestor::subsection and not (contains($style, 'archaic')) and (parent::header or parent::text) and $isNoTextBefore='true'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="local-name()='subsection' and not (contains($style, 'archaic')) and (./header or ./text)">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$IsForFollowingSibling = 'true' and ancestor::paragraph and not ($style = 'archaic-paragraph') and (parent::header or parent::text) and $isNoTextBefore='true'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="local-name()='paragraph' and not ($style = 'archaic-paragraph') and (./header or ./text)">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$IsForFollowingSibling = 'true' and  ancestor::instruction-paragraph and (parent::header or parent::text) and $isNoTextBefore='true'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="local-name()='instruction-paragraph' and (./header or ./text)">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$IsForFollowingSibling = 'true' and  ancestor::instruction-subparagraph and (parent::header or parent::text) and $isNoTextBefore='true'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="local-name()='instruction-subparagraph' and (./header or ./text)">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="parent::section and $style='traditional-inline'  and following-sibling::*">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="$IsForFollowingSibling = 'true' and $IAmInLowLevelStructure='yes' and (parent::header or parent::text) and $isNoTextBefore='true'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test=" $IAmInLowLevelStructure='yes' and (./header or ./text) and $isNoTextBefore='true'">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>false</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="isRamseyerGenerateOn" as="xs:string?">
        <xsl:choose>
            <xsl:when test="not(ancestor::ramseyer)">
                <!-- nothing -->
            </xsl:when>
            <xsl:when test="ancestor::ramseyer and ancestor::ramseyer/@generated-text ='on'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="isInCordonGenerateOn" as="xs:string?">
        <xsl:choose>
            <xsl:when test="not(ancestor::cordon)" />
            <xsl:when test="ancestor::cordon and ancestor::cordon/@generated-text ='off'">
                <xsl:text>no</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>yes</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="OpeningSectionTemplate">
		<xsl:param name="aToPrintLevelLocator" as="xs:string" />
		<xsl:param name="aLevelLocator" />			
		
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:if test="$aToPrintLevelLocator='yes' ">
			<xsl:value-of select="$aLevelLocator" />
		</xsl:if>
		
		<xsl:choose>
			<xsl:when test="string-length(./enum)+string-length(./header)+string-length(./text) = 0">
				<xsl:text />
			</xsl:when>
			<xsl:otherwise>				
				<xsl:if test="$isCommented='yes' ">❨</xsl:if>
				<xsl:if test="contains(@vbattChangedForReported,'brackets')">❨</xsl:if>      	
				<xsl:if test="contains(@vbattChangedForReported,'parentheses')">【</xsl:if>				
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="$inQuotedBlock='yes'">
			<!--Issue #69-->
			<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
			<!--<xsl:call-template name="QuotedBlockNestingStart"/>-->
		</xsl:if>		
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="printGeneratedSectionWord">
		<xsl:param name="aSectionOnePhrase" />
		<xsl:param name="aUndesignatedPhrase" />
		<xsl:param name="aResolvedPhrase" />
		<xsl:param name="aDefaultPhrase" />		
		<xsl:choose>
			<xsl:when test="@section-type='section-one'">
				<xsl:value-of select="$aSectionOnePhrase" />
			</xsl:when>
			<xsl:when test="@section-type='resolved'">
				<xsl:value-of select="$aResolvedPhrase" />
			</xsl:when>
			<xsl:when test="@section-type='undesignated-section'">
				<xsl:value-of select="$aUndesignatedPhrase" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$aDefaultPhrase" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="IsSectionFirstInBlockUndesignated" as="xs:string">
		<xsl:choose>			
			<xsl:when test="@section-type != 'undesignated-section' or not(@section-type)">
				<xsl:text>no</xsl:text>
			</xsl:when>
			<xsl:when test="parent::amendment-block and not(preceding-sibling::*)">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:when test="parent::resolution-body/@display-resolving-clause='no-display-resolving-clause' and not(preceding-sibling::*)">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:when test="parent::legis-body/@display-enacting-clause='no-display-enacting-clause' and not(preceding-sibling::*)">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>no</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="ToInsertendingCorrectionLine" as="xs:string?">
		<xsl:param name="inputLevelLocator" as="xs:string?" />
		<xsl:variable name="IAmALastSibling" as="xs:string">
			<xsl:call-template name="iAmALastSiblingNoQoutedBlock" />
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="not(contains($inputLevelLocator,'I72' )  or contains($inputLevelLocator,'I75' ))">
				<xsl:text>false</xsl:text>
			</xsl:when>
			<xsl:when test="ancestor::quoted-block">
				<xsl:text>false</xsl:text>
			</xsl:when>
			<xsl:when test="not ((header and not(header/following-sibling::*)) or (enum and not (enum/following-sibling::*)))">
				<xsl:text>false</xsl:text>
			</xsl:when>
			<xsl:when test="not($IAmALastSibling = 'true')">
				<xsl:text>false</xsl:text>
			</xsl:when>
			<!--Check for allmark-->
			<xsl:when test="not(//pre-form) and not (//amendment-doc or $docstage='Pre-Introduction' or contains($docstage,'Enrolled')) and not(//attestation) and not(//endorsement)">
				<xsl:text>false</xsl:text>
			</xsl:when>
			<!-- check parent big heads -->
			<xsl:when test="parent::subpart and (((parent::subpart/header and not(parent::subpart/header/following-sibling::*)) or (parent::subpart/enum and not (parent::subpart/enum/following-sibling::*))))">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="parent::part and (((parent::part/header and not(parent::part/header/following-sibling::*)) or (parent::part/enum and not (parent::part/enum/following-sibling::*))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="parent::subchapter and (((parent::subchapter/header and not(parent::subchapter/header/following-sibling::*)) or (parent::subchapter/enum and not (parent::subchapter/enum/following-sibling::*))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="parent::chapter and (((parent::chapter/header and not(parent::chapter/header/following-sibling/text)) or (parent::chapter/enum and not (parent::chapter/enum/following-sibling/text))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="parent::subtitle and (((parent::subtitle/header and not(parent::subtitle/header/following-sibling/text)) or (parent::subtitle/enum and not (parent::subtitle/enum/following-sibling/text))))">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="parent::title and (((parent::title/header and not(parent::title/header/following-sibling/text)) or (parent::title/enum and not (parent::title/enum/following-sibling/text))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>			
			<xsl:when test="parent::subdivision and (((parent::subdivision/header and not(parent::subdivision/header/following-sibling/text)) or (parent::subdivision/enum and not (parent::subdivision/enum/following-sibling/text))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="parent::division and (((parent::division/header and not(parent::division/header/following-sibling/text)) or (parent::division/enum and not (parent::division/enum/following-sibling/text))))">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<!-- check preceeding sibling  big heads -->
			<xsl:when test="preceding-sibling::*[1]/subpart and (((preceding-sibling::*[1]/subpart/header and not(preceding-sibling::*[1]/subpart/header/following-sibling::*)) or (preceding-sibling::*[1]/subpart/enum and not (preceding-sibling::*[1]/subpart/enum/following-sibling::*))))">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="preceding-sibling::*[1]/part and (((preceding-sibling::*[1]/part/header and not(preceding-sibling::*[1]/part/header/following-sibling::*)) or (preceding-sibling::*[1]/part/enum and not (preceding-sibling::*[1]/part/enum/following-sibling::*))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="preceding-sibling::*[1]/subchapter and (((preceding-sibling::*[1]/subchapter/header and not(preceding-sibling::*[1]/subchapter/header/following-sibling::*)) or (preceding-sibling::*[1]/subchapter/enum and not (preceding-sibling::*[1]/subchapter/enum/following-sibling::*))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="preceding-sibling::*[1]/chapter and (((preceding-sibling::*[1]/chapter/header and not(preceding-sibling::*[1]/chapter/header/following-sibling::*)) or (preceding-sibling::*[1]/chapter/enum and not (preceding-sibling::*[1]/chapter/enum/following-sibling::*))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="preceding-sibling::*[1]/subtitle and (((preceding-sibling::*[1]/subtitle/header and not(preceding-sibling::*[1]/subtitle/header/following-sibling::*)) or (preceding-sibling::*[1]/subtitle/enum and not (preceding-sibling::*[1]/subtitle/enum/following-sibling::*))))">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="preceding-sibling::*[1]/title and (((preceding-sibling::*[1]/title/header and not(preceding-sibling::*[1]/title/header/following-sibling::*)) or (preceding-sibling::*[1]/title/enum and not (preceding-sibling::*[1]/title/enum/following-sibling::*))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>			
			<xsl:when test="preceding-sibling::*[1]/subdivision and (((preceding-sibling::*[1]/subdivision/header and not(preceding-sibling::*[1]/subdivision/header/following-sibling::*)) or (preceding-sibling::*[1]/subdivision/enum and not (preceding-sibling::*[1]/subdivision/enum/following-sibling::*))) )">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="preceding-sibling::*[1]/division and (((preceding-sibling::*[1]/division/header and not(preceding-sibling::*[1]/division/header/following-sibling::*)) or (preceding-sibling::*[1]/division/enum and not (preceding-sibling::*[1]/division/enum/following-sibling::*))))">
				<xsl:text>true</xsl:text>
			</xsl:when>			
			<xsl:otherwise>
				<xsl:text>false</xsl:text>
			</xsl:otherwise>	
		</xsl:choose>		
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="ExceptionalHeadersRamseyerCordonEnumCode">
		<xsl:param name="isBold">
			<xsl:choose>
				<xsl:when test="ancestor::header/@bold='on'">
					<xsl:text>yes</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>no</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:param>
		
		<xsl:param name="headerStyle">
			<xsl:value-of select="ancestor::header/@header-style" />
		</xsl:param>
		
		<xsl:choose>
			<xsl:when test="($headerStyle='Caps-Small-Caps' or $headerStyle='All-Small-Caps') and $isBold='yes'">
				<xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction><!--<xsl:text disable-output-escaping="yes">&lt;BEL&gt;G1&lt;BEL&gt;T2</xsl:text>--><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
			</xsl:when>
			<xsl:when test="$headerStyle='Caps-Small-Caps' or $headerStyle='All-Small-Caps'">
				<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction><!--<xsl:text disable-output-escaping="yes">&lt;BEL&gt;T1</xsl:text>--><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
			</xsl:when>			
		</xsl:choose>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="IsExceptionalHeadersRamseyerCordon" as="xs:string">
		<xsl:choose>
			<xsl:when test="not(ancestor::changes-in-existing-law)">
				<xsl:text>false</xsl:text>
			</xsl:when>
			<xsl:when test="header/@header-style != ''">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:when test="ancestor::header/@header-style != ''">
				<xsl:text>true</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>false</xsl:text>
			</xsl:otherwise>
		</xsl:choose>		
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="ExceptionalHeadersRamseyerCordonEnum" as="xs:string">		
		<xsl:choose>
			<xsl:when test="header/@header-style = 'All-Caps'">
				<xsl:value-of select="upper-case(local-name())" />
			</xsl:when>
			<xsl:when test="header/@header-style='All-Small-Caps'">
				<xsl:value-of select="lower-case(local-name())" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="gpo:capitalize(.)" />
			</xsl:otherwise>
		</xsl:choose>		
		<xsl:text> </xsl:text>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="chapter" mode="process">
		<xsl:variable name="noDot" as="xs:string">true</xsl:variable>
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="./@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>
		<xsl:variable name="isExceptionalHeader" as="xs:string">
			<xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />		
		</xsl:variable>
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<xsl:variable name="isRamOmmittedText" as="xs:string">
			<xsl:call-template name="isEmptyOmittedStructure" />
		</xsl:variable>
		<para>
		<xsl:choose>
			<xsl:when test="$isExceptionalHeader='true'">
				<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocator" />
			</xsl:when>
			<xsl:when test="$isRamOmmittedText='yes'" />	
			<xsl:when test="$style= 'traditional-inline' or $style='appropriations' ">
				<xsl:attribute name="loc">74</xsl:attribute>
			</xsl:when>
			<xsl:when test="$style= 'nuclear'">
				<xsl:attribute name="loc">74</xsl:attribute>
			</xsl:when>
			<xsl:when test="$style= 'education'">
				<xsl:attribute name="loc">73</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="loc">74</xsl:attribute>
				<!-- fixes issue #102 -->
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction> 
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="$isCommented='yes'  and $isRamOmmittedText='no'">
			<xsl:text>❨</xsl:text>
		</xsl:if>
		<xsl:if test="contains(@vbattChangedForReported,'brackets')  and $isRamOmmittedText='no'">
			<xsl:text>❨</xsl:text>
		</xsl:if>
		<xsl:if test="contains(@vbattChangedForReported,'parentheses')  and $isRamOmmittedText='no'">
			<xsl:text>【</xsl:text>
		</xsl:if>
		<xsl:if test="$inQuotedBlock='yes'  and $isRamOmmittedText='no'">
			<!--Issue #69-->
			<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
		</xsl:if>
		<xsl:choose>
			<xsl:when test="$isExceptionalHeader='true'">
				<xsl:call-template name="ExceptionalHeadersRamseyerCordonEnum" />
			</xsl:when>
			<xsl:when test="not(@level-type='undesignated')">
				<xsl:text>CHAPTER </xsl:text>
			</xsl:when>
		</xsl:choose>
		<xsl:apply-templates select="enum" mode="go" />
		<!-- no space after the enum is needed -->
		<!--<xsl:text> </xsl:text>-->
		<!-- replace function with template; function gives 'context item is absent' error -->
		<xsl:call-template name="getmdash">
			<xsl:with-param name="node" select="." />
			<xsl:with-param name="style" select="$style" />
			<xsl:with-param name="noDot" select="$noDot" />
		</xsl:call-template>
		<!--<xsl:value-of select="gpo:getmdash(., $style, $noDot)"/>	-->
		<xsl:choose>
			<xsl:when test="$isExceptionalHeader='true'">
				<xsl:call-template name="ExceptionalHeadersRamseyerCordon" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates select="header" mode="AllCaps" />
			</xsl:otherwise>
		</xsl:choose>	
		<xsl:if test="$isCommented='yes'  and $isRamOmmittedText='no'">
			<xsl:text>❩</xsl:text>
		</xsl:if>
		
		<xsl:sequence select="gpo:addClosingCharacter" /> 	
		</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="ExceptionalHeadersRamseyerCordonLocator">
	<!--BH:  I don't think this template is being used in a bill.  I think this is for
		committee and conference reports. -->
		<xsl:variable name="comment">ExceptionalHeadersRamseyerCordonLocator</xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:choose>
			<xsl:when test="header/@size='small'">
				<para loc="88" />
			</xsl:when>
			<xsl:when test="header/@size='medium'">
				<para loc="74" />
			</xsl:when>
			<xsl:when test="header/@size='large'">
				<para loc="73" />
			</xsl:when>
			<xsl:when test="header/@size='x-large'">
				<para loc="78" />
			</xsl:when>
			<xsl:otherwise>
				<para loc="74" />		
			</xsl:otherwise>
		</xsl:choose>
		<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocatorExt" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="ExceptionalHeadersRamseyerCordonLocatorExt">
		<xsl:param name="isBold">
			<xsl:choose>
				<xsl:when test="header/@bold='on'">
					<xsl:text>yes</xsl:text>
				</xsl:when>
				<xsl:when test="ancestor::header/@bold='on'">
					<xsl:text>yes</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>no</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:param>
		<xsl:param name="isItalic">
			<xsl:choose>
				<xsl:when test="@reported-display-style='italic'">
					<xsl:text>yes</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>no</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:param>
		<xsl:param name="headerStyle">
			<xsl:value-of select="header/@header-style" />
		</xsl:param>
		<xsl:param name="headerSize">
			<xsl:value-of select="header/@size" />
		</xsl:param>
		
		<xsl:choose>
			<xsl:when test="$isBold='yes' and $isItalic='yes'">
				<!-- bold italic -->
				<xsl:choose>
					<xsl:when test="$headerStyle='All-Caps' ">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;G4&lt;BEL&gt;T3</xsl:text>
					</xsl:when>
					<xsl:when test="$headerStyle='Caps-Small-Caps'">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;g721&lt;BEL&gt;T5</xsl:text>
					</xsl:when>
					<xsl:when test="$headerStyle='All-Small-Caps'">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;g721&lt;BEL&gt;T4</xsl:text>
					</xsl:when>	
					<xsl:when test="$headerStyle='Caps-Lowercase'">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;G4&lt;BEL&gt;T3</xsl:text>
					</xsl:when>	
				</xsl:choose>
			</xsl:when>
			<xsl:when test="$isBold='yes'">
				<!-- bold only -->
				<xsl:choose>
					<xsl:when test="($headerStyle='Caps-Lowercase' ) and ($headerSize='small' )">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;K&lt;BEL&gt;T2</xsl:text>
					</xsl:when>
					<xsl:when test="($headerStyle='All-Caps' or $headerStyle='Caps-Lowercase' ) and ($headerSize='small' or $headerSize='medium')">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;T2</xsl:text>
					</xsl:when>					
					<xsl:when test="$headerStyle='Caps-Small-Caps'">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;g730&lt;BEL&gt;T5</xsl:text>
					</xsl:when>
					<xsl:when test="$headerStyle='All-Small-Caps' ">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;g730&lt;BEL&gt;T4</xsl:text>
					</xsl:when>									
				</xsl:choose>
			</xsl:when>
			<xsl:when test="$isItalic='yes'">
				<!-- italic only -->
				<xsl:choose>
					<xsl:when test="$headerStyle='All-Caps'  and  ($headerSize='small' or $headerSize='medium')">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;G4&lt;BEL&gt;T5</xsl:text>
					</xsl:when>
					<xsl:when test="$headerStyle='All-Caps'  or $headerStyle='Caps-Lowercase'">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;T3</xsl:text>
					</xsl:when>
					<xsl:when test="$headerStyle='Caps-Small-Caps'">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;G4&lt;BEL&gt;T5</xsl:text>
					</xsl:when>
					<xsl:when test="$headerStyle='All-Small-Caps'">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;G4&lt;BEL&gt;T4</xsl:text>
					</xsl:when>					
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<!-- normal -->
				<xsl:choose>
					<xsl:when test="$headerStyle='Caps-Lowercase'">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;T1</xsl:text>
					</xsl:when>
					<xsl:when test="$headerStyle='All-Small-Caps'">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;T4</xsl:text>
					</xsl:when>
					<xsl:when test="$headerStyle='Caps-Small-Caps' and ($headerSize='large' or $headerSize='x-large')">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;T5</xsl:text>
					</xsl:when>
					<xsl:when test="$headerStyle='All-Caps' and ($headerSize='large' or $headerSize='x-large')">
						<xsl:text disable-output-escaping="yes">&lt;BEL&gt;T1</xsl:text>
					</xsl:when>
				</xsl:choose>	
			</xsl:otherwise>
		</xsl:choose>	
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="ExceptionalHeadersRamseyerCordon">	
		<xsl:choose>
			<xsl:when test="header/@header-style='All-Caps'">
				<xsl:apply-templates select="./header" mode="AllCaps" />
			</xsl:when>
			<xsl:when test="header/@header-style='All-Small-Caps'">
				<xsl:apply-templates select="./header" mode="AllLower" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates mode="InitialCaps" select="./header" />
			</xsl:otherwise>
		</xsl:choose>
		
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subpart" mode="process">
		<xsl:variable name="node" select="." as="node()" />
		<xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>		
		<xsl:variable name="style" as="xs:string">
			<xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
		</xsl:variable>
		<xsl:variable name="noDot" as="xs:boolean">true</xsl:variable>
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="./@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="levelLocator" as="item()">
			<!--<xsl:call-template name="locatorFromAttributes"/>-->
			<xsl:choose>
				<xsl:when test="@vbattLocator and string-length(normalize-space(@vbattLocator)) &gt; 0">
					<xsl:sequence select="substring(normalize-space(@vbattLocator), 2, string-length(@vbattLocator))" />
				</xsl:when>
				<xsl:otherwise>73</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="isExceptionalHeader" as="xs:string">
			<xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />		
		</xsl:variable>
		<!--Issue #138 - Para included in the code and modified calls to templates to output header and emdash-->
		<para>
			<xsl:choose>
				<xsl:when test="$isExceptionalHeader='true'">
					<xsl:attribute name="loc"><xsl:call-template name="ExceptionalHeadersRamseyerCordonLocator" /></xsl:attribute>
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="loc"><xsl:value-of select="$levelLocator" /></xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<xsl:if test="$isCommented='yes' ">
			<xsl:text>❨</xsl:text>
		</xsl:if>
		<xsl:if test="contains(@vbattChangedForReported,'brackets')">
			<xsl:text>❨</xsl:text>
		</xsl:if>
		<xsl:if test="contains(@vbattChangedForReported,'parentheses')">
			<xsl:text>【</xsl:text>
		</xsl:if>
			<!--Issue #161 - the code was calling function "gpo:QuotedBlockNextingStart" that wasn't working and isn't needed-->
		<xsl:if test="ancestor::quoted-block">
			<xsl:text>“</xsl:text>
		</xsl:if>
		<xsl:choose>
			<xsl:when test="$isExceptionalHeader='true'">
				<xsl:call-template name="ExceptionalHeadersRamseyerCordonEnum" />
			</xsl:when>
			<xsl:when test="not(./@level-type='undesignated')">
				<xsl:text>Subpart </xsl:text>
			</xsl:when>
		</xsl:choose>
		<xsl:apply-templates select="./enum" mode="go" />
			<xsl:call-template name="getmdash">
				<xsl:with-param name="node" select="." />
				<xsl:with-param name="style" select="$style" />
				<xsl:with-param name="noDot" select="'true'" />
			</xsl:call-template> 
			
		<xsl:choose>
			<xsl:when test="$isExceptionalHeader='true'">
				<xsl:call-template name="ExceptionalHeadersRamseyerCordon" />
			</xsl:when>
			<xsl:otherwise>
				<!--<xsl:apply-templates select="header" mode="InitialCaps"/>-->
				<xsl:apply-templates select="header" mode="FirstWord" />
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="$isCommented='yes' ">
			<xsl:text>❩</xsl:text>
		</xsl:if>
			<!--Issue 539-->
			<xsl:if test="ancestor::quoted-block and not(text) and not(ancestor::quoted-block/descendant::continuation-text)     and not(*/enum) and not(*/header) and not(*/text) and not(text)">
			<xsl:text>”</xsl:text>
			<xsl:value-of select="ancestor::quoted-block/descendant::after-quoted-block" />
			</xsl:if>
	       </para>
		<xsl:apply-templates mode="process" />

	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="clause" mode="process">
		<xsl:variable name="comment">Generic Clause <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="./@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>
		<xsl:variable name="levelLocator" as="xs:string">
					<xsl:call-template name="calculateLocator">
						<xsl:with-param name="level" select="local-name(.)" />						
					</xsl:call-template>		
		</xsl:variable>
	<!--	<xsl:variable name="actualLevelLocator"  as="item()*">
			<xsl:choose>
				<xsl:when test="@indent"> <xsl:call-template name="findActualLocator">
					<xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator"/></xsl:with-param>
				</xsl:call-template></xsl:when>
				<xsl:otherwise><xsl:value-of select="$levelLocator"/></xsl:otherwise>
			</xsl:choose>          
		</xsl:variable>-->
		<para>
			<xsl:attribute name="loc">
				<xsl:value-of select="$levelLocator" />
			</xsl:attribute>
			<xsl:text>  </xsl:text>
			<xsl:if test="ancestor::quoted-block"><xsl:text>“</xsl:text></xsl:if>
			<xsl:if test="ancestor::whereas">
				<xsl:choose>
					<xsl:when test="@changed='deleted'">
						<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
						<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					</xsl:when>
					<xsl:when test="@changed='added'">
						<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					</xsl:when>
				</xsl:choose>
			</xsl:if>
			<xsl:if test="not(@display-inline='yes-display-inline')">
				<xsl:if test="$isCommented='yes'">❨</xsl:if>
				<xsl:if test="contains(@vbattChangedForReported,'brackets')">❨</xsl:if>
				<xsl:if test="contains(@vbattChangedForReported,'parentheses')">【</xsl:if>
			</xsl:if>
			<xsl:if test="enum">
				<xsl:apply-templates select="./enum" mode="go" />
				<xsl:if test="(header or text) and not(string(enum)='')">
					<xsl:text> </xsl:text>
				</xsl:if>
			</xsl:if>
			<xsl:if test="header">
				<xsl:choose>
					<xsl:when test="contains($levelLocator,'20')  or contains(substring-before(.,' '),'&amp;') ">
						<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
					</xsl:when>
					<xsl:when test="contains(local-name(.),'rules-')">
						<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					</xsl:when>
					<xsl:otherwise>
						<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:apply-templates select="header" mode="Special">
					<xsl:with-param name="level" select="$levelLocator" />
				</xsl:apply-templates>
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<!-- additional fix for issue #100 -->
				<xsl:text>.—</xsl:text>
				<xsl:if test="$isCommented='yes' and       not(text)  and       not (*[@display-inline='yes-display-inline']) and       not(string-length(@display-inline)=0)">
					<xsl:text>❩</xsl:text>
				</xsl:if>
				<xsl:if test=" not(text) and $isCommented='yes' and $inQuotedBlock='yes' ">❩</xsl:if>       
			</xsl:if>
			<!--Issue #422 - looked for more elements than text-->
			<xsl:if test="local-name(following::*[1]) = 'after-quoted-block' and not(text) and not(../*/enum) and not(../*/header) and not(../*/text)">
				<xsl:if test="not(following::after-quoted-block/@display = 'no')">
					<xsl:call-template name="QuotedBlockNestingEnd" />
					<xsl:value-of select="following::*[1]" />
					
					<xsl:call-template name="addClosingCharacterForChildElements">
						<xsl:with-param name="source">
							<xsl:text>afterQuotedBlock</xsl:text>
						</xsl:with-param>
					</xsl:call-template>
				</xsl:if>
			</xsl:if>
			<xsl:apply-templates select="text" mode="inline" />		
			<xsl:value-of select="gpo:addClosingCharacter" />
		</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subclause[@display-inline='no-display-inline' or not(@display-inline)][not(child::item/@display-inline = 'yes-display-inline')]" mode="process">
		<xsl:call-template name="handleLowLevelStructure" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="item[@display-inline='no-display-inline' or not(@display-inline)]" mode="process">
		<xsl:variable name="comment">Item <xsl:value-of select="parent::*/name()" /></xsl:variable>
         <xsl:call-template name="handleLowLevelStructure" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="item/enum" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="item/text" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="item/header" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subitem[@display-inline='no-display-inline' or not(@display-inline)]" mode="process">
		<xsl:call-template name="handleLowLevelStructure" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subitem/enum" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subitem/text" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subitem/header" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="division" mode="process">	
	<xsl:variable name="node" select="." as="node()" />
	<xsl:variable name="isExceptionalHeader" as="xs:string">
		<xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />			
	</xsl:variable>
	<xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
	<xsl:variable name="inQuotedBlock" as="xs:string">
		<xsl:choose>
			<xsl:when test="ancestor::quoted-block">yes</xsl:when>
			<xsl:otherwise>no</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="isCommented" as="xs:string">
		<xsl:choose>
			<xsl:when test="./@commented='yes'">yes</xsl:when>
			<xsl:otherwise>no</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>
	<xsl:variable name="style" as="xs:string">
		<xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
	</xsl:variable>
	<para style="{$style}">
		<xsl:choose>
			<xsl:when test="$isExceptionalHeader = 'true'">				
				<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocator" />
			</xsl:when>
			<xsl:when test="$style = 'traditional-inline'  or  $style='appropriations' ">
				<xsl:attribute name="loc">74</xsl:attribute>
				<xsl:processing-instruction name="xpp">fv:2</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="starts-with($style , 'traditional') or starts-with($style , 'archaic') ">
				<xsl:attribute name="loc">74</xsl:attribute>&gt;
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="loc">78</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<xsl:if test="$isCommented='yes' ">
			<xsl:text>❨</xsl:text>
		</xsl:if>
		
		<xsl:if test="contains(@vbattChangedForReported,'brackets')">
			<xsl:text>❨</xsl:text>
		</xsl:if>
		<xsl:if test="contains(@vbattChangedForReported,'parentheses')">
			<xsl:text>【</xsl:text>
		</xsl:if>
		<xsl:if test="$inQuotedBlock='yes'">
			<!--Issue #69-->
			<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
		</xsl:if>
		<xsl:choose>
			<xsl:when test="$isExceptionalHeader='true'">
				<xsl:call-template name="ExceptionalHeadersRamseyerCordonEnum" />
			</xsl:when>
			<xsl:when test="not(./@level-type='undesignated') ">
				<xsl:text>DIVISION </xsl:text>
			</xsl:when>
		</xsl:choose>		
		<xsl:apply-templates select="enum" mode="go" />
		
		<xsl:call-template name="getmdash">
			<xsl:with-param name="node" select="." />
			<xsl:with-param name="style" select="$style" />
			<xsl:with-param name="noDot" select="'true'" />
		</xsl:call-template> 
		
		<xsl:choose>
			<xsl:when test="$isExceptionalHeader='true'">
				<xsl:call-template name="ExceptionalHeadersRamseyerCordon" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates select="header" mode="AllCaps" />
			</xsl:otherwise>
		</xsl:choose>
		
		<xsl:if test="$isCommented='yes'">
			<xsl:text>❩</xsl:text>
		</xsl:if>
	</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="handleLowLevelStructure">
		<xsl:variable name="noDot" as="xs:string">yes</xsl:variable>
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="./@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>
		
		<xsl:variable name="levelLocator" as="xs:string">
			<xsl:call-template name="createLevelLocator" />
		</xsl:variable>
		<xsl:variable name="actualLevelLocator" as="item()*">
			<!--<xsl:value-of select="$levelLocator"/>-->
			<xsl:choose>
				<xsl:when test="@indent"> 
					<xsl:call-template name="findActualLocator">
						<xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator" /></xsl:with-param>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$levelLocator" />
				</xsl:otherwise>
			</xsl:choose>          
		</xsl:variable>
		<xsl:variable name="comment">handleLowLevelStructure - <xsl:value-of select="name()" /> - <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<para>
			<xsl:attribute name="loc">
				<xsl:value-of select="translate($actualLevelLocator, '  ', '')" />
			</xsl:attribute>
			<xsl:text>  </xsl:text>
			<xsl:if test="ancestor::quoted-block">
				<xsl:text>“</xsl:text>
			</xsl:if>
			<xsl:if test="ancestor::whereas">
				<xsl:choose>
					<xsl:when test="@changed='deleted'">
						<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
						<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
					</xsl:when>
					<xsl:when test="@changed='added'">
						<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					</xsl:when>
				</xsl:choose>
			</xsl:if>
			<xsl:if test="not(@display-inline='yes-display-inline')">
				<xsl:if test="$isCommented='yes'">❨</xsl:if>
				<xsl:if test="contains(@vbattChangedForReported,'brackets')">❨</xsl:if>
				<xsl:if test="contains(@vbattChangedForReported,'parentheses')">【</xsl:if>
				<xsl:if test="$inQuotedBlock='yes'">
					<!--Relies on common-named1.xsl-->
					<!--<xsl:call-template name="QuotedBlockNestingStart"/>-->
				</xsl:if>
			</xsl:if>
			<xsl:if test="enum">
				<xsl:apply-templates select="enum" mode="go" />
				<xsl:if test="(header or text) and not(string(enum)='')">
					<xsl:text> </xsl:text>
				</xsl:if>
			</xsl:if>
			<xsl:if test="header">
				<xsl:choose>
					<xsl:when test="contains($actualLevelLocator,'20')  or contains(substring-before(.,' '),'&amp;') ">
						<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
					</xsl:when>
					<xsl:when test="contains(local-name(.),'rules-')">
						<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
					</xsl:when>
					<xsl:otherwise>
						<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:apply-templates select="header" mode="Special">
					<xsl:with-param name="level" select="$actualLevelLocator" />
				</xsl:apply-templates>
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<!--Issue #227 - period mdash was not getting output-->
				<xsl:call-template name="getmdash">
					<xsl:with-param name="style" select="$style" />
				</xsl:call-template>
				<!--<xsl:value-of select="gpo:getmdash($style, $noDot)"/>-->
				
				<!-- SM 080306 This code must be revisited -->
				<!-- NB 12/13/2006 - added clause to the test to cover for a blank attribute value (which is the default of yes) -->
				<xsl:if test="$isCommented='yes' and       not(text)  and       not (*[@display-inline='yes-display-inline']) and       not(string-length(@display-inline)=0)">
					<xsl:text>❩</xsl:text>
				</xsl:if>
				<xsl:if test=" not(text) and $isCommented='yes' and $inQuotedBlock='yes' ">❩</xsl:if>       
			</xsl:if>
			<xsl:apply-templates select="text" mode="inline" />
		   			<xsl:choose>
				<!--Issue #527-->
				<xsl:when test="following-sibling::*[1]/name() = 'after-quoted-block' and not(text)">
					<xsl:text>”</xsl:text><xsl:value-of select="following-sibling::after-quoted-block" />
				</xsl:when>
				<!--BH:  This calls the function 'gpo:addClosingCharacter' which requires a node parameter.  The original call doesn't send any
	            parameters.  I am sending the element name.  This may require modification.  -->
				<xsl:when test="ancestor::quoted-block and not(../*/enum) and not(../*/header) and not(../*/text) and not(ancestor::quoted-block/descendant::continuation-text)      and not(ancestor::quoted-block/descendant::quoted-block-continuation-text)">
					<xsl:value-of select="gpo:addClosingCharacter" />
				</xsl:when>
				<xsl:otherwise />
			</xsl:choose>
		</para>
<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="clause/text" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="clause/enum" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="clause/header" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subclause/text" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subclause/enum" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subclause/header" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subtitle" mode="process">
		<xsl:variable name="style" as="xs:string">
			<xsl:value-of select="@style" />
		</xsl:variable>
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="./@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<!--BH:  This brings back an empty locator -->
		<xsl:variable name="levelLocator" as="item()*">
			<xsl:call-template name="locatorFromAttributes" />
		</xsl:variable>
		<xsl:variable name="isExceptionalHeader" as="xs:string">
			<xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />		
		</xsl:variable>
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<para>
			<xsl:attribute name="loc">
				<xsl:choose>
					<xsl:when test="@vbattLocator != ''"><xsl:value-of select="substring-after(@vbattLocator, 'I')" /></xsl:when>
					<xsl:otherwise>72</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
			<xsl:choose>
				<xsl:when test="$isExceptionalHeader='true'">
					<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocator" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of disable-output-escaping="yes" select="$levelLocator" />
				</xsl:otherwise>
			</xsl:choose>
			
			
			<xsl:if test="$isCommented='yes' ">❨</xsl:if>
			<xsl:if test="contains(@vbattChangedForReported,'brackets')">❨</xsl:if>
			<xsl:if test="contains(@vbattChangedForReported,'parentheses')">【</xsl:if>
			<xsl:if test="$inQuotedBlock='yes'">
				<!--Issue #69-->
				<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
			</xsl:if>
			<xsl:choose>
				<xsl:when test="$isExceptionalHeader='true'">
					<xsl:call-template name="ExceptionalHeadersRamseyerCordonEnum" />
				</xsl:when>
				<xsl:when test="not(./@level-type='undesignated')">
					<xsl:text>Subtitle </xsl:text>
				</xsl:when>
			</xsl:choose>
			<xsl:apply-templates select="./enum" mode="go" /><xsl:text /> <!-- no space after the enum -->
			<xsl:sequence select="gpo:getmdash($style, 'true')" />
			<xsl:choose>
				<xsl:when test="$isExceptionalHeader='true'">
					<xsl:call-template name="ExceptionalHeadersRamseyerCordon" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>—</xsl:text>
					<xsl:apply-templates select="header" mode="FirstWord" />
				</xsl:otherwise>
			</xsl:choose>		
			<xsl:if test="$isCommented='yes'">❩</xsl:if>
			<xsl:sequence select="gpo:addClosingCharacter" />
		</para> 
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="title" mode="process">
		
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>
		
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="./@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<!-- TA: need to revisit locatorFromAttributes. For now, get the locator code from
			the vbattLocator (if present) or use 73 
			-->
		<xsl:variable name="levelLocator" as="item()">
			<!--<xsl:call-template name="locatorFromAttributes"/>-->
			<xsl:choose>
				<xsl:when test="@vbattLocator and string-length(normalize-space(@vbattLocator)) &gt; 0">
					<xsl:sequence select="substring(normalize-space(@vbattLocator), 2, string-length(@vbattLocator))" />
				</xsl:when>
				<xsl:otherwise>78</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="actualLevelLocator" as="item()*">
			<xsl:choose>
				<xsl:when test="@indent"> 
					<xsl:call-template name="findActualLocator">
						<xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator" /></xsl:with-param>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$levelLocator" />
				</xsl:otherwise>
			</xsl:choose>          
		</xsl:variable>
		
		<xsl:variable name="isExceptionalHeader">
			<xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />			
		</xsl:variable>
			
		<xsl:if test="enum//text() or header//text()">
				<xsl:call-template name="KeepParentsFormatOrSelf" />
				<para>
					<xsl:choose>
						<xsl:when test="$isExceptionalHeader='true'">
							<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocator" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:attribute name="loc">
								<xsl:value-of select="$actualLevelLocator" />
							</xsl:attribute>
						</xsl:otherwise>
					</xsl:choose>
					<!--Issue #290 - This logic should be in the section level but is put in the title to
						match the output of the UpConversion.-->
					<xsl:if test="preceding-sibling::title[1][child::*[position() = last()]][name() = 'section']">
					<xsl:if test="following-sibling::title[1]">
						<xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
						</xsl:if>
					</xsl:if>
					<xsl:if test="$isCommented='yes' ">
						<xsl:text>❨</xsl:text>
					</xsl:if>
					<xsl:if test="contains(@vbattChangedForReported,'brackets')">
						<xsl:text>❨</xsl:text>
					</xsl:if>
					
					<xsl:if test="contains(@vbattChangedForReported,'parentheses')">
						<xsl:text>【</xsl:text>
					</xsl:if>
					<xsl:if test="$inQuotedBlock='yes'">
						<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
					</xsl:if>
					
					<xsl:choose>
						<xsl:when test="$isExceptionalHeader='true'">
							<xsl:call-template name="ExceptionalHeadersRamseyerCordonEnum" />
						</xsl:when>				
						<xsl:when test="not(@level-type='undesignated')">
							<xsl:text disable-output-escaping="yes">TITLE </xsl:text>
						</xsl:when>
					</xsl:choose>
					
					<xsl:apply-templates select="enum" mode="go" />
					
					<xsl:call-template name="getmdash">	
						<xsl:with-param name="node" select="." />
						<xsl:with-param name="style" select="$style" />
						<xsl:with-param name="noDot" select="'true'" />
					</xsl:call-template>
					<xsl:choose>
						<xsl:when test="$isExceptionalHeader='true'">
							<xsl:call-template name="ExceptionalHeadersRamseyerCordon" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:if test="header[@display-inline='yes-display-inline'] or header[not(@display-inline)]">
							<xsl:apply-templates select="header" mode="AllCaps" />
							</xsl:if>
						</xsl:otherwise>
					</xsl:choose>			
					<xsl:if test="$isCommented='yes'  or (@changed='deleted' and @reported-display-style='bold-brackets')">
						<xsl:text>❩</xsl:text>
					</xsl:if>
				</para>
			</xsl:if>
		<xsl:if test="header[@display-inline='no-display-inline']">
		<para loc="74"><xsl:value-of select="upper-case(header[@display-inline='no-display-inline'])" /></para>
		</xsl:if>
		<xsl:apply-templates select="* except header" mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="xxtitle" mode="process">
		<xsl:variable name="levelLocator" as="xs:string"><xsl:call-template name="createLevelLocator" /></xsl:variable>
		<xsl:variable name="actualLevelLocator" as="xs:string">
			<xsl:choose>
				<xsl:when test="@indent"> <xsl:call-template name="findActualLocator">
					<xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator" /></xsl:with-param>
				</xsl:call-template></xsl:when>
				<xsl:otherwise><xsl:value-of select="$levelLocator" /></xsl:otherwise>
			</xsl:choose>          
		</xsl:variable>
		
		<xsl:choose>
			<xsl:when test="ancestor::quoted-block">
				<xsl:variable name="qb-id" as="xs:string"><xsl:value-of select="ancestor::quoted-block/@id" /></xsl:variable>
				<xsl:variable name="textCount" as="xs:integer"><xsl:value-of select="count(ancestor::quoted-block/descendant::text)" /></xsl:variable>
				<xsl:variable name="currentCount" as="xs:integer"><xsl:value-of select="count(preceding::text[ancestor::quoted-block/@id = $qb-id]) + 1" /></xsl:variable>
				
				<para>
					<xsl:attribute name="loc" select="$actualLevelLocator" />
					<xsl:attribute name="format">
						<xsl:call-template name="createFormat" />
					</xsl:attribute>
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text></xsl:if>TITLE <xsl:value-of select="enum" />—<xsl:value-of select="upper-case(header)" />
					
					<xsl:if test="text[@display-inline='yes-display-inline']">
						
						<xsl:apply-templates select="text" mode="inline" />
						<xsl:if test="$textCount = $currentCount">’<xsl:value-of select="ancestor::quoted-block/after-quoted-block" /></xsl:if>
					</xsl:if></para> 
				<xsl:if test="text[@display-inline='no-display-inline']">
					<para><xsl:apply-templates select="text" mode="inline" />=<xsl:if test="$textCount = $currentCount">’<xsl:value-of select="../after-quoted-block" /></xsl:if></para>
				</xsl:if>
			</xsl:when>
			<xsl:otherwise>
				<para>
					<xsl:attribute name="format">
						<xsl:call-template name="createFormat" />
					</xsl:attribute>
					<xsl:attribute name="loc" select="$actualLevelLocator" />TITLE <xsl:value-of select="enum" />—<xsl:value-of select="upper-case(header)" /><xsl:text> </xsl:text>
					<xsl:apply-templates select="text" mode="inline" />
				</para>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createParagraphInline">
		<xsl:for-each select="paragraph[@display-inline = 'yes-display-inline']">
			<xsl:apply-templates select="enum" mode="inline" />
			<!-- fixes issue #359 -->
			<xsl:if test="(text or header) and string-length(enum)&gt;0">
				<xsl:text> </xsl:text>
			</xsl:if>
			<xsl:apply-templates select="header" mode="inline" />
			<xsl:apply-templates select="text" mode="inline" />
			<xsl:if test="subparagraph[@display-inline = 'yes-display-inline']">
				<xsl:for-each select="subparagraph[@display-inline = 'yes-display-inline']">
					<xsl:apply-templates select="enum" mode="inline" />
					<xsl:apply-templates select="header" mode="inline" />
					<xsl:apply-templates select="text" mode="inline" />
					<xsl:if test="clause[@display-inline = 'yes-display-inline']">
						<xsl:call-template name="createClauseInline" />
					</xsl:if>
				</xsl:for-each>
			</xsl:if>
		</xsl:for-each>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createSubsectionInline">
		<xsl:for-each select="subsection[@display-inline = 'yes-display-inline']">
			<!-- issue #391 -->
			<xsl:if test="@style='appropriations'"><xsl:text> </xsl:text></xsl:if>
			<xsl:apply-templates select="enum" mode="inline" />
			<!--<xsl:if test="@style='appropriations'">--><xsl:text> </xsl:text><!--</xsl:if>-->
			<!--Issue #55: Missing processing instructions around header element-->
			<xsl:if test="header">
				<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
				<!-- fixes issue #473. All subsection headers must be processed in Special mode to get
					proper capitialization and appropriate PIs -->
				<xsl:apply-templates select="header" mode="Special" />
			<!--<xsl:apply-templates select="header" mode="inline"/>-->
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:text>.—</xsl:text>
			</xsl:if>
			<xsl:apply-templates select="text" mode="inline" />
			<xsl:if test="paragraph[@display-inline = 'yes-display-inline']">
				<xsl:for-each select="paragraph[@display-inline = 'yes-display-inline']">
					<xsl:apply-templates select="enum" mode="inline" />
					<xsl:apply-templates select="header" mode="inline" />
					<xsl:apply-templates select="text" mode="inline" />
					<xsl:if test="subparagraph[@display-inline = 'yes-display-inline']">
						<xsl:call-template name="createSubparagraphInline" />
					</xsl:if>
				</xsl:for-each>
			</xsl:if>
		</xsl:for-each>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createSubparagraphInline">
		<xsl:for-each select="subparagraph[@display-inline = 'yes-display-inline']">
			<xsl:apply-templates select="enum" mode="inline" />
            <!-- fix for issue #225; space ONLY if there is a header -->
			<xsl:if test="header">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="header" mode="inline" />
			</xsl:if>
			<xsl:if test="text">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="text" mode="inline" />
			</xsl:if>
			<xsl:choose>
				<xsl:when test="clause[@display-inline = 'yes-display-inline']">
					<xsl:for-each select="clause[@display-inline = 'yes-display-inline']">
						<xsl:apply-templates select="enum" mode="inline" />
						<!-- fix for issue #225; space ONLY if there is a header -->
						<xsl:if test="header">
							<xsl:text> </xsl:text>
							<xsl:apply-templates select="header" mode="inline" />
						</xsl:if>
						<xsl:if test="text">
							<xsl:text> </xsl:text>
							<xsl:apply-templates select="text" mode="inline" />
						</xsl:if>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise />
			</xsl:choose>
		</xsl:for-each>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="quoted-block" mode="inlineClause">
		<xsl:variable name="comment">clause/quoted-block - <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:for-each select="subclause[@display-inline = 'yes-display-inline']">
			<xsl:if test="not(@display-inline = 'yes-display-inline')">
						<xsl:text> “</xsl:text>
			</xsl:if>
			<xsl:apply-templates select="enum" mode="inline" />
			<!-- fixes issue #206; add a space if there is a header element. -->
			<xsl:if test="header">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="header" mode="inline" />
			</xsl:if>
			<!-- fixes issue #206; add a space if there is a text element. -->
			<xsl:if test="text">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="text" mode="inline" />
			</xsl:if>
			
			<xsl:if test="item[@display-inline = 'yes-display-inline']">
				<xsl:for-each select="item[@display-inline = 'yes-display-inline']">
					<xsl:apply-templates select="enum" mode="inline" />
					<xsl:text> </xsl:text>
					<xsl:apply-templates select="header" mode="inline" />
					<xsl:apply-templates select="text" mode="inline" />
				</xsl:for-each>
			</xsl:if>		
		</xsl:for-each>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createClauseInline">
		<xsl:variable name="comment">createClauseInline - <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:for-each select="clause[@display-inline = 'yes-display-inline']">
			<xsl:apply-templates select="enum" mode="inline" />
			<!-- fix for issue #225; space ONLY if there is a header -->
			<xsl:if test="header">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="header" mode="inline" />
			</xsl:if>
			<xsl:if test="text">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="text" mode="inline" />
			</xsl:if>
			<xsl:if test="text[@display-inline = 'yes-display-inline']">
				<xsl:for-each select="clause[@display-inline = 'yes-display-inline']">
					<xsl:apply-templates select="enum" mode="inline" />
					<!-- fix for issue #225; space ONLY if there is a header -->
					<xsl:if test="header">
						<xsl:text> </xsl:text>
						<xsl:apply-templates select="header" mode="inline" />
					</xsl:if>
					<xsl:if test="text">
						<xsl:text> </xsl:text>
						<xsl:apply-templates select="text" mode="inline" />
					</xsl:if>
				</xsl:for-each>
			</xsl:if>
			<xsl:if test="subclause[@display-inline='yes-display-inline']">
			<xsl:call-template name="createSubclauseInline" />
			</xsl:if>
		</xsl:for-each>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subclause[@display-inline='yes-display-inline']" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="item[@display-inline='yes-display-inline']" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createSubclauseInline">
		<xsl:variable name="comment">createSubclauseInline - <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:for-each select="subclause[@display-inline = 'yes-display-inline']">
			<xsl:apply-templates select="enum" mode="inline" />
			<!-- fixes issue #206; add a space if there is a header element. -->
			<xsl:if test="header">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="header" mode="inline" />
			</xsl:if>
			<!-- fixes issue #206; add a space if there is a text element. -->
			<xsl:if test="text">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="text" mode="inline" />
			</xsl:if>
			<xsl:if test="item[@display-inline = 'yes-display-inline']">
				<xsl:for-each select="item[@display-inline = 'yes-display-inline']">
					<xsl:apply-templates select="enum" mode="inline" />
					<xsl:text>  </xsl:text>
					<xsl:apply-templates select="header" mode="inline" />
					<xsl:apply-templates select="text" mode="inline" />
				</xsl:for-each>
			</xsl:if>
		</xsl:for-each>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="clause[@display-inline = 'yes-display-inline']" mode="process">
		<xsl:variable name="comment">clause[@display-inline='yes-display-inline'] - <xsl:value-of select="@id" />
			Suppress output</xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:apply-templates select="subclause[not(@display-inline) or @display-inline='no-display-inline']" mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="clause[child::subclause/@display-inline = 'yes-display-inline' or   child::quoted-block[@display-inline = 'yes-display-inline'][child::subclause/@display-inline='yes-display-inline']]" mode="process">
		<xsl:variable name="levelLocator" as="xs:string">
			<xsl:call-template name="calculateLocator">
				<xsl:with-param name="level" select="local-name()" />						
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="comment">clause[child::subclause/@display-inline = 'yes-display-inline'] - <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<para loc="{$levelLocator}">
			<xsl:text>  </xsl:text>
			<xsl:if test="ancestor::quoted-block">
				<xsl:text>“</xsl:text>
			</xsl:if>
			<xsl:value-of select="enum" />
			<xsl:if test="header"><xsl:call-template name="createHeader" /><xsl:text> </xsl:text></xsl:if>
			<xsl:if test="text">
				<xsl:if test="not(header)">
					<xsl:text> </xsl:text>
				</xsl:if>
				<xsl:apply-templates select="text" mode="inline" /><xsl:text> </xsl:text>
			</xsl:if>
			<xsl:if test="subclause">
			<xsl:call-template name="createSubclauseInline" />
			</xsl:if>
			<xsl:if test="quoted-block[@display-inline = 'yes-display-inline']">
				<xsl:apply-templates select="quoted-block" mode="inlineClause" />
			</xsl:if>
		</para>
		<!--We need to take care of subclauses in the clause-->
		<xsl:apply-templates select="descendant::subclause[@display-inline='yes-display-inline']/item" mode="process" />
		<xsl:apply-templates mode="process" />
<!--		<xsl:apply-templates select="descendant::subclause[not(@display-inline) or @display-inline='no-display-inline']" mode="process"/>-->
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subclause[@display-inline='no-display-inline' or not(@display-inline)][child::item/@display-inline = 'yes-display-inline']" mode="process">
		<xsl:variable name="levelLocator" as="xs:string">
			<xsl:call-template name="calculateLocator">
				<xsl:with-param name="level" select="local-name()" />						
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="comment">subclause[child::item/@display-inline = 'yes-display-inline'] - <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<para loc="{$levelLocator}">
			<xsl:text>  </xsl:text>
			<xsl:if test="ancestor::quoted-block">
				<xsl:text>“</xsl:text>
			</xsl:if>
			<xsl:value-of select="enum" />
			<xsl:if test="header"><xsl:call-template name="createHeader" /><xsl:text> </xsl:text></xsl:if>
			<xsl:call-template name="createItemInline" />
		</para>
		<xsl:apply-templates mode="process" />
		<!--We need to take care of subclauses in the clause-->
	<!--	<xsl:apply-templates select="item[@display-inline='yes-display-inline']/subitem" mode="process"/>
		<xsl:apply-templates select="item[not(@display-inline) or @display-inline='no-display-inline']" mode="process"/>-->
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createItemInline">
		<xsl:variable name="comment">createItemInline - <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:for-each select="item[@display-inline = 'yes-display-inline']">
			<xsl:apply-templates select="enum" mode="inline" />
			<!-- fixes issue #206; add a space if there is a header element. -->
			<xsl:if test="header">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="header" mode="inline" />
			</xsl:if>
			<!-- fixes issue #206; add a space if there is a text element. -->
			<xsl:if test="text">
				<xsl:text> </xsl:text>
				<xsl:apply-templates select="text" mode="inline" />
			</xsl:if>
			
			<xsl:if test="text[@display-inline = 'yes-display-inline']">
				<xsl:for-each select="item[@display-inline = 'yes-display-inline']">
					<xsl:apply-templates select="enum" mode="inline" />
					<xsl:apply-templates select="header" mode="inline" />
					<xsl:apply-templates select="text" mode="inline" />
				</xsl:for-each>
			</xsl:if>
		</xsl:for-each>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="part" mode="process">
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>
		
		<!-- TA: need to revisit locatorFromAttributes. For now, get the locator code from
			the vbattLocator (if present) or use 73 
			-->
		<xsl:variable name="levelLocator" as="item()">
			<!--<xsl:call-template name="locatorFromAttributes"/>-->
			<xsl:choose>
				<xsl:when test="@vbattLocator and string-length(normalize-space(@vbattLocator)) &gt; 0">
					<xsl:sequence select="substring(normalize-space(@vbattLocator), 2, string-length(@vbattLocator))" />
				</xsl:when>
				<xsl:otherwise>73</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="actualLevelLocator" as="item()*">
			<xsl:choose>
				<xsl:when test="@indent"> 
					<xsl:call-template name="findActualLocator">
					<xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator" /></xsl:with-param>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$levelLocator" />
				</xsl:otherwise>
			</xsl:choose>          
		</xsl:variable>
		
		
		<xsl:variable name="isExceptionalHeader">
			<xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />		
		</xsl:variable>
		
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		
		<para>
			<xsl:choose>
				<xsl:when test="$isExceptionalHeader='true'">
					<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocator" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="loc">
						<xsl:value-of select="$actualLevelLocator" />
					</xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>	
			
			<xsl:if test="$isCommented='yes' ">
				<xsl:text>❨</xsl:text>
			</xsl:if>
			<xsl:if test="contains(@vbattChangedForReported,'brackets')">
				<xsl:text>❨</xsl:text>
			</xsl:if>
			<xsl:if test="contains(@vbattChangedForReported,'parentheses')">
				<xsl:text>【</xsl:text>
			</xsl:if>
			<xsl:if test="$inQuotedBlock='yes'">
				<!--Issue #69-->
				<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
			</xsl:if>
			
			<xsl:if test="starts-with($style , 'traditional') or starts-with($style , 'archaic') or $style = 'education' ">
				<xsl:choose>
					<xsl:when test="$isExceptionalHeader='true'">
						<xsl:call-template name="ExceptionalHeadersRamseyerCordonEnum" />
					</xsl:when>
					<xsl:when test="not(@level-type='undesignated')">
						<xsl:text>Part </xsl:text>
					</xsl:when>
				</xsl:choose>
				
				<xsl:apply-templates select="enum" mode="go" />
				
				<xsl:call-template name="getmdash">
					<xsl:with-param name="node" select="." />
					<xsl:with-param name="style" select="$style" />
					<xsl:with-param name="noDot" select="'true'" />
				</xsl:call-template> 
				
				<xsl:choose>
					<xsl:when test="$isExceptionalHeader='true'">
						<xsl:call-template name="ExceptionalHeadersRamseyerCordon" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:apply-templates select="header" mode="InitialCaps" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:if test="not(starts-with($style , 'traditional') or starts-with($style , 'archaic') or $style = 'education' )">
				
				<xsl:choose>
					<xsl:when test="$isExceptionalHeader='true'">
						<xsl:call-template name="ExceptionalHeadersRamseyerCordonEnum" />
					</xsl:when>
					<xsl:when test="not(@level-type='undesignated')">
						<xsl:text>PART </xsl:text>
					</xsl:when>
				</xsl:choose>
				
				<xsl:apply-templates select="enum" mode="go" />
				
				<xsl:call-template name="getmdash">
					<xsl:with-param name="node" select="." />
					<xsl:with-param name="style" select="$style" />
					<xsl:with-param name="noDot" select="'true'" />
				</xsl:call-template> 
				
				<xsl:choose>
					<xsl:when test="$isExceptionalHeader='true'">
						<xsl:call-template name="ExceptionalHeadersRamseyerCordon" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:apply-templates select="header" mode="AllCaps" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			<xsl:if test="$isCommented='yes'">
				<xsl:text>❩</xsl:text>
			</xsl:if>
			<xsl:value-of select="gpo:addClosingCharacter(.)" />	
		</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="rule" mode="process">
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="./@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<para loc="74">
			<xsl:if test="$isCommented='yes' ">❨</xsl:if>
			<xsl:if test="contains(@vbattChangedForReported,'brackets')">❨</xsl:if>--&gt;
			<xsl:if test="contains(@vbattChangedForReported,'parentheses')">【</xsl:if>
		<xsl:if test="$inQuotedBlock='yes'">
			<!--Issue #69-->
			<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
		</xsl:if>
		<xsl:apply-templates select="enum" mode="AllCaps" />
		<xsl:if test="not(header[@display-inline='no-display-inline'])">	
			<xsl:text> </xsl:text>
		</xsl:if>
		<xsl:apply-templates select="./header" mode="InitialCaps" />
			<xsl:if test="$isCommented='yes' ">❩</xsl:if>
		</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match=" rules-clause| rules-paragraph" mode="process">
		<xsl:variable name="node" select="." as="item()*" />
		<xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
		<xsl:choose>
			<xsl:when test="rules-clause-header">
				<xsl:apply-templates select="rules-clause-header" mode="Sentence" />
			</xsl:when>
			<xsl:when test="header">
				<xsl:apply-templates select="header" mode="Sentence" />
			</xsl:when>
		</xsl:choose>
		
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<xsl:variable name="style" as="xs:string">
			<xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
		</xsl:variable>
		<xsl:variable name="levelLocator" as="xs:string">
			<xsl:call-template name="calculateLocator">
				<xsl:with-param name="level" select="local-name(.)" />
			</xsl:call-template>
		</xsl:variable>
		<xsl:value-of disable-output-escaping="yes" select="$levelLocator" />
		<xsl:if test="not(@display-inline='yes-display-inline')">
			<xsl:call-template name="OpeningSectionTemplate">
				<xsl:with-param name="aToPrintLevelLocator"><xsl:text>no</xsl:text></xsl:with-param>
				<xsl:with-param name="aLevelLocator" select="$levelLocator" />
			</xsl:call-template>	
		</xsl:if>
		<xsl:if test="./enum">
			<xsl:apply-templates select="enum" mode="go" />
			<xsl:if test="(header or text) and not(string(enum)='')">
				<xsl:text> </xsl:text>
			</xsl:if>
		</xsl:if>
		<xsl:apply-templates mode="process" />		
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="rules-subparagraph | rules-subdivision  | rules-item | rules-subitem " mode="process">
		<xsl:call-template name="handleLowLevelStructure" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="isRamseyerCordon">
		<xsl:choose>
			<xsl:when test="ancestor::ramseyer or ancestor::cordon">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>no</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subchapter" mode="process">
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="./@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>
		<!-- <xsl:variable name="levelLocator">
            <xsl:call-template name="locatorFromAttributes"/>
        </xsl:variable>-->
		<!-- get the locator from vbattLocator attribute (usually as I74), if present; otherwise 74-->
		<xsl:variable name="levelLocator" as="xs:double">
			<xsl:choose>
				<xsl:when test="@vbattLocator and string-length(@vbattLocator) &gt; 0">
					<xsl:value-of select="translate(@vbattLocator, translate(@vbattLocator, '0123456789', ''), '')" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="74" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="isExceptionalHeader" as="item()*">
			<xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />		
		</xsl:variable>
		<para loc="{$levelLocator}">
			<xsl:call-template name="KeepParentsFormatOrSelf" />
			<xsl:choose>
				<xsl:when test="$isExceptionalHeader='true'">
					<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocator" />
				</xsl:when>
				<xsl:otherwise>
					<!-- partial fix for issue #245 -->
					<!--<xsl:value-of disable-output-escaping="yes" select="$levelLocator"/>-->
					<xsl:call-template name="locatorFromAttributes" />
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="($style='traditional-inline' or $style='appropriations') and $isExceptionalHeader='false'">
				<xsl:processing-instruction name="xpp">fv:1</xsl:processing-instruction>
			</xsl:if>
			<xsl:if test="$isCommented='yes' ">❨</xsl:if>
			<xsl:if test="contains(@vbattChangedForReported,'brackets')">❨</xsl:if>
			<xsl:if test="contains(@vbattChangedForReported,'parentheses')">【 </xsl:if>
			<xsl:if test="$inQuotedBlock='yes'">
				<!--Issue #69-->
				<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
			</xsl:if>
			<xsl:choose>
				<xsl:when test="$isExceptionalHeader='true'">    
					<xsl:call-template name="ExceptionalHeadersRamseyerCordonEnum" /> 
					<xsl:apply-templates select="./enum" mode="go" />				
					<xsl:call-template name="getmdash">
						<xsl:with-param name="node" select="." />
						<xsl:with-param name="style" select="$style" />
						<xsl:with-param name="noDot" select="'true'" />
					</xsl:call-template>
					<!--<xsl:value-of select="gpo:getmdash($style, true())"/>-->            
					<xsl:call-template name="ExceptionalHeadersRamseyerCordon" />
				</xsl:when>
				<xsl:when test="$style = 'USC' or $style ='traditional' or starts-with($style , 'archaic')">		
					<xsl:if test="not(./@level-type='undesignated')">
						<xsl:text>SUBCHAPTER </xsl:text>
					</xsl:if>
					<xsl:apply-templates select="./enum" mode="go" />
					<xsl:call-template name="getmdash">
						<xsl:with-param name="node" select="." />
						<xsl:with-param name="style" select="$style" />
						<xsl:with-param name="noDot" select="'true'" />
					</xsl:call-template>
					<!--<xsl:value-of select="gpo:getmdash($style, true())"/>-->    
					<xsl:apply-templates select="./header" mode="AllCaps" />
				</xsl:when>
				<xsl:otherwise>				
					<xsl:if test="not(./@level-type='undesignated')">					
						<xsl:text>Subchapter </xsl:text>
					</xsl:if>
					<xsl:apply-templates select="./enum" mode="go" />
					<xsl:call-template name="getmdash">
						<xsl:with-param name="node" select="." />
						<xsl:with-param name="style" select="$style" />
						<xsl:with-param name="noDot" select="'true'" />
					</xsl:call-template>
					<!--<xsl:value-of select="gpo:getmdash($style, true())"/>-->   
					<xsl:apply-templates select="header" mode="InitialCaps" />
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="$isCommented='yes'">❩</xsl:if>
			<xsl:value-of select="gpo:addClosingCharacter(.)" />
		</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subdivision" mode="process">			
		<xsl:variable name="inQuotedBlock" as="xs:string">
			<xsl:choose>
				<xsl:when test="ancestor::quoted-block">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="isCommented" as="xs:string">
			<xsl:choose>
				<xsl:when test="./@commented='yes'">yes</xsl:when>
				<xsl:otherwise>no</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>
		<xsl:variable name="isExceptionalHeader" as="xs:string">
			<xsl:call-template name="IsExceptionalHeadersRamseyerCordon" />				
		</xsl:variable>
	
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		
		<para>
			<xsl:choose>
				<xsl:when test="$isExceptionalHeader = 'true'">
					<xsl:call-template name="ExceptionalHeadersRamseyerCordonLocator" />
				</xsl:when>
				<xsl:when test="$style='traditional-inline' or $style='appropriations'">
					<xsl:attribute name="loc">74</xsl:attribute>
					<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				</xsl:when>
				<xsl:when test="$style='traditional'  or $style='archaic'  or $style='archaic-paragraph' ">
					<xsl:attribute name="loc">74</xsl:attribute>
					<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="loc">78</xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="$isCommented='yes' ">
				<xsl:text>❨</xsl:text>
			</xsl:if>
			<xsl:if test="contains(@vbattChangedForReported,'brackets')">
				<xsl:text>❨</xsl:text>
			</xsl:if>
			<xsl:if test="contains(@vbattChangedForReported,'parentheses')">
				<xsl:text>【</xsl:text>
			</xsl:if>
			<xsl:if test="$inQuotedBlock='yes'">
				<!--Issue #69-->
				<xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
			</xsl:if>
		
			<xsl:choose>			
				<xsl:when test="$isExceptionalHeader='true'">
					<xsl:call-template name="ExceptionalHeadersRamseyerCordonEnum" />
					<xsl:apply-templates mode="go" select="enum" />
					<!-- issue #243 -->
					<xsl:call-template name="getmdash">
						<xsl:with-param name="node" select="." />
						<xsl:with-param name="style" select="$style" />
						<xsl:with-param name="noDot" select="'true'" />
					</xsl:call-template>
					<!--<xsl:value-of select="gpo:getmdash($style, true())"/>-->								
					<xsl:call-template name="ExceptionalHeadersRamseyerCordon" />	
				</xsl:when>			
				<xsl:when test="$style='traditional'  or $style='traditional-inline' or $style='archaic'  or $style='archaic-paragraph'  or $style='appropriations'">
					<xsl:if test="not(./@level-type='undesignated')">
						<xsl:text>Subdivision </xsl:text>
					</xsl:if>
					<xsl:apply-templates mode="go" select="enum" />
					<!-- issue #243 -->
					<xsl:call-template name="getmdash">
						<xsl:with-param name="node" select="." />
						<xsl:with-param name="style" select="$style" />
						<xsl:with-param name="noDot" select="'true'" />
					</xsl:call-template>
					<!--<xsl:value-of select="gpo:getmdash($style, true())"/>-->					
					<xsl:apply-templates mode="InitialCaps" select="./header" />				
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="not(./@level-type='undesignated')">
						<xsl:text>SUBDIVISION </xsl:text>
					</xsl:if>
					<xsl:apply-templates mode="go" select="enum" />
					<!-- issue #243 -->
					<xsl:call-template name="getmdash">
						<xsl:with-param name="node" select="." />
						<xsl:with-param name="style" select="$style" />
						<xsl:with-param name="noDot" select="'true'" />
					</xsl:call-template>
					<!--<xsl:value-of select="gpo:getmdash($style, true())"/>-->					
					<xsl:apply-templates mode="AllCaps" select="./header" />				
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="$isCommented='yes'">
				<xsl:text>❩</xsl:text>
			</xsl:if>
		</para>
		<xsl:apply-templates mode="process" />
			
		<xsl:sequence select="gpo:addClosingCharacter" />
		
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createFormat">
		<xsl:choose>
		<xsl:when test="@reported-display-style='strikethrough'">
			<xsl:attribute name="format">
				<xsl:choose>
					<xsl:when test="ancestor::amendment-doc">6203</xsl:when>
					<xsl:when test="@changed='added'">6401</xsl:when>
					<xsl:when test="@changed='deleted'">6401</xsl:when>
					<xsl:when test="@vbattParentFormat= 'AddOrDelete'">6401</xsl:when>
					<xsl:otherwise>6201</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		</xsl:when>
			<xsl:otherwise />		
		</xsl:choose>
	</xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Puts a close bracket or paren iwhen the current element is flagged for it but the next one is not</desc>
		<param>The element node.</param>
		<return>The character code for the closing bracket or parenthesis.</return>
		<gpo:srcXSL>Named Template:  addClosingCharacter</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:addClosingCharacter" as="xs:string?">
		<xsl:param name="node" as="element()" />
		
		<xsl:variable name="n0" as="xs:string?" select="local-name($node/child::*[not(local-name()='text')]          [not(local-name()='enum')]          [not(local-name()='header')][last()])" />
	
		<xsl:variable name="n1" as="xs:string?" select="$node/child::*[not(local-name()='text')]          [not(local-name()='enum')]          [not(local-name()='header')][last()]/@vbattChangedForReported" />
		
		<xsl:choose>
			<xsl:when test="$node/child::header or $node/child::text">
				<!-- The end bracket would come from these elements -->
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="currentBracket" as="xs:string" select="        if (contains($node/@reported-display-style, 'bracket')          or contains($node/@vbattChangedForReported, 'bracket')) then 'Yes'        else 'No'        " />

				<xsl:variable name="nextBracket" as="xs:string" select="       if (contains($node/following::*[1]/@reported-display-style, 'bracket')) then 'Yes'       else 'No'       " />
				
				<xsl:variable name="currentParens" as="xs:string" select="       if (contains($node/@reported-display-style, 'parentheses')         or contains($node/@vbattChangedForReported, 'parentheses')) then 'Yes'       else 'No'       " />
				
					
				<xsl:variable name="nextParens" as="xs:string" select="       if (contains($node/following::*[1]/@reported-display-style, 'parentheses')          or contains($node/following::*[1]/@vbattChangedForReported, 'parentheses')) then 'Yes'       else 'No'       " />
						
				<xsl:variable name="nbCheck" as="xs:string?" select="$node/child::section[position()=1]/@reported-display-style" />
				
				<xsl:variable name="includesStructural" as="xs:string" select="         if ($node/child::division) then 'Yes'         else if ($node/child::subdivision) then 'Yes'         else if ($node/child::chapter) then 'Yes'         else if ($node/child::subchapter) then 'Yes'         else if ($node/child::part) then 'Yes'         else if ($node/child::subpart) then 'Yes'         else if ($node/child::title) then 'Yes'         else if ($node/child::subtitle) then 'Yes'               else if ($node/child::section) then 'Yes'         else if ($node/child::subsection) then 'Yes'         else if ($node/child::paragraph) then 'Yes'         else if ($node/child::subparagraph) then 'Yes'         else if ($node/child::clause) then 'Yes'         else if ($node/child::subclause) then 'Yes'         else if ($node/child::item) then 'Yes'         else if ($node/child::subitem) then 'Yes'              else 'No'      " />
				
				<xsl:if test="$currentBracket='Yes' and $nextBracket='No' and $includesStructural='No'">
					<xsl:text>❩</xsl:text>			
				</xsl:if>
				<xsl:if test="$currentParens='Yes' and $nextParens='No' and $includesStructural='No'">
					<xsl:text>】</xsl:text>			
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>		
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Gets the reported-display-style of the specified element node.</desc>
		<param>The element node.</param>
		<return>The @reported-display-style of the specified element node.</return>
		<gpo:srcXSL>Named Template:  getReportedDisplayStyle</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:getReportedDisplayStyle" as="xs:string?">
		<xsl:param name="node" as="element()" />
		<xsl:sequence select="normalize-space(string($node/@reported-display-style))" />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>addClosingCharacterForChildElements</desc>
		<param>source: </param>
		<return />
		<gpo:srcXSL>Named Template:  addClosingCharacterForChildElements</gpo:srcXSL>
	</doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="addClosingCharacterForChildElements" as="xs:string">
		<xsl:param name="source" as="xs:string" select="''" />
		
		<xsl:variable name="nextBracket" as="xs:string" select="    if (following-sibling::* and following-sibling::*[1]/@changed='not-changed') then 'No'    else if (not (following-sibling::* ) and parent::*/following-sibling::* and parent::*/following-sibling::*[1]/@changed='not-changed') then 'No'    else if (((contains(following::*[1]/@reported-display-style, 'bracket') and @reported-display-style = following::*[1]/@reported-display-style ) or (contains(following::*[1]/@vbattChangedForReported, 'bracket') and @vbattChangedForReported = following::*[1]/@vbattChangedForReported)) and not (local-name(following::*[1]) = 'after-quoted-block')) then 'Yes'    else if (local-name() = 'after-quoted-block' and  contains(parent::quoted-block/following-sibling::*[1]/@reported-display-style, 'bracket')) then 'Yes'    else if (local-name()='toc-entry'       and following-sibling::*       and (following-sibling::*[1]/@changed ='added' or following-sibling::*[1]/@changed ='not-changed' or following-sibling::*[1]/@vbattChangedForReported='not-changed' or  following-sibling::*[1]/@vbattChangedForReported='added')) then 'No'    else if (local-name()='toc-entry' and following-sibling::*) then 'Yes'    else if (not(parent::*/following-sibling::*[1]) and ancestor::*[2]/following-sibling::*[1]/@vbattChangedForReported = 'bold-brackets') then 'Yes'    else if (not(parent::*/following-sibling::*[1]) and not (ancestor::*[2]/following-sibling::*[1]) and ancestor::*[3]/following-sibling::*[1]/@vbattChangedForReported = 'bold-brackets') then 'Yes'    else 'No'    " />
		
		<xsl:variable name="nextParens" as="xs:string" select="    if ((     (contains(following::*[1]/@reported-display-style, 'parentheses')              and @reported-display-style = following::*[1]/@reported-display-style)      or (contains(following::*[1]/@vbattChangedForReported, 'parentheses')        and @vbattChangedForReported = following::*[1]/@vbattChangedForReported))      and not(local-name(following::*[1]) = 'after-quoted-block')) then 'Yes'    else 'No'    " />
		
		<xsl:variable name="nbCheck" as="xs:string?" select="normalize-space(following-sibling::subsection[1]/@reported-display-style)" />
		
		<xsl:variable name="includesStructuralBracket" as="xs:string" select="    if (contains(following-sibling::division[1]/@reported-display-style, 'bracket')     or contains(following-sibling::subdivision[1]/@reported-display-style, 'bracket')     or contains(following-sibling::chapter[1]/@reported-display-style, 'bracket')     or contains(following-sibling::subchapter[1]/@reported-display-style, 'bracket')     or contains(following-sibling::part[1]/@reported-display-style, 'bracket')     or contains(following-sibling::subpart[1]/@reported-display-style, 'bracket')     or contains(following-sibling::title[1]/@reported-display-style, 'bracket')     or contains(following-sibling::subtitle[1]/@reported-display-style, 'bracket')     or contains(following-sibling::section[1]/@reported-display-style, 'bracket')     or contains(following-sibling::subsection[1]/@reported-display-style, 'bracket')     or contains(following-sibling::paragraph[1]/@reported-display-style, 'bracket')     or contains(following-sibling::subparagraph[1]/@reported-display-style, 'bracket')     or contains(following-sibling::clause[1]/@reported-display-style, 'bracket')     or contains(following-sibling::subclause[1]/@reported-display-style, 'bracket')     or contains(following-sibling::item[1]/@reported-display-style, 'bracket')     or contains(following-sibling::subitem[1]/@reported-display-style, 'bracket')) then 'Yes'    else 'No'    " />
			
		<xsl:variable name="includesStructuralParens" as="xs:string" select="    if (contains(parent::*[child::division[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::subdivision[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::chapter[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::subchapter[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::part[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::subpart[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::title[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::subtitle[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::section[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::subsection[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::paragraph[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::subparagraph[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::clause[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::subclause[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::item[1]]/@reported-display-style, 'parentheses')     or contains(parent::*[child::subitem[1]]/@reported-display-style, 'parentheses')) then 'Yes'    else 'No'    " />
			
		
		<xsl:variable name="isChildLast" as="xs:string">
			<xsl:call-template name="iAmALastSibling" />
		</xsl:variable>
		
		<xsl:variable name="IAmLasIntSection" as="xs:string">
			<xsl:call-template name="isLastInSection" />
		</xsl:variable>
		
		<xsl:variable name="IAmLastTheSibling" as="xs:string">
			<xsl:choose>
				<xsl:when test="local-name()='toc-entry' and $IAmLasIntSection='true' ">
					<xsl:text>true</xsl:text>
				</xsl:when>
				<xsl:when test="$billtype='appropriations'  and not(local-name(ancestor::section[1]/child::*[position()=last()]) = 'quoted-block')">
					<xsl:text>false</xsl:text>
				</xsl:when>
				<xsl:when test="$source='afterQuotedBlock' and       (parent::quoted-block/following-sibling::section       or local-name(parent::quoted-block/following-sibling::quoted-block/child::*[1]) = 'section'        or (ancestor::legis-body/descendant::*[position()=last()] = self::*)            or (ancestor::resolution-body/descendant::*[position()=last()] = self::*)       or (ancestor::amendment-body/descendant::*[position()=last()] = self::*)        or not (parent::quoted-block/ancestor::*/following-sibling::*))">
					<xsl:text>true</xsl:text>
				</xsl:when>
				<xsl:when test="$source='afterQuotedBlock' and       (ancestor::section[1]/descendant::*[position()=last()] = self::*)      and preceding-sibling::*[1] = ancestor::section[1]/descendant::*[position()=last()]/preceding-sibling::*[1]">
					<xsl:text>true</xsl:text>
				</xsl:when>
				<xsl:when test="$source !='afterQuotedBlock' and ($IAmLasIntSection='true') and  $isChildLast = 'false' ">
					<xsl:text>true</xsl:text>
				</xsl:when>
				<xsl:when test="$source = 'footNoteExc'">
					<xsl:text>true</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>false</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		
		<xsl:variable name="parentBracket" as="xs:string" select="    if (@changed='not-changed') then 'No'    else if ((not(ancestor-or-self::quoted-block) or $isChildLast = 'false' or $IAmLastTheSibling='true') and  (contains(../@reported-display-style, 'bracket') or contains(../@vbattChangedForReported, 'bracket'))) then 'Yes'    else if ((not(ancestor-or-self::quoted-block) or $isChildLast = 'false' or $IAmLastTheSibling='true') and        ((contains(@reported-display-style, 'bracket') or contains(@vbattChangedForReported, 'bracket') or (local-name(child::*[last()]) = 'toc-entry' and contains(child::*[last()]/@vbattChangedForReported, 'bracket')) )and $source='toc')) then 'Yes'    else if ($source ='afterQuotedBlock' and (contains(parent::quoted-block/descendant::*[position() = last()-1]/ancestor-or-self::*[1]/@reported-display-style, 'bracket') or contains(parent::quoted-block/descendant::*[position() = last()-1]/ancestor-or-self::*[1]/@vbattChangedForReported, 'bracket'))) then 'Yes'    else 'No'" />
		
		<xsl:variable name="parentParens" as="xs:string" select="    if (@changed='not-changed') then 'No'    else if ((not(ancestor-or-self::quoted-block)  or  $isChildLast = 'false' or $IAmLastTheSibling='true') and (contains(../@reported-display-style, 'parentheses') or contains(../@vbattChangedForReported, 'parentheses'))) then 'Yes'    else if ((not(ancestor-or-self::quoted-block) or $isChildLast = 'false' or $IAmLastTheSibling='true') and       ((contains(@reported-display-style, 'parentheses') or contains(@vbattChangedForReported, 'parentheses') or (local-name(child::*[last()]) = 'toc-entry' and contains(child::*[last()]/@vbattChangedForReported, 'parentheses')) )and $source='toc')) then 'Yes'     else if ($source ='afterQuotedBlock'  and ( contains(parent::quoted-block/descendant::*[position() = last()-1]/ancestor-or-self::*[1]/@reported-display-style, 'parentheses') or contains(parent::quoted-block/descendant::*[position() = last()-1]/ancestor-or-self::*[1]/@vbattChangedForReported, 'parentheses'))) then 'Yes'    else 'No'" />
		

		
		<xsl:variable name="toPrintClosedBoldBrackets" as="xs:string">
			<xsl:call-template name="checkSiblingsRule" />
		</xsl:variable>
		
		<xsl:variable name="isCurrentBracketOnDeletedToc" as="xs:string" select="    if (local-name()='toc-entry'       and (@reported-display-style='bold-brackets'       or @vbattChangedForReported='bold-bracktes')) then 'yes'    else 'no'" />
		
		<xsl:variable name="result1" as="xs:string" select="    if (     not(local-name() ='text'       and $billtype ='appropriations'       and $toPrintClosedBoldBrackets='yes'       and (local-name(ancestor::section[1]/node()[position()=last()]) != 'quoted-block'))     and (local-name(node()[position()=last()]) != 'footnote'         or $source = 'footNoteExc')        and (local-name() != 'after-quoted-block'        or( not (deleted-phrase) and not(added-phrase)))        and ($parentBracket='Yes' or $isCurrentBracketOnDeletedToc='yes')        and (($nextBracket='No' and $includesStructuralBracket='No') or $IAmLastTheSibling='true')        and (not (@vbattChangedForReported = 'not-changed') or local-name()='after-quoted-block')     ) then ''    else ''" />
		
		<xsl:variable name="result2" as="xs:string" select="    if (local-name() != 'after-quoted-block'  and $parentParens='Yes' and (($nextParens='No' and $includesStructuralParens='No') or $IAmLastTheSibling='true')) then ''    else if ($source = 'afterQuotedBlock'  and not (deleted-phrase/following-sibling::added-phrase) and $parentParens='Yes' and (($nextParens='No' and $includesStructuralParens='No') or $IAmLastTheSibling='true')) then ''    else ''" />
		
		<xsl:sequence select="concat($result1, $result2)" />
		
	</xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Modifies the input 'string' by replacing all occurences of 'search-for' with 'replace-with'.</desc>
		<param>string: the string to make the changes for.</param>
		<param>search-for: the string to replace.</param>
		<param>replace-with: the replacement string.</param>
		<return>The modified string.</return>
		<gpo:srcXSL>Named Template:  search-and-replace</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:search-and-replace" as="xs:string">
		<xsl:param name="string" as="xs:string" />
		<xsl:param name="search-for" as="xs:string" />
		<xsl:param name="replace-with" as="xs:string" />
		<xsl:value-of select="replace($string, $search-for, $replace-with)" />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc />
		<param>CStage: </param>
		<param>amend-type: The value of the amend-type attribute of the amendement-doc element</param>
		<param>amend-degree: The value of the amend-degree attribute of the amendement-doc element</param>
		<param>amend-id: The value of the dms-id attribute of the amendement-doc element</param>
		<param>amend-num: The value of the amend-num attribute of the amendement-doc element</param>
		<param>public-print: The value of the public-print attribute of the document node</param>
		<param>current-chamber: The value of the current-chamber element</param>
		<return />
		<gpo:srcXSL>Named Template:  ConvStage</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:ConvStage" as="xs:string">
		<xsl:param name="CStage" as="xs:string?" />
		<xsl:param name="amend-type" as="xs:string?" />
		<xsl:param name="amend-degree" as="xs:string?" />
		<xsl:param name="amend-id" as="xs:string?" />
		<xsl:param name="amend-num" as="xs:string?" />
		<xsl:param name="public-print" as="xs:string?" />
		<xsl:param name="current-chamber" as="xs:string?" />
		
		<xsl:variable name="theSlugNumber" as="xs:string" select="gpo:toPrintTheSlugNumber($amend-type, $amend-degree)" />
	
		<xsl:sequence select="if ($amend-id='G') then concat('AMDT.', substring-after(upper-case($amend-num), 'AMENDMENT'))        else if (lower-case($CStage) ='printed-as-passed') then 'PAP'        else if ($CStage='Public-Print' or $public-print='yes') then 'PP'        else if ($CStage='Additional-Sponsors-House') then 'ASH'        else if ($CStage='Additional-Sponsors-Senate') then 'SAS'        else if ($CStage='Agreed-to-House') then 'ATH'        else if ($CStage='Agreed-to-Senate') then 'ATS'        else if ($CStage='Amendment-in-House') then 'AH'        else if ($CStage='Amendment-in-Senate') then 'AS'        else if ($CStage='Committee-Discharged-House') then 'CDH'        else if ($CStage='Committee-Discharged-Senate') then 'CDS'        else if ($CStage='Considered-and-Passed-House') then 'CPH'        else if ($CStage='Considered-and-Passed-Senate') then 'CPS'        else if ($CStage='Engrossed-Amendment-House') then concat('EAH', $theSlugNumber)        else if ($CStage='Engrossed-Amendment-Senate') then concat('EAS', $theSlugNumber)        else if ($CStage='Engrossed-in-House') then concat('EH', $theSlugNumber)        else if ($CStage='Engrossed-in-Senate') then concat('ES', $theSlugNumber)        else if ($CStage='Enrolled-Bill') then 'ENR'        else if ($CStage='Failed-Amendment-House') then 'FAH'        else if ($CStage='Failed-Passage-House') then 'FPH'        else if ($CStage='Failed-Amendment-Senate') then 'FAS'        else if ($CStage='Failed-Passage-Senate') then 'FPS'        else if ($CStage='Held-at-Desk-House') then 'HDH'        else if ($CStage='Held-at-Desk-Senate') then 'HDS'        else if ($CStage='Indefinitely-Postponed-House') then 'IPH'        else if ($CStage='Indefinitely-Postponed-Senate') then 'IPS'        else if ($CStage='Introduced-in-House') then 'IH'        else if ($CStage='Introduced-in-Senate') then 'IS'        else if ($CStage='Laid-on-Table-House') then 'LTH'        else if ($CStage='Laid-on-Table-Senate') then 'LTS'        else if ($CStage='Ordered-to-be-Printed-House') then 'OPH'        else if ($CStage='Ordered-to-be-Printed-Senate') then 'OPS'        else if ($CStage='Placed-on-Calendar-House') then 'PCH'        else if ($CStage='Placed-on-Calendar-Senate') then 'PCS'        else if ($CStage='Pre-Introduction') then ''        else if ($CStage='Re-Enrolled-Bill') then 'RENR'        else if ($CStage='Received-in-House') then 'RDH'        else if ($CStage='Received-in-Senate') then 'RDS'        else if ($CStage='Reengrossed-Amendment-House') then concat('REAH', $theSlugNumber)        else if ($CStage='Reengrossed-Amendment-Senate') then concat('REAS', $theSlugNumber)        else if ($CStage='Reference-Change-House') then 'RCH'        else if ($CStage='Reference-Change-Senate') then 'RCS'        else if ($CStage='Referral-Instructions-House') then 'RIH'        else if ($CStage='Referral-Instructions-Senate') then 'RIS'        else if ($CStage='Referred-in-House') then 'RFH'        else if ($CStage='Referred-in-Senate') then 'RFS'        else if ($CStage='Referred-to-Committee-House') then 'RTH'        else if ($CStage='Referred-to-Committee-Senate') then 'RTS'        else if ($CStage='Referred-w-Amendments-House') then 'RAH'        else if ($CStage='Referred-w-Amendments-Senate') then 'RAS'        else if ($CStage='Reported-in-House') then 'RH'        else if ($CStage='Reported-in-Senate') then 'RS'        else if ($CStage='Sponsor-Change') then 'SC'        else if ($CStage='Engrossed-House' or $CStage='Engrossed-in-House') then concat('EH', $theSlugNumber)        else if ($CStage='Reported-House') then 'RH'        else if ($CStage='Enrolled-House') then 'ENR'        else if ($CStage='Introduced-House') then 'IH'        else if ($CStage='Pre-Introduction') then ''        else if ($CStage='Enrolled-in-Senate') then 'ENR'        else if ($CStage='Re-Enrolled-in-Senate') then 'RENR'        else if (contains($current-chamber,'House')) then concat('EAH', $theSlugNumber)        else if (contains($current-chamber,'Senate')) then concat('EAS', $theSlugNumber)        else ''" />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc />
		<param>SText: </param>
		<return />
		<gpo:srcXSL>Named Template:  SessionText</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:SessionText" as="xs:string">
		<xsl:param name="SText" as="xs:string" />
		<xsl:sequence select="    if ($SText = '1') then 'A T T  H  E F  I  R  S  T S  E  S  S  I  O  N'    else if ($SText = '2') then 'A T T  H  E S  E  C  O  N  D S  E  S  S  I  O  N'    else ''    " />
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc />
		<param>SText: </param>
		<return />
		<gpo:srcXSL>Named Template:  SessionTextAll</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:SessionTextAll" as="xs:string">
		<xsl:param name="SText" as="xs:string" />
		
		<xsl:sequence select=" if (contains($SText ,'First ')) then 'A T T  H  E F  I  R  S  T S  E  S  S  I  O  N'       else if (contains($SText ,'Second')) then 'A T T  H  E S  E  C  O  N  D S  E  S  S  I  O  N'       else if (contains($SText ,'1' )) then 'A T T  H  E F  I  R  S  T S  E  S  S  I  O  N'       else if (contains($SText ,'2')) then 'A T T  H  E S  E  C  O  N  D S  E  S  S  I  O  N'       else ''       " />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Converts a session to a session simple string</desc>
		<param>SText: The input string that contains the session</param>
		<return>A string that spells the session nunmber</return>
		<gpo:srcXSL>Named Template:  SessionTextSimple</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:SessionTextSimple" as="xs:string">
		<xsl:param name="SText" as="xs:string" />
		<xsl:variable name="session_text" as="xs:string">
			<xsl:choose>
				<!--First -->
				<xsl:when test="contains($SText ,'First ')">
					<xsl:text>first session</xsl:text>
				</xsl:when>
				<!--Second-->
				<xsl:when test="contains($SText ,'Second')">
					<xsl:text>second session</xsl:text>
				</xsl:when>
				<!-- 1st-->
				<xsl:when test="contains($SText ,'1' )">
					<xsl:text>first session</xsl:text>
				</xsl:when>
				<!--2nd-->
				<xsl:when test="contains($SText ,'2')">
					<xsl:text>second session</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:value-of select="$session_text" />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc />
		<param>rule: The input string that specifies the line rule</param>
		<return />
		<gpo:srcXSL>Named Template:  lrules</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:lrules" as="xs:string">
		<xsl:param name="rule" as="xs:string?" />
		
		<xsl:sequence select="    if($rule='no-gen') then '0'    else if ($rule='hor') then '1'    else if ($rule='hor-ver') then '2'    else if ($rule='hor-sides') then '3'    else if ($rule='all-gen') then '4'    else if ($rule='hor-trimside') then '5'    else if ($rule='hor-ver-trimside') then '6'    else ''    " />
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc />
		<param>cdef: The input string that specifies the column definition</param>
		<return />
		<gpo:srcXSL>Named Template:  coldefconv</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:coldefconv" as="xs:string">
		<xsl:param name="cdef" as="xs:string" />
		
		<xsl:sequence select="    if ($cdef='trace') then 'tr'    else if ($cdef='fig') then ''    else if ($cdef='txt') then 'r'    else if ($cdef='txt-no-ldr') then 'xl'    else if ($cdef='txt-no-spread') then 'xs'    else if ($cdef='txt-no-ldr-no-spread') then 'xls'    else if ($cdef='align-on-char') then ''    else ''    " />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc />
		<param>sedf: </param>
		<param>SecondCol-for: </param>
		<return />
		<gpo:srcXSL>Named Template:  stubdefconv</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:stubdefconv" as="xs:string?">
		<xsl:param name="sdef" as="xs:string" />
		<xsl:param name="SecondCol" as="xs:boolean" />
		
		<xsl:sequence select="if (not($SecondCol)) then (          if ($sdef='trace') then '50'          else if ($sdef='fig') then ''          else if ($sdef='txt-clr') then '2'          else if ($sdef='txt-ldr') then '0'          else if ($sdef='txt-clr-start-end') then '22'          else if ($sdef='txt-clr-2pts-larger') then '26'          else if ($sdef='txt-ldr-start') then '31'          else if ($sdef='txt-ldr-end') then '38'          else if ($sdef='ctr-start') then '21'          else if ($sdef='ctr-start-end') then '30'          else if ($sdef='ctr-continues-start') then '25'          else if ($sdef='ctr-on-table-start') then '28'          else if ($sdef='table-fnote') then '29'          else if ($sdef='footnote-bottom-page') then '39'          else ''          ) else (           if($sdef = 'txt-clr') then 'lx'          else ''          )         " />
	
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:colmodfconv" as="xs:string?">
		<xsl:param name="cmodf" as="xs:string?" />
		
		<xsl:sequence select="if ($cmodf='parallel') then 'p'        else if ($cmodf='bold') then 'b'        else ''" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:rowmodfconv" as="xs:string?">
		<xsl:param name="rmodf" as="xs:string?" />
		
		<xsl:sequence select="if ($rmodf='bold') then 's'    else if ($rmodf='double') then 'd'    else ''" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:entrymodffconv" as="xs:string?">
		<xsl:param name="emodf" as="xs:string?" />
		
		<xsl:sequence select="if ($emodf='force-ldr') then 'l'    else if ($emodf='force-ldr-bottom') then 'l'    else if ($emodf='ctr-variable') then 'oi0'    else if ($emodf='paragraph') then 'oi1'    else if ($emodf='fl-hang-hier-2') then 'oi2'    else if ($emodf='fl-hang-hier-3') then 'oi3'    else if ($emodf='fl-hang-hier-4') then 'oi4'      else if ($emodf='fl-hang-hier-5') then 'oi5'    else if ($emodf='fl-hang-hier-6') then 'oi6'    else if ($emodf='fl-hang-hier-7') then 'oi7'    else if ($emodf='fl-hang-hier-8') then 'oi8'    else if ($emodf='fl-hang-hier-9') then 'oi9'    else ''" />

	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Used for calculating points of vertical spacing (Q10=10 spacing)</desc>
		<param>pnode: </param>
		<param>pvalue: </param>
		<return>A para node with the appropriate qcode.</return>
		<gpo:srcXSL>Named Template:  getblank-lines-after</gpo:srcXSL>
	</doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="getblank-lines-after" as="node()">
		<xsl:param name="pnode" as="xs:integer" />
		<xsl:param name="pvalue" as="xs:integer" />
		
		<xsl:variable name="qValue" as="xs:string?">
			<xsl:choose>
				<xsl:when test="$pvalue &gt; 0">
					<xsl:choose>
						<xsl:when test="$pnode &gt; 0 ">
							<xsl:sequence select="if ($pvalue &gt; 2) then xs:string($pvalue * 4)             else concat('0', xs:string($pvalue * 4))" />
						</xsl:when>
						<xsl:otherwise>
							<!-- tda maybe? what happens if pvalue gt 7
							<xsl:sequence select="concat($pvalue, '0')"/>
							-->
							<xsl:choose>
								<xsl:when test="$pvalue=1">
									<xsl:text>10</xsl:text>
								</xsl:when>
								<xsl:when test="$pvalue=2">
									<xsl:text>20</xsl:text>
								</xsl:when>
								<xsl:when test="$pvalue=3">
									<xsl:text>30</xsl:text>
								</xsl:when>
								<xsl:when test="$pvalue=4">
									<xsl:text>40</xsl:text>
								</xsl:when>
								<xsl:when test="$pvalue=5">
									<xsl:text>50</xsl:text>
								</xsl:when>
								<xsl:when test="$pvalue=6">
									<xsl:text>60</xsl:text>
								</xsl:when>
								<xsl:when test="$pvalue=7">
									<xsl:text>70</xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<xsl:text>0</xsl:text>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>0</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:element name="para">
			<xsl:attribute name="qcode">
				<xsl:value-of select="$qValue" />
			</xsl:attribute>
		</xsl:element>
		
	</xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>tda: We have to reconsider the logic for this template.</desc>
		<param>node: The input node</param>
		<param>returnval: </param>
		<return />
		<gpo:srcXSL>Named Template:  getInlineHeaderStyle</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:getInlineHeaderStyle" as="xs:string?">
		<xsl:param name="node" as="element()" />
		<xsl:param name="returnval" as="xs:string" />
		<!--BH:  need a fall-thru for @vattGrid-->	
		<xsl:variable name="attGrid" as="xs:string">
			<xsl:choose>
				<xsl:when test="$node/@vbattGrid">
					<xsl:value-of select="$node/@vbattGrid" />
				</xsl:when>
				<xsl:otherwise>G2</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="attType" as="xs:string">
			<!--BH:  Added a choose because the input file did not have any @vbattTypeface attributes-->
			<xsl:choose>
				<xsl:when test="$node/@vbattTypeface">
					<xsl:value-of select="$node/@vbattTypeface" />
				</xsl:when>
				<xsl:otherwise>
					No attribute vbattTypeface
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable> 
		<xsl:variable name="attMode" as="xs:string">
			<!--BH:  Added a choose because the input file did not have any @vbattMode attributes-->
			<xsl:choose>
				<xsl:when test="$node/@vbattMode">
					<xsl:value-of select="$node/@vbattMode" />
				</xsl:when>
				<xsl:otherwise>
					No attribute vbattMode
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="typefaceAndMode" as="xs:string">
			<!--BH Not sure what goes here-->
			<xsl:choose>
				<xsl:when test="not($attGrid='' or $attGrid=' ')">
					<!--<xsl:text>&lt;BEL&gt;</xsl:text>-->
					<para>
						<xsl:attribute name="format">
							<xsl:value-of select="$attGrid" />
						</xsl:attribute>
						<xsl:text>|</xsl:text>
					</para>
				</xsl:when>
				<xsl:when test="not($attType='' or $attType=' ')">
					<!--<xsl:text>&lt;BEL&gt;</xsl:text>-->
					<para>
						<xsl:attribute name="format">
							<xsl:value-of select="$attType" />
						</xsl:attribute>
						<xsl:text>|</xsl:text>
					</para>
				</xsl:when>
				<xsl:when test="not($attMode='' or $attMode=' ')">
					<para>
						<xsl:attribute name="format">
							<xsl:value-of select="$attMode" />
						</xsl:attribute>
					</para>
				</xsl:when>
				<xsl:otherwise><xsl:comment>'typefaceAndMode' not set.</xsl:comment></xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:sequence select="if ($returnval='typeface') then substring-before($typefaceAndMode, '|')    else if ($returnval='mode') then substring-after($typefaceAndMode,'|')    else ''" />
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Capitalizes the first character of the input string. The rest of the string is converted to lower case.</desc>
		<param>words: The string to modify</param>
		<return>The modified string where the first character is capitalized and the rest of the string is lower case.</return>
		<gpo:srcXSL>Named Template:  CapitalizeFirstOnly</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:CapitalizeFirstOnly" as="xs:string">
		<xsl:param name="words" as="xs:string" />
		<xsl:value-of select="concat(upper-case(substring($words, 1, 1)), lower-case(substring($words, 2)))" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:GetNearestAncestorLevelName" as="xs:string">
		<xsl:param name="node" as="element()" />
		<xsl:value-of select="local-name($node/ancestor-or-self::*[         self::account or         self::appropriations-para or         self::chapter or         self::clause or         self::division or         self::item or         self::paragraph or         self::part or         self::rule or         self::rules-clause or         self::rules-item or         self::rules-paragraph or         self::rules-subdivision or         self::rules-subitem or         self::rules-subparagraph or         self::section or         self::subaccount or         self::subchapter or         self::subclause or         self::subdivision or         self::subitem or         self::subparagraph or         self::subpart or         self::subsection or         self::subsubaccount or         self::subsubsubaccount or         self::subtitle or         self::title         ][1])" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:GetNearestAncestorWithIdName" as="xs:string">
		<xsl:param name="node" as="element()" />
		<xsl:value-of select="local-name($node/ancestor-or-self::*[          self::account or         self::appropriations-para or       self::chapter or        self::clause or        self::constitution-article or        self::division or        self::enum or        self::external-xref or        self::footnote or        self::formula or        self::internal-xref or        self::item or        self::legis-body or        self::paragraph or        self::part or        self::quoted-block or        self::resolution-body or        self::rule or        self::rules-clause or        self::rules-item or        self::rules-paragraph or        self::rules-subdivision or        self::rules-subitem or        self::rules-subparagraph or        self::section or        self::subaccount or        self::subchapter or        self::subclause or        self::subdivision or        self::subitem or        self::subparagraph or        self::subpart or        self::subsection or        self::subsubaccount or        self::subsubsubaccount or        self::subtitle or        self::title          ][1])" />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Finds the nearest element to $node that has a valid style value. This function matches the logic used in the template even thought
			I think that the GetNearestAncestorStyleValue1() function expresses better what the function tries to accomplish</desc>
		<param>node: The current node</param>
		<param>billStyle: The value of the bill-type atribute of the bill document node</param>
		<param>restype: The value of the esolution-type atribute of the resolution document node</param>
		<return>The style value from the nearest node</return>
		<gpo:srcXSL>Named Template:  GetNearestAncestorStyleValue</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:GetNearestAncestorStyleValue" as="xs:string">
		<xsl:param name="node" as="element()" />
		<xsl:param name="billStyle" as="xs:string?" />
		<xsl:param name="restype" as="xs:string?" />
		
		<xsl:variable name="mainStyle" as="xs:string" select="normalize-space($node/ancestor-or-self::*[@style!=''][position()=1]/@style)" />
		
		<xsl:variable name="result" as="item()*">
			<xsl:if test="$mainStyle=''">
				<xsl:choose>
					<xsl:when test="$billStyle=''">
						<xsl:value-of select="$restype" />
					</xsl:when>
					<xsl:when test="$billStyle = 'olc'">
						<xsl:text>OLC</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$billStyle" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			<xsl:if test="$mainStyle='other'">
				<xsl:value-of select="normalize-space($node/ancestor-or-self::*[@other-style!=''][position()=1]/@other-style)" />
			</xsl:if>
			<xsl:if test="not($mainStyle='other')">
				<xsl:value-of select="$mainStyle" />
			</xsl:if>
		</xsl:variable>
		
		<xsl:value-of select="string-join($result,'')" />
	</xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="KeepParentsFormatOrSelf" as="item()*">
		<xsl:param name="node" as="element()" select="." />
		
		<xsl:variable name="rstyles" as="xs:string" select="gpo:GetChangedForReported($node)" />
		<xsl:variable name="vbattParentFormat" as="xs:string" select="normalize-space($node/@vbattParentFormat)" />
		<xsl:variable name="display-inline" as="xs:string" select="normalize-space($node/@display-inline)" />
		<xsl:variable name="parent-display-inline" as="xs:string" select="normalize-space($node/../@display-inline)" />
		<xsl:variable name="section-type" as="xs:string" select="normalize-space($node/@section-type)" />
		<xsl:choose>
			<xsl:when test="ancestor::amendment-block">
				<para format="6203" />
			</xsl:when>
			<xsl:when test="$vbattParentFormat = 'AddOrDelete'">
				<xsl:if test="not($display-inline='yes-display-inline')         or  ($display-inline='yes-display-inline'           and $section-type='undesignated-section'           and $node/ancestor::amendment-block and $node/ancestor::committee-report)         or  $node/parent::resolution-body[@display-resolving-clause='no-display-resolving-clause']/section[1]/@section-type='undesignated-section' ">
					<xsl:call-template name="AddorDelete" />
				</xsl:if>
			</xsl:when>
			<xsl:when test="$vbattParentFormat='GetParentsFormat'     and (not($display-inline) or $display-inline='no-display-inline')">
				<xsl:call-template name="GetParentsFormat">
					<xsl:with-param name="rstyles" select="$rstyles" />
				</xsl:call-template>
			</xsl:when>
			<xsl:when test="$node/ancestor::*/amendment-list">
				<!-- Nothing -->
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="$display-inline='yes-display-inline'">
						<xsl:text />
					</xsl:when>
					<xsl:otherwise>
						<xsl:variable name="linesNumAttr" as="xs:string?" select="gpo:getLineNumbersValue($node)" />
						<xsl:if test="not($linesNumAttr = 'off')">
							<xsl:sequence select="gpo:bell2Xml($vbattParentFormat)" />
						</xsl:if>
						<xsl:if test="$linesNumAttr = 'off'">
							<xsl:call-template name="AddOrDeleteCommon">
								<xsl:with-param name="node" select="$node" />
								<xsl:with-param name="displayStyleCurrent" select="$rstyles" />
								<xsl:with-param name="displayStyleParent" select="$parent-display-inline" />
								<xsl:with-param name="aLinesNumbers" select="$linesNumAttr" />
								<xsl:with-param name="vbattChangedForReported" select="$vbattParentFormat" />
							</xsl:call-template>
						</xsl:if>
					</xsl:otherwise>
				</xsl:choose>
				
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:GetChangedForReported" as="xs:string">
		<xsl:param name="node" as="element()" />
		<xsl:sequence select="normalize-space($node/@vbattChangedForReported)" />
	</xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="GetChangedForReported">
		<xsl:value-of select="./@vbattChangedForReported" />
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="GetParentsFormat" as="node()">
		<xsl:param name="rstyles" as="xs:string?" />
		
		<!-- TODO: moved the if to the calling code and remove node from param -->
		<!--
		<xsl:if test="not($node/@display-inline) or $node/@display-inline='no-display-inline'">
		-->
			<xsl:choose>
				<xsl:when test="$rstyles='italic'">
					<para format="6203" />
				</xsl:when>
				<xsl:when test="$rstyles='strikethrough'">
					<para format="6401" />
				</xsl:when>
				<xsl:when test="$rstyles='boldface-roman'  or $rstyles='brackets-boldface-roman' ">
					<para format="6202" />
				</xsl:when>
				<xsl:when test="$rstyles='boldface-italic' or $rstyles='brackets-boldface-italic' ">
					<para format="6204" />
				</xsl:when>
				<xsl:when test="$rstyles='not-changed'">
					<para format="6201" />
				</xsl:when>
				<xsl:otherwise>
					<para format="6201" />
				</xsl:otherwise>
			</xsl:choose>
		<!--
		</xsl:if>
		-->
	</xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>This template is written to determine when the I90 line should be printed.
			The rules:
			-If the stage is Pre-Introduction, we do not output
			-If the stage is 'Reported' and contains either the following meta-house or meta-senate, we do not output
			-In all other cases we do output</desc>
		<param>dms-id: the value of //amendment-doc/@dms-id</param>
		<param>restype: </param>
		<param>billtype: the value of //bill/@type</param>
		<param>pre-form: true if //pre-form element node exists</param>
		<param>bill-key: the value of //bill/@key</param>
		<param>bill-dms-version: the value of //bill/@dms-version</param>
		<param>bill-stage: The value of the bill-stage attribute of the bill root element</param>
		<param>resolution-stage: The value of the resolution-stage attribute of the resolution root element</param>
		<return>returns true if the I90 line should be printed, returns false otherwise</return>
		<gpo:srcXSL>Named Template:  toOutputI90Line</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:toOutputI90Line" as="xs:boolean">
		<xsl:param name="dms-id" as="xs:string" />
		<xsl:param name="restype" as="xs:string" /> 
		<xsl:param name="billtype" as="xs:string" />
		<xsl:param name="pre-form-exists" as="xs:boolean" />
		<xsl:param name="bill-key" as="xs:string" />
		<xsl:param name="bill-dms-version" as="xs:string" />
		<xsl:param name="bill-stage" as="xs:string" />
		<xsl:param name="resolution-stage" as="xs:string" />
		
		<xsl:sequence select="    if ($dms-id='G') then true()    else if ($restype='senate-order' or $restype='house-order') then false()    else if ($billtype='appropriations' and  $pre-form-exists and $bill-key='G' and $bill-dms-version!='') then true()    else if ($pre-form-exists) then false()    else if (contains($bill-stage,'Pre-Introduction') or contains($resolution-stage,'Pre-Introduction')) then false()    else if (contains($bill-stage, 'Enrolled') or contains($resolution-stage, 'Enrolled')) then false()    else true()    " />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Gives true of false if the bill-stage is Received-in-House, Referred-in-House, Received-in-Senate, or Referred-in-Senate.  If any
			of these are found, we do not output the official title</desc>
		<param>bill-stage: The value of the bill-stage attribute of the bill root element</param>
		<param>m_legisNumber: The legis number</param>
		<param>resolution-stage: The value of the resolution-stage attribute of the resolution root element</param>
		<return>The style value from the nearest node</return>
		<gpo:srcXSL>Named Template:  GetNearestAncestorStyleValue</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:ToOutputOfficialTitle" as="xs:boolean">
		<xsl:param name="bill-stage" as="xs:string" />
		<xsl:param name="m_legisNumber" as="xs:string" />
		<xsl:param name="resolution-stage" as="xs:string" />

		<xsl:sequence select="    if ($bill-stage='Placed-on-Calendar-Senate'       and starts-with($m_legisNumber,'S')) then true()    else if ($bill-stage='Placed-on-Calendar-House'        and starts-with($m_legisNumber,'H')) then true()    else if ($bill-stage='Received-in-House'       or $bill-stage='Referred-in-House'       or $bill-stage='Received-in-Senate'       or $bill-stage='Referred-in-Senate'       or $bill-stage='Placed-on-Calendar-House'       or $bill-stage='Placed-on-Calendar-Senate'         or $bill-stage='Laid-on-Table-House'        or $bill-stage='Indefinitely-Postponed-House'       or $bill-stage='Held-at-Desk-House'      or $bill-stage='Considered-and-Passed-House'       or $bill-stage='Committee-Discharged-House'      or $bill-stage='Agreed-to-House'       or $bill-stage='Additional-Sponsors-House') then false()    else if ($resolution-stage='Referred-in-Senate'       or $resolution-stage='Received-in-Senate') then false()    else true()    " />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:GetNearestAncestorStyleRecursive" as="xs:string">
		<xsl:param name="node" as="element()" />
		<xsl:param name="sectionStyleOverlapped" as="xs:boolean" />
		<xsl:choose>
			<xsl:when test="(      (local-name($node)='section'        or (local-name($node)='enum' and $node/parent::section)        or (local-name($node)='header' and $node/parent::section)      )        or (       local-name($node)= 'added-phrase'        and ($node/parent::enum or $node/parent::header)        and local-name($node/ancestor::*[2]) = 'section' )      )       and $sectionStyleOverlapped and $node/ancestor-or-self::*[@section-style!=''][1]">
				
				<xsl:variable name="sectionStyleValue" as="xs:string">
					<xsl:choose>
						<xsl:when test="$node/ancestor-or-self::*[@section-style!=''][1]">
							<xsl:choose>
								<xsl:when test="$node/ancestor-or-self::*[@section-style!=''][1]/descendant::quoted-block[@style!='']  = $node/ancestor-or-self::quoted-block[@style!=''] ">
									<xsl:text>noSectionStyle</xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="$node/ancestor-or-self::*[@section-style!=''][1]/@section-style" />
								</xsl:otherwise>
							</xsl:choose>
						</xsl:when>
						<xsl:otherwise>
							<xsl:text>noSectionStyle</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				
				
				<xsl:choose>
					<xsl:when test="$sectionStyleValue='usc-section-style'">
						<xsl:text>USC</xsl:text>
					</xsl:when>
					<xsl:when test="$sectionStyleValue='olc-section-style'">
						<xsl:text>OLC</xsl:text>
					</xsl:when>
					<xsl:when test="$sectionStyleValue='traditional-section-style'">
						<xsl:text>traditional</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<!-- check parent node -->
						<xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node/parent::node(), true())" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			
			<xsl:when test="$node/@style and $node/@style='appropriations' and local-name($node)='section' ">
				<xsl:text>traditional</xsl:text>
			</xsl:when>
			<xsl:when test="$node/@style and $node/@style='other' and $node/@other-style='appropriations' and  local-name($node)='section' ">
				<xsl:text>traditional</xsl:text>
			</xsl:when>
			<xsl:when test="$node/@style">
				<xsl:choose>
				<xsl:when test="$node/@style='other'">
					<xsl:value-of select="$node/@other-style" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$node/@style" />
				</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>OLC</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Finds the indent for a specific element. It looks like this function should concatenate all indents for a list of elements
		but the way it is written it does something else (the two ifs below should be an if/else</desc>
		<param>cnode: the current element to start the search from</param>
		<param>level: the element node to look for to terminate the search</param>
		<return>The string % followed by the value of the indent attribute for the $level element</return>
		<gpo:srcXSL>Named Template:  FindIndent</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:FindIndent" as="xs:string">
		<xsl:param name="cnode" as="element()" />
		<xsl:param name="level" as="xs:string?" />
		
		<xsl:variable name="indents" as="xs:string*">
			<xsl:for-each select="$cnode">
				<xsl:if test="local-name()=$level and @indent != ''">
					<xsl:text>%</xsl:text>
					<xsl:value-of select="@indent" />
				</xsl:if>
				<xsl:if test="count($cnode/descendant::*) &gt; 0">
					<xsl:value-of select="gpo:FindIndent(descendant::*[1], $level)" />
				</xsl:if>
			</xsl:for-each>
		</xsl:variable>
		
		<xsl:sequence select="string-join($indents, '')" />
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Fixes an indent string</desc>
		<param>indent-string: The string to fix</param>
		<return>The string after the last % sign with all spaces removed</return>
		<gpo:srcXSL>Named Template:  FixIndentString</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:FixIndentString" as="xs:string">
		<xsl:param name="indent-string" as="xs:string" />
		
		<xsl:choose>
			<xsl:when test="contains($indent-string, '%')">
				<xsl:value-of select="gpo:FixIndentString(substring-after($indent-string, '%'))" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="translate($indent-string, ' ', '')" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>Finds the indent for a specific element and fixes it.</desc>
		<param>pnode: the current element to start the search from</param>
		<param>level: the element node to look for to terminate the search</param>
		<return>The indent attribute for the $level element</return>
		<gpo:srcXSL>Named Template:  GetIndent</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:GetIndent" as="xs:string">
		<xsl:param name="pnode" as="element()" />
		<xsl:param name="level" as="xs:string?" />
		<xsl:variable name="indent-string" as="xs:string" select="gpo:FindIndent($pnode, $level)" />
		<xsl:sequence select="gpo:FixIndentString($indent-string)" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:GetConferenceReportStyle" as="xs:string?">
		<xsl:param name="node" as="element()" />
		<xsl:sequence select="normalize-space($node/@conference-report-style)" />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>starPrint</desc>
		<param>star-print: The value of the biil or resolution star-print attribute</param>
		<return>A string indicatting how many stars to print</return>
		<gpo:srcXSL>Named Template:  starPrint</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:starPrint" as="xs:string">
		<xsl:param name="star-print" as="xs:string?" />
		
		<xsl:sequence select="if ($star-print='first-star-print') then '1'    else if ($star-print='second-star-print') then '2'    else if ($star-print='third-star-print') then '3'    else if ($star-print='fourth-star-print') then '4'    else if ($star-print='fifth-star-print') then '5'    else if ($star-print='sixth-star-print') then '6'    else if ($star-print='seventh-star-print') then '7'    else if ($star-print='eighth-star-print') then '8'    else if ($star-print='ninth-star-print') then '9'    else if ($star-print='tenth-star-print') then '10'    else '0'    " />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>AddOrDeleteCommon</desc>
		<param>node: The current node</param>
		<param>displayStyleCurrent: the current display-style</param>
		<param>displayStyleParent: the parent's display-style</param>
		<param>aLinesNumbers: the current line-numbers (on or off)</param>
		<param>vbattChangedForReported: the vbattChangedForReported of the current element</param>
		<return>A para element with the appropriate subformat code S</return>
		<gpo:srcXSL>Named Template:  AddOrDeleteCommon</gpo:srcXSL>
	</doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="AddOrDeleteCommon" as="node()">
		<xsl:param name="node" as="element()" select="." />
		<xsl:param name="displayStyleCurrent" as="xs:string?" select="'normal'" />
		<xsl:param name="displayStyleParent" as="xs:string?" select="'normal'" />
		<xsl:param name="aLinesNumbers" as="xs:string?" select="'on'" />
		<xsl:param name="vbattChangedForReported" as="xs:string?" select="''" />
		
		<xsl:choose>
			<xsl:when test="$aLinesNumbers='off'">
				<xsl:choose>
					<xsl:when test="($displayStyleCurrent='italic' or $displayStyleParent='italic' or $vbattChangedForReported='italic')        and ($node/ancestor::ramseyer or $node/ancestor::cordon)">
						<para format="6603" />
					</xsl:when>
					<xsl:when test="$displayStyleCurrent='italic'        or $displayStyleParent='italic'        or $vbattChangedForReported='italic' ">
						<para format="6303" />
					</xsl:when>
					<xsl:when test="$displayStyleCurrent='strikethrough'        or $displayStyleParent='strikethrough'        or $vbattChangedForReported='strikethrough'">
						<para format="6301" />
					</xsl:when>
					<xsl:when test="contains($displayStyleCurrent, 'boldface-roman')        or contains($displayStyleParent, 'boldface-roman')        or contains($vbattChangedForReported, 'boldface-roman')">
						<para format="6301" />
					</xsl:when>
					<xsl:when test="contains($displayStyleCurrent, 'boldface-italic')        or contains($displayStyleParent, 'boldface-italic')        or  contains($vbattChangedForReported, 'boldface-italic')">
						<para format="6303" />
					</xsl:when>
					<xsl:otherwise>
						<para format="6301" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="$displayStyleCurrent='italic'        or ($displayStyleParent='italic'  and $displayStyleCurrent = '')        or $vbattChangedForReported='italic' ">
						<para format="6203" />
					</xsl:when>
					<xsl:when test="$displayStyleCurrent='strikethrough'        or ($displayStyleParent='strikethrough' and $displayStyleCurrent = '')         or $vbattChangedForReported='strikethrough'">
						<para format="6401" />
					</xsl:when>
					<xsl:when test="contains($displayStyleCurrent, 'boldface-roman')        or (contains($displayStyleParent, 'boldface-roman') and $displayStyleCurrent = '')         or contains($vbattChangedForReported, 'boldface-roman')">
						<para format="6202" />
					</xsl:when>
					<xsl:when test="contains($displayStyleCurrent, 'boldface-italic')        or (contains($displayStyleParent, 'boldface-italic') and $displayStyleCurrent = '')         or  contains($vbattChangedForReported, 'boldface-italic')">
						<para format="6204" />
					</xsl:when>
					<xsl:otherwise>
						<para format="6201" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="AddorDelete" as="item()*">
		<xsl:param name="node" as="element()" select="." />

		<!--we do not need to a new format if the legis-body has an attribute of changed-->
		<xsl:variable name="LineNumbersAttr" as="xs:string" select="gpo:getLineNumbersValue($node)" />
			
		<!-- <xsl:variable name="theCommitteeID" as="xs:string?" select="//committee-report/@committee-id"/> -->
			
		<xsl:choose>
			<xsl:when test=" (ancestor::resolution-body[2] and parent::resolution-body/section[1]) or (ancestor::legis-body/@changed and not(self::toc) ) or                            ((not(@display-inline) or @display-inline='no-display-inline'  or (@display-inline='yes-display-inline' and @section-type='undesignated-section' and ancestor::amendment-block and ancestor::committee-report)) and not(@changed)  and                            not ((ancestor::whereas) or                             (/amendment-doc[@amend-type='conference-report']) or                             (/amendment-doc[@amend-type='engrossed-amendment']) or                             ((/bill/@bill-stage='Enrolled-Bill' or /resolution/@resolution-stage='Enrolled-House'              or /resolution/@resolution-stage='Enrolled-in-Senate'  or  /resolution/@resolution-stage='Enrolled-Bill')) or                            (contains(/resolution/@resolution-stage, 'Engrossed')  and ( /resolution/@resolution-type='senate-resolution'  or  /resolution/@resolution-type='house-resolution' )  and ((//whereas) or (//resolution-body))) or                             (self::legis-comment))                            )">
				<xsl:variable name="rstyles" as="xs:string" select="gpo:GetChangedForReported($node)" />
					
				<xsl:choose>
					<xsl:when test="$rstyles='not-changed'">
						<xsl:choose>
							<xsl:when test="/amendment-doc/@amend-type='house-amendment' and                                         (@display-inline='yes-display-inline'                                    or child::*[attribute::display-inline='yes-display-inline'])">
								<xsl:text />
							</xsl:when>
							<xsl:when test="//committee-report           and ancestor-or-self:: amendment-block/@margin-indent='yes'             and not (ancestor-or-self:: amendment-block/legis-body)">
								<para format="6969" />
							</xsl:when>
							<xsl:when test="ancestor-or-self::amendment-block           and (ancestor-or-self::amendment-block/ancestor::committee-report-segment or ancestor-or-self::amendment-block/ancestor::committee-report-part)  and not (ancestor-or-self::ramseyer) and not (ancestor-or-self::cordon)">

								<para format="6621" />

							</xsl:when>

							<xsl:when test="ancestor-or-self::*[@line-numbers='off']">
								<para format="6301" />
							</xsl:when>
							<xsl:when test="($resstage='Engrossed-in-Senate'             or  $resstage='Engrossed-House'             or  $resstage='Engrossed-in-House')           and  ($restype='house-resolution' or  $restype='house-order' or  $restype='senate-order') ">
								<para format="6300" />
							</xsl:when>
							<xsl:when test="(starts-with($docstage, 'Enrolled-'))">
								<para format="6501" />
							</xsl:when>
							<xsl:otherwise>
									<para format="6201" />	
							</xsl:otherwise>
						</xsl:choose>
					</xsl:when>
					<xsl:when test="contains($rstyles, 'boldface-roman') or (@vbattChangedForReported='boldface-roman') and not ($LineNumbersAttr='off')">
						<para format="6202" />
					</xsl:when>
					<xsl:when test="contains($rstyles, 'boldface-italic') or (@vbattChangedForReported='boldface-italic' ) and not ($LineNumbersAttr='off') ">
						<para format="6204" />
					</xsl:when>
					<xsl:when test="$rstyles='strikethrough' and not ($LineNumbersAttr='off')">
						<para format="6401" />
					</xsl:when>
					<xsl:when test="$rstyles='italic'">
						<xsl:if test="not(ancestor-or-self::amendment-block) or (not ((ancestor::whereas) or                                                                                                       (/amendment-doc[@amend-type='conference-report']) or                                                                                                        (/amendment-doc[@amend-type='engrossed-amendment']) or                                                                                                        ((/bill/@bill-stage='Enrolled-Bill' or /resolution/@resolution-stage='Enrolled-House'  or /resolution/@resolution-stage='Enrolled-in-Senate'  or  /resolution/@resolution-stage='Enrolled-Bill')) or                                                                                                       (contains(/resolution/@resolution-stage, 'Engrossed')  and ( /resolution/@resolution-type='senate-resolution'  or  /resolution/@resolution-type='house-resolution' )  and ((//whereas) or (//resolution-body))) or                                                                                                        (self::legis-comment)))">
							<xsl:choose>
								<xsl:when test="$LineNumbersAttr='off' and (ancestor::ramseyer or ancestor::cordon)">
									<para format="6603" />
								</xsl:when>
								<xsl:when test="$LineNumbersAttr='off'">
									<para format="6303" />
								</xsl:when>
								<xsl:otherwise>
									<para format="6203" />
								</xsl:otherwise>
							</xsl:choose>
						</xsl:if>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="AddOrDeleteCommon">
							<xsl:with-param name="displayStyleCurrent">
								<xsl:value-of select="@reported-display-style" />
							</xsl:with-param>
							<xsl:with-param name="displayStyleParent">
								<xsl:value-of select="../@reported-display-style" />
							</xsl:with-param>
							<xsl:with-param name="aLinesNumbers" select="gpo:getLineNumbersValue(.)" />
						</xsl:call-template>

					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>

			<xsl:otherwise>
				<xsl:variable name="firstUndesignatedInBlock" as="xs:string">
					<xsl:call-template name="IsSectionFirstInBlockUndesignated" />
				</xsl:variable>
				<xsl:if test="not(@display-inline) or @display-inline='no-display-inline' or (@display-inline='yes-display-inline'  and  $firstUndesignatedInBlock='yes') ">
					<xsl:choose>
						<xsl:when test="ancestor::whereas">							
							<xsl:choose>
								<xsl:when test="contains(lower-case($docstage), 'enrolled')">
									<!-- nothing - skip the step -->
								</xsl:when>
								<xsl:when test="local-name(/*)='resolution'">
									<para format="6300" />
								</xsl:when>
								<xsl:when test="not(@changed) or @changed='not-changed'">
									<para format="6301" />
								</xsl:when>
								<xsl:when test="@reported-display-style='italic'">
									<para format="6304" />
								</xsl:when>
								<xsl:when test="@reported-display-style='strikethrough'">
									<para format="6303" />
								</xsl:when>
								<xsl:otherwise>
									<para format="6301" />
								</xsl:otherwise>
							</xsl:choose>
						</xsl:when>
						<xsl:otherwise>

							<xsl:variable name="rstyles" as="xs:string?" select="gpo:GetChangedForReported($node)" />
							
							<xsl:choose>
					
								<xsl:when test="(/bill/@bill-stage='Enrolled-Bill'                                                  or /resolution/@resolution-stage='Enrolled-House'                                                 or /resolution/@resolution-stage='Enrolled-in-Senate'                                                 or  /resolution/@resolution-stage='Enrolled-Bill')">
									<para format="6501" />
								</xsl:when>
								<xsl:when test="contains(/resolution/@resolution-stage, 'Engrossed')                                                 and ( /resolution/@resolution-type='senate-resolution'                                                  or  /resolution/@resolution-type='house-resolution' )                                                and ((//whereas) or (//resolution-body))">
									<para format="6300" />
								</xsl:when>
								<xsl:when test="self::legis-comment">
									<para format="6301" />
								</xsl:when>
								<xsl:when test="@changed='deleted'">
									<!--BH: modified datatype from xs:string to node() based
										on amendment.xsl-->
									<xsl:variable name="testRStyles" as="node()">
										<xsl:call-template name="AddOrDeleteCommon">
											<xsl:with-param name="displayStyleCurrent" select="$rstyles" />
											<xsl:with-param name="aLinesNumbers" select="gpo:getLineNumbersValue($node)" />
										</xsl:call-template>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="contains($testRStyles,'6201')">
											<xsl:call-template name="AddOrDeleteCommon">
												<xsl:with-param name="displayStyleCurrent" select="@reported-display-style" />
												<xsl:with-param name="displayStyleParent" select="../@reported-display-style" />
												<xsl:with-param name="aLinesNumbers" select="gpo:getLineNumbersValue($node)" />
											</xsl:call-template>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="$testRStyles" />
										</xsl:otherwise>
									</xsl:choose>
								</xsl:when>
								<xsl:otherwise>
									<xsl:call-template name="AddOrDeleteCommon">
										<xsl:with-param name="displayStyleCurrent" select="@reported-display-style" />
										<xsl:with-param name="aLinesNumbers" select="gpo:getLineNumbersValue($node)" />
									</xsl:call-template>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:getLineNumbersValue" as="xs:string?">
		<xsl:param name="node" as="element()" />
		
		<xsl:choose>
			<xsl:when test="$node/ancestor-or-self::amendment-instruction">
				<xsl:choose>
					<xsl:when test="not ($node/ancestor-or-self::amendment-instruction/@line-numbers)         and $node/ancestor-or-self::amendment-block">
						<xsl:value-of select="$node/ancestor-or-self::amendment-block/@line-numbers" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$node/ancestor-or-self::amendment-instruction/@line-numbers" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="not($node/ancestor-or-self::amendment-instruction)        and $node/ancestor-or-self::amendment-block        and $node/ancestor-or-self::amendment-block/@line-numbers">
				<xsl:value-of select="$node/ancestor-or-self::amendment-block/@line-numbers" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="'on'" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="getLineNumbersValue">
		<xsl:param name="node" />
		<!--BH:  This needs to be rewritten-->
	<!--	<xsl:choose>
			<xsl:when test="$node/ancestor-or-self::amendment-instruction">
				<xsl:choose>
					<xsl:when
						test="not ($node/ancestor-or-self::amendment-instruction/@line-numbers) and $node/ancestor-or-self::amendment-block">
						<xsl:value-of select="$node/ancestor-or-self::amendment-block/@line-numbers"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$node/ancestor-or-self::amendment-instruction/@line-numbers"
						/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when
				test="not($node/ancestor-or-self::amendment-instruction) and $node/ancestor-or-self::amendment-block and $node/ancestor-or-self::amendment-block/@line-numbers">
				<xsl:value-of select="$node/ancestor-or-self::amendment-block/@line-numbers"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>on</xsl:text>
			</xsl:otherwise>
		</xsl:choose>-->
	</xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>This template is needed when the legis-body has a changed attribute and the toc elements in encountered.  
			The toc information needs to be 10 more than the current 
			format.  So if the changed attribute is 'italic', the current format is S6203.  
			This will make the toc format S6213. If the current format is S6204, then the toc format will need to be 
			S6214, and so on...</desc>
		<param>node: The current node</param>
		<param>docstage: The value of the amend-stage attribute of the document node</param>
		<param>amend-type: The value of the amend-type attribute of amendement-doc</param>
		<return>A para element with the appropriate subformat code S</return>
		<gpo:srcXSL>Named Template:  LegisBodyWithChangedAttribute</gpo:srcXSL>
	</doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="LegisBodyWithChangedAttribute" as="item()">
		<xsl:param name="node" as="element()?" select="." />
		<xsl:param name="docstage" as="xs:string?" />
		<xsl:param name="amend-type" as="xs:string?" />
		
		<xsl:choose>
			<xsl:when test="not($amend-type='conference-report')">
				
				<xsl:variable as="xs:string" name="ChangedForReported" select="gpo:GetChangedForReported($node)" />
				
				<xsl:choose>
					<xsl:when test="$node/ancestor::legis-body/@reported-display-style='italic'        or $ChangedForReported='italic'">
						<para format="6203" />
					</xsl:when>
					<xsl:when test="$node/ancestor::legis-body/@reported-display-style='strikethrough'         or $ChangedForReported='strikethrough'">
						<para format="6401" />
					</xsl:when>
					<xsl:when test="$node/ancestor::legis-body/@reported-display-style='boldface-roman'        or $ChangedForReported='boldface-roman'">
						<para format="6202" />
					</xsl:when>
					<xsl:when test="contains($docstage,'Enrolled-')">
						<para format="6501" />
					</xsl:when>
					<xsl:otherwise>
						<para format="6201" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:QuotedBlockNestingStart" as="xs:string">
		<xsl:param name="node" as="element()" />
		
		<!-- TODO: this should be a parameter -->
		<!--Issue #68 -->
		<xsl:variable name="depth" as="xs:integer" select="count($node/ancestor::quoted-block)        + count($node/ancestor-or-self::quote)        + count($node/ancestor-or-self::term)" />
		<xsl:sequence select="     if ($depth &gt; 0) then     (     if ($depth mod 2) then '“'      else '```'     )     else ''    " />
	</xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="QuotedBlockNestingEnd" as="item()*">
		<xsl:param name="node" as="element()" select="." />
		
		<xsl:variable name="depth" as="xs:integer" select="count($node/ancestor::quoted-block) + count($node/ancestor-or-self::quote) + count($node/ancestor-or-self::term)" />

		<xsl:if test="not(local-name($node/preceding-sibling::*[position()=1])='table')">
			<xsl:if test="$depth &gt; 0">
				<xsl:choose>
					<xsl:when test="($depth mod 2) = 1">
						<!-- fixes issue #176 -->
						<xsl:text>”</xsl:text>
					</xsl:when>
					<xsl:when test="($depth mod 2) = 0">
						<xsl:text>'</xsl:text>
					</xsl:when>
					<xsl:when test="local-name($node/following::*[1])='after-quoted-block'">
						<xsl:text>'</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>'''</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			
			<xsl:variable name="style" as="xs:string" select="gpo:GetNearestAncestorStyleRecursive(., true())" />

			<xsl:if test="/bill[@bill-stage='Introduced-in-House'] and $style='USC'">
				<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:if>
		</xsl:if>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="leftPadWithSpaces">
		<xsl:param name="text" />
		<xsl:param name="amount" />
		<xsl:choose>
			<xsl:when test="$amount">
				<xsl:text> </xsl:text>
				<xsl:call-template name="leftPadWithSpaces">
					<xsl:with-param name="text" select="$text" />
					<xsl:with-param name="amount" select="$amount - 1" />
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$text" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="spaceForAddedDeletedPhrase">
		<!-- NB 6/14/2006 - created new template to put out trailing space, as needed -->
		<!-- SM 061807 If within enum there should be no space -->
		<xsl:variable name="secondPartText" select="following-sibling::*[1]/text()" as="item()*" />
		<xsl:variable name="isNoTextFollowing" as="xs:string">
			<xsl:call-template name="noTextInBetween">
				<xsl:with-param name="aFirstPartText">
					<xsl:value-of select="normalize-space(.)" />
				</xsl:with-param>
				<xsl:with-param name="aSecondPartText">
					<xsl:value-of select="$secondPartText" />
				</xsl:with-param>
			</xsl:call-template>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="(following-sibling::added-phrase or following-sibling::deleted-phrase) and parent::enum">
				<xsl:text>⁠</xsl:text>
			</xsl:when>
			<xsl:when test="(local-name() = 'deleted-phrase' or local-name() = 'added-phrase' )  and  (following-sibling::added-phrase or following-sibling::deleted-phrase) ">
				<!-- TB 10MAr2008 Bug #878 -->
				<!-- nothing -->
			</xsl:when>
			<xsl:when test="(local-name() = 'deleted-phrase'  or local-name() = 'added-phrase' ) and following-sibling::italic">
				<!-- TB 10MAr2008 Bug #878 -->
				<!-- nothing -->
			</xsl:when>
			<xsl:when test="(following-sibling::added-phrase or following-sibling::deleted-phrase) and $isNoTextFollowing='true'">
				<xsl:text> </xsl:text>
			</xsl:when>
		</xsl:choose>

	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="getEnumInHeaderEscape" as="xs:string">
		<xsl:param name="node" as="element()" select="." />
		
		<xsl:choose>
			<xsl:when test="local-name($node) = 'header-in-text'">
				<xsl:choose>
					<xsl:when test="$node/@level = 'section'">
						<xsl:variable name="style" as="xs:string?" select="gpo:GetNearestAncestorStyleValue($node, $billstage, $resstage)" />
						<xsl:choose>
							<xsl:when test="starts-with($style , 'traditional') or starts-with($style , 'archaic')">
								<xsl:text>K-T4</xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text />
							</xsl:otherwise>
						</xsl:choose>
					</xsl:when>
					<xsl:when test="$node/@level = 'subsection' or local-name($node) = 'subsection'">
						<xsl:variable name="style" as="xs:string?" select="gpo:GetNearestAncestorStyleValue($node, $billstage, $resstage)" />
						<xsl:if test="not(contains($style,'archaic'))">
							<xsl:text>K-T5</xsl:text>
						</xsl:if>
					</xsl:when>
					<xsl:when test="$node/@level = 'paragraph' or $node/@level = 'subparagraph' or $node/@level = 'clause' or $node/@level = 'subclause' or $node/@level = 'item' or $node/@level = 'subitem'">
						<xsl:text>K-T4</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="local-name($node) = 'part' or local-name($node) = 'section'">
				<xsl:variable name="style" as="xs:string?" select="gpo:GetNearestAncestorStyleValue($node, $billstage, $resstage)" />
				<xsl:choose>
					<xsl:when test="(starts-with($style , 'traditional' ) and local-name($node) = 'part'  ) or ($style='traditional' and  local-name($node) = 'section' ) or starts-with($style , 'archaic')">
						<xsl:text>T1-K</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="//legis-body[@style='OLC']//header = 'Archaic'">
				<xsl:choose>
					<xsl:when test="local-name($node) = 'header' and not(local-name($node/..) = 'subsection')">
						<xsl:text>K-T5</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="local-name($node) = 'subsection'">
				<xsl:variable name="style" as="xs:string?" select="gpo:GetNearestAncestorStyleValue($node, $billstage, $resstage)" />
				<xsl:if test="not(contains($style,'archaic'))">
					<xsl:text>K-T5</xsl:text>
				</xsl:if>
			</xsl:when>
			<xsl:when test="local-name($node) = 'paragraph'          or local-name($node) = 'subparagraph'          or local-name($node) = 'clause'          or local-name($node) = 'subclause'          or local-name($node) = 'item'          or local-name($node) = 'subitem'">
				<xsl:text>K-T4</xsl:text>
			</xsl:when>
			<xsl:when test="local-name($node) = 'quoted-block'          or local-name($node) = 'division'          or local-name($node) = 'subdivision'          or local-name($node) = 'chapter'          or local-name($node) = 'subchapter'          or local-name($node) = 'subpart'          or local-name($node) = 'title'          or local-name($node) = 'subtitle'">
				<xsl:text />
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="$node/..">
						<xsl:call-template name="getEnumInHeaderEscape">
							<xsl:with-param name="node" select="$node/.." />
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="getFontPrecedingInlineComment" as="node()">
		<xsl:param name="node" as="element()" />
		<xsl:choose>
			<xsl:when test="local-name($node)='subitem'">
				<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="local-name($node)='item'">
				<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="local-name($node)='subclause'">
				<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="local-name($node)='clause'">
				<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="local-name($node)='subparagraph'">
				<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="local-name($node)='paragraph'">
				<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="local-name($node)='subsection'">
				<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="count($node | /) = 1">
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>
			<xsl:otherwise>
					<xsl:call-template name="getFontPrecedingInlineComment">
						<xsl:with-param name="node" select="$node/parent::node()" as="element()" />
					</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc />
		<param>node: The reference node</param>
		<return>yes or no depending on which conditions are met</return>
		<gpo:srcXSL>Named Template:  isEmptyOmittedStructure</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:isEmptyOmittedStructure" as="xs:string">
		<xsl:param name="node" as="element()" />
		<xsl:choose>
			<xsl:when test="count($node/child::*) &gt; 2">
				<xsl:text>no</xsl:text>
			</xsl:when>
			<xsl:when test="count($node/child::*)  = 1       and ($node/ancestor::ramseyer or $node/ancestor::cordon)        and $node/text/omitted-text/@type='vertical'">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:when test="count($node/child::*)  = 1       and ($node/ancestor::ramseyer or $node/ancestor::cordon)        and $node/section/text/omitted-text/@type='vertical'">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:when test="count($node/child::*) = 2       and $node/enum=''       and ($node/ancestor::ramseyer or $node/ancestor::cordon)       and $node/text/omitted-text/@type='vertical' ">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:when test="count($node/child::*) = 2       and $node/enum=''       and ($node/ancestor::ramseyer or $node/ancestor::cordon)       and $node/section/text/omitted-text/@type='vertical' ">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>no</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="isEmptyOmittedStructure">
		<xsl:choose>
			<xsl:when test="count(child::*) &gt; 2">
				<xsl:text>no</xsl:text>
			</xsl:when>
			<xsl:when test="(ancestor::ramseyer or ancestor::cordon) and text/omitted-text/@type='vertical' and (count(child::*)  = 1)">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:when test="(ancestor::ramseyer or ancestor::cordon) and section/text/omitted-text/@type='vertical' and (count(child::*)  = 1)">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:when test="count(child::*) = 2 and enum='' and (ancestor::ramseyer or ancestor::cordon) and text/omitted-text/@type='vertical' ">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:when test="count(child::*) = 2 and enum='' and (ancestor::ramseyer or ancestor::cordon) and section/text/omitted-text/@type='vertical' ">
				<xsl:text>yes</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>no</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="locatorFromAttributes" as="item()*">
		<xsl:param name="node" as="element()" select="." />
		
		<xsl:variable name="isOmittedStructure" as="xs:string" select="gpo:isEmptyOmittedStructure($node)" />
			
		<xsl:choose>
			<xsl:when test="$isOmittedStructure='yes'">
				<!-- nothing -->
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="string-length($node/@vbattLocator) &gt; 0">
					<xsl:sequence select="gpo:bell2Xml(normalize-space($node/@vbattLocator))" />
				</xsl:if>
				<xsl:if test="string-length($node/@vbattFormat) &gt; 0">
					<xsl:sequence select="gpo:bell2Xml(normalize-space($node/@vbattFormat))" />
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>

	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="locatorForSection" as="item()*">
		<xsl:param name="node" as="element()" select="." />
		<xsl:param name="style" as="xs:string" select="'OLC'" />
		<xsl:param name="section-type" as="xs:string" />
		
		<xsl:if test="$node/@display-inline = 'yes-display-inline' ">
			<xsl:text />
		</xsl:if>

		<xsl:variable name="ramseyerOmittedText" as="xs:string" select="gpo:isEmptyOmittedStructure($node)" />
			
		<xsl:variable name="output" as="xs:string" select="     if (starts-with($style , 'traditional') or starts-with($style , 'archaic') or $style='nuclear') then 'false'     else 'true'" />
			
		<xsl:variable name="firstUndesignatedInBlock" as="xs:string">
			<xsl:call-template name="IsSectionFirstInBlockUndesignated" />
		</xsl:variable>

		<xsl:if test="not($node/@display-inline = 'yes-display-inline') and $ramseyerOmittedText = 'no'">
			<xsl:choose>
				<xsl:when test="$section-type='resolved' or $section-type='ordered' ">20</xsl:when>
				<xsl:when test="/bill/@bill-stage='Enrolled-Bill' and $node/@section-type='section-one' and $style='OLC' ">46</xsl:when>
				<xsl:when test="/bill/@bill-stage='Enrolled-Bill' and $node/@section-type='section-one' and $style='USC' ">66</xsl:when>
				<xsl:when test="/bill/@bill-stage='Enrolled-Bill'  and $node/@section-type='section-one' ">20</xsl:when>
				<xsl:when test="/bill/@bill-stage='Enrolled-Bill' and string-length($node/enum) &gt; 1 and $output='true' ">
					<xsl:variable name="enumLength" as="xs:integer" select="gpo:calcEnumLength(normalize-space($node/enum))" />
					<xsl:choose>
						<xsl:when test="$style='OLC' or $style='tax' or $style='energy' ">
							<xsl:variable name="locator" as="xs:string" select="concat('4', $enumLength)" />
							<xsl:value-of select="$locator" />
							<!--<para loc="{$locator}"/>-->
						</xsl:when>
						<xsl:when test="$style='USC'">
							<xsl:variable name="locator" as="xs:string" select="concat('6', $enumLength)" />
							<!--Issue #91:  The code was sending a paragraph instead of the number of the locator.-->
							<xsl:value-of select="$locator" />
							<!--<para loc="{$locator}"/>-->
						</xsl:when>
					</xsl:choose>
				</xsl:when>
				<xsl:when test="/bill/@bill-stage='Enrolled-Bill' and $node/ancestor::quoted-block  and $output='true' ">
					<!--<xsl:value-of select="$locator"/>-->
					<para loc="43" />
				</xsl:when>
				<xsl:when test=" $node/@section-type='undesignated-section'  and local-name($node/child::*[1])='continuation-text' " />

				<xsl:when test="$style='OLC'  and not($node/text[@display-inline='no-display-inline'])">

					<xsl:choose>
						<xsl:when test="($node/@section-type='undesignated-section'  and not($node/child::enum) and not($node/child::header)) ">20</xsl:when>
						<xsl:when test="$node/descendant::header/enum-in-header and $node/@vbattChangedForReported='strikethrough'  ">72</xsl:when>
						<xsl:otherwise>72</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:when test="$style='USC'">75</xsl:when>
				<xsl:when test="starts-with($style , 'traditional') or starts-with($style , 'archaic') or $style='nuclear'">20</xsl:when>
				<xsl:when test="$style='constitutional-amendment' or /resolution[@resolution-type]='constitutional-amendment'">20</xsl:when>
				<xsl:otherwise>72</xsl:otherwise>
			</xsl:choose>
		</xsl:if>

		<xsl:choose>
			<xsl:when test="(not(($node/header and  $node/header/text)) and not($node/enum and  enum/text) and $node/parent::resolution-body/@display-resolving-clause='no-display-resolving-clause'        and (position()=1 or not($node/preceding-sibling::*)) and $node/@display-inline='yes-display-inline' ) or (      $firstUndesignatedInBlock='yes' and lower-case($resstage) = 'reported-in-senate')">

				<xsl:choose>
					<xsl:when test="$firstUndesignatedInBlock='yes'  and ($node/@display-inline='yes-display-inline')">20</xsl:when>
					<xsl:when test="$style !='OLC' ">20</xsl:when>
					<xsl:when test="not($node/@display-inline = 'no-display-inline')">20</xsl:when>
					<xsl:when test=" ($node/text[@display-inline='no-display-inline']) ">20</xsl:when>
					<xsl:when test="$node/@section-type !='undesignated-section' ">20</xsl:when>
				</xsl:choose>

			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="$node/@display-inline='yes-display-inline'         and $firstUndesignatedInBlock='yes'         and not(lower-case($resstage) = 'reported-in-senate')">20</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:calcEnumLengthXX">
		<xsl:param name="aEnumSourceString" />
		<xsl:variable name="enumSourceStringForCalc">
			<xsl:value-of select="normalize-space($aEnumSourceString) " />
		</xsl:variable>
		
		<xsl:variable name="enumLengthStep1">
			<xsl:choose>
				<xsl:when test="contains($enumSourceStringForCalc, '[[[')">
					<xsl:value-of select="string-length(substring-before($enumSourceStringForCalc, '[[[')) + 1 + string-length(substring-after($enumSourceStringForCalc, ']]]'))" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="string-length($enumSourceStringForCalc)" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="enumLengthStep2">
			<xsl:choose>
				<xsl:when test="substring($enumSourceStringForCalc, string-length($enumSourceStringForCalc)) = '.'">
					<xsl:value-of select="number($enumLengthStep1) - 1" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$enumLengthStep1" />
				</xsl:otherwise>
			</xsl:choose>			
		</xsl:variable>
		
		<xsl:variable name="enumLengthStep3">
			<xsl:choose>
				<xsl:when test="number ($enumLengthStep2) &gt; 6">
					<xsl:text>6</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$enumLengthStep2" />
				</xsl:otherwise>
			</xsl:choose>				
		</xsl:variable>
		
		<xsl:value-of select="$enumLengthStep3" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:calcEnumLengthX" as="xs:integer">
		<xsl:param name="aEnumSourceString" as="xs:string" />
		
		<xsl:variable name="noTrailingDot" as="xs:string" select="replace(normalize-space($aEnumSourceString), '\.$', '')" />

		<xsl:variable name="actualLen" as="xs:integer" select="string-length(replace($noTrailingDot, '(\[\[\[(.*)\]\]\])', 'x'))" />
		
		<xsl:sequence select="if ($actualLen &gt; 6) then 6       else $actualLen" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:calcEnumLength" as="xs:integer">
		<xsl:param name="aEnumSourceString" as="xs:string" />
		
		<xsl:variable name="enumSourceStringForCalc" as="xs:string" select="normalize-space($aEnumSourceString)" />
	
		<xsl:variable name="enumLengthStep1" as="xs:integer" select="      if (contains($enumSourceStringForCalc, '[[[')) then            string-length(substring-before($enumSourceStringForCalc, '[[['))            + 1            + string-length(substring-after($enumSourceStringForCalc, ']]]'))      else        string-length($enumSourceStringForCalc)      " />
		
		<xsl:variable name="enumLengthStep2" as="xs:integer" select="      if (substring($enumSourceStringForCalc, string-length($enumSourceStringForCalc)) = '.') then xs:integer($enumLengthStep1) - 1      else $enumLengthStep1" />
			
		<xsl:sequence select="    if (xs:integer($enumLengthStep2) &gt; 6) then 6    else $enumLengthStep2" />
		
	</xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="locatorForQBContText" as="xs:string">
		<!--<xsl:param name="node" as="xs:string" select="@quoted-block-continuation-text-level"/>-->
		<xsl:param name="style" as="xs:string?" select="'OLC'" />
		<xsl:choose>
		<xsl:when test="@display-inline = 'yes-display-inline'">
			<xsl:text />
		</xsl:when>
		<xsl:otherwise>
			<xsl:choose>
				<xsl:when test="@indent = 'left-margin'">20</xsl:when>
				<xsl:when test="@indent = 'flush-left'">20</xsl:when>
				<xsl:otherwise>
					<xsl:call-template name="calculateLocator">
						<xsl:with-param name="level" select="@quoted-block-continuation-text-level" />
						<xsl:with-param name="addASC24s" select="'no'" />
					</xsl:call-template>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="locatorForListItem" as="node()">
		<xsl:param name="node" as="element()" select="." />
		<xsl:param name="listType" as="xs:string" select="'none'" />
		
		<xsl:variable name="theLevel" as="xs:string">
			<xsl:choose>
				<xsl:when test="$node/@level">
					<xsl:value-of select="$node/@level" />
				</xsl:when>
				<xsl:when test="local-name($node) = 'amendment-list'">
					<xsl:text />
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>section</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:choose>
			<xsl:when test="($theLevel='section'         or $theLevel='subsection'         or $theLevel='paragraph'         or $theLevel='subparagraph'         or $theLevel='clause'         or $theLevel='subclause'         or $theLevel='item'         or $theLevel='subitem')        or $node/parent::amendment-list">
				<xsl:call-template name="calculateLocator">
					<xsl:with-param name="level" select="$theLevel" />
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="not(//committee-report)">
					<para loc="22">
						<xsl:text>  </xsl:text>
					</para>
				</xsl:if>
				<xsl:if test="//committee-report and not($node/ancestor-or-self::amendment-list)">
					<para loc="22">
						<xsl:text> </xsl:text>
						<xsl:call-template name="addListTypebyParam">
							<xsl:with-param name="theListType" select="$node/@list-type" />
						</xsl:call-template>
						<xsl:text> </xsl:text>
					</para>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="addListTypebyParam" as="xs:string">
		<xsl:param name="node" as="element()" />
		<xsl:param name="theListType" as="xs:string?" select="$node/@list-type" />
		
		<xsl:choose>
			<xsl:when test="$node/parent::amendment-list">
				<xsl:text />
			</xsl:when>
			<xsl:when test="$theListType='bulleted'">
				<xsl:text>•</xsl:text>
			</xsl:when>
			<xsl:when test="$theListType='numbered'">
				<xsl:text>[listNumberedX]</xsl:text>
			</xsl:when>
			<xsl:when test="$theListType='lettered'">
				<xsl:text>[listLetteredX]</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc>adjustLevel</desc>
		<param>direction: Either up or down</param>
		<param>position: A number</param>
		<param>count: The number of iterations</param>
		<return />
		<gpo:srcXSL>Named Template:  adjustLevel</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:adjustLevel" as="xs:string">
		<xsl:param name="direction" as="xs:string" />
		<xsl:param name="position" as="xs:string" />
		<xsl:param name="count" as="xs:string" />
		<xsl:variable name="newPosition" as="xs:string" select="    if ($direction = 'up') then    (     if ($position = '20' or $position='22') then '20'      else if ($position = '24') then '22'      else if ($position = '26') then '24'      else if ($position = '28') then '26'      else if ($position = '30') then '28'      else if ($position = '31') then '30'      else $position    ) else (     if ($position = '20') then '22'      else if ($position = '22') then '24'      else if ($position = '24') then '26'      else if ($position = '26') then '28'      else if ($position = '28') then '30'      else if ($position = '30') then '31'      else if ($position = '31') then '31'      else $position    )        " />
		
		<xsl:sequence select="if ($count = '1') then $newPosition    else gpo:adjustLevel($direction, $newPosition, xs:string(xs:integer($count) - 1))    " />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:printOpeningAppropElementSymbol" as="xs:string">
		<xsl:param name="node" as="element()" />
		<xsl:param name="aIsCommented" as="xs:string" />
		<xsl:param name="aInQuotedBlock" as="xs:string" />
		<xsl:param name="vbattChangedForReported" as="xs:string" />
		
		<xsl:variable name="result" as="item()*">
			<xsl:if test="$aIsCommented='yes' ">
				<xsl:text></xsl:text>
			</xsl:if>
			<xsl:if test="starts-with($vbattChangedForReported,'brackets')">
				<xsl:text></xsl:text>
			</xsl:if>
			<xsl:if test="starts-with($vbattChangedForReported,'bold-brackets')">
				<xsl:text></xsl:text>
			</xsl:if>
			<xsl:if test="contains($vbattChangedForReported,'parentheses')">
				<xsl:text></xsl:text>
			</xsl:if>
			<xsl:if test="$aInQuotedBlock='yes'">
				<xsl:sequence select="gpo:QuotedBlockNestingStart($node)" />
			</xsl:if>
		</xsl:variable>
		
		<xsl:sequence select="string-join($result, '')" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:getStarString1" as="xs:string">
		<xsl:param name="count" as="xs:integer" />
		<xsl:param name="previousValue" as="xs:string" />
		
		<xsl:variable name="iValue" as="xs:string*">
			<xsl:for-each select="for $x in 1 to $count return $x">
				<xsl:value-of select="concat('[1/4]', '')" />
			</xsl:for-each>
		</xsl:variable>
		
		<xsl:value-of select="concat($previousValue, $iValue)" />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
		<desc />
		<param>The number of stars.</param>
		<return>A string with the specified number of stars.</return>
		<gpo:srcXSL>Named Template:  getStarString</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:getStarString" as="xs:string">
		<xsl:param name="count" as="xs:integer" />
		<xsl:choose>
			<xsl:when test="$count &lt; 1">
				<xsl:sequence select="''" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="concat('[1/4]', gpo:getStarString($count - 1))" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:bell2Xml" as="node()">
		<xsl:param name="bellcode" as="xs:string" />
		
		<xsl:choose>
			<xsl:when test="starts-with($bellcode, 'S')">
				<xsl:element name="para">
					<xsl:attribute name="format">
						<xsl:value-of select="normalize-space(substring-after($bellcode, 'S'))" />
					</xsl:attribute>
				</xsl:element>
			</xsl:when>
			<xsl:when test="starts-with($bellcode, 'F')">
				<xsl:element name="para">
					<xsl:attribute name="format">
						<xsl:value-of select="normalize-space(substring-after($bellcode, 'F'))" />
					</xsl:attribute>
				</xsl:element>
			</xsl:when>
			<xsl:when test="starts-with($bellcode, 'I')">
				<xsl:element name="para">
					<xsl:attribute name="loc">
						<xsl:value-of select="normalize-space(substring-after($bellcode, 'I'))" />
					</xsl:attribute>
				</xsl:element>
			</xsl:when>
			<xsl:when test="starts-with($bellcode, 'Q')">
				<xsl:element name="para">
					<xsl:attribute name="qcode">
						<xsl:value-of select="normalize-space(substring-after($bellcode, 'Q'))" />
					</xsl:attribute>
				</xsl:element>
			</xsl:when>
			<xsl:when test="starts-with($bellcode, 'G')">
				<xsl:processing-instruction name="xpp">
					<xsl:text>ff;</xsl:text>
					<xsl:value-of select="normalize-space(substring-after($bellcode, 'G'))" />
				</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="starts-with($bellcode, 'T')">
				<xsl:processing-instruction name="xpp">
					<xsl:text>fv;</xsl:text>
					<xsl:value-of select="normalize-space(substring-after($bellcode, 'T'))" />
				</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="starts-with($bellcode, 'K')">
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>calculateLocator</desc>
        <return />
        <gpo:srcXSL>Named Template:  calculateLocator</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="calculateLocator">
        <xsl:param name="level" />
        <!-- NB 8/14/2006 - Added iteration parameter to prevent infinite looping -->
        <xsl:param name="iteration">1</xsl:param>
        <!-- NB 8/14/2006 - Added justGetNumberFlag parameter so that a loop would no result in a doulbe Bel-I -->
        <xsl:param name="justGetNumberFlag">no</xsl:param>      
        <xsl:param name="addASC24s">yes</xsl:param>
        <xsl:param name="isOmittedStructure" />
        <xsl:param name="directory" />
        <xsl:param name="position" />
        <xsl:variable name="isOmittedStructure" as="xs:string?">
            <xsl:call-template name="isEmptyOmittedStructure" />
            <xsl:choose>
                <xsl:when test="@display-inline = 'yes-display-inline'">yes</xsl:when>	
                <xsl:when test="$isOmittedStructure='yes'">yes</xsl:when>
                <xsl:otherwise />
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="val1" as="xs:string?">
            <xsl:choose>
                <xsl:when test="$level='paragraph' and local-name(parent::*)='whereas'">29</xsl:when>
                <!-- commented by TB Nov2010 I21 is the same like I20 with generated em-space, and we are generating it - to make it consistently-->
                <!--xsl:when test="$level='section' and //committee-report">21</xsl:when-->
                <xsl:when test="$level='section'">20</xsl:when>
                <xsl:when test="$level='subsection' or  $level='rules-clause'">20</xsl:when>
                <xsl:when test="$level='paragraph' or $level='rules-paragraph'">22</xsl:when>
                <xsl:when test="$level='subparagraph' or $level='rules-subparagraph' ">24</xsl:when>
                <xsl:when test="$level='clause'  or  $level='rules-subdivision'">26</xsl:when>
            	<!--Issue #347 modified 'or' to 'and'-->
            	<xsl:when test="$level='subclause' and @style='traditional' ">26</xsl:when>
            	<xsl:when test="$level='subclause' or $level='rules-item' ">28</xsl:when>
                <xsl:when test="$level='subclause' or $level='rules-item' ">28</xsl:when>
                <xsl:when test="$level='item' or $level='rules-subitem'">30</xsl:when>
                <xsl:when test="$level='subitem'">31</xsl:when>
                <!-- NB 11/30/2006 - added an otherwise clause so that there will be a default value for this to be -->						
                <xsl:otherwise>20</xsl:otherwise>						
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="val2" as="xs:string?">
            <xsl:choose>
                <xsl:when test="starts-with(@indent, 'up')">
                    <xsl:variable name="direction" as="xs:string">up</xsl:variable>
                    <xsl:variable name="position" as="xs:string?"><xsl:value-of select="$val1" /></xsl:variable>
                    <xsl:variable name="count" as="xs:string?"><xsl:value-of select="substring-after(./@indent, 'up')" /></xsl:variable>
                	<xsl:call-template name="findActualLocator">
                		<xsl:with-param name="levelLocator" select="xs:double($val1)" />
                	</xsl:call-template>
                	<!--<xsl:call-template name="adjustLevel">
                		<xsl:with-param name="direction">up</xsl:with-param>
                		<xsl:with-param name="position"><xsl:value-of select="$val1"/></xsl:with-param>
                		<xsl:with-param name="count"><xsl:value-of select="$count"/></xsl:with-param>
                	</xsl:call-template>-->
                </xsl:when>
                <xsl:when test="starts-with(./@indent, 'down')">
                    <xsl:variable name="direction" as="xs:string">up</xsl:variable>
                    <xsl:variable name="count" as="xs:string"><xsl:value-of select="substring-after(./@indent, 'down')" /></xsl:variable>
                	<xsl:call-template name="adjustLevel">
                		<xsl:with-param name="direction">down</xsl:with-param>
                		<xsl:with-param name="position"><xsl:value-of select="$val1" /></xsl:with-param>
                		<xsl:with-param name="count"><xsl:value-of select="substring-after(./@indent, 'down')" /></xsl:with-param>
                	</xsl:call-template>   
                </xsl:when>
                <!-- NB 8/14/2006 - Added iteration parameter to test to prevent infinite looping  -->	
                
                <xsl:when test="$iteration='1' and not(string-length(./@indent)=0)">
                    <!--xsl:when test="$iteration='1' and ancestor-or-self::*[@indent !='']"-->
                    <!--xsl:variable name="junker">x<xsl:value-of select="string-length(./@indent)"/>x</xsl:variable-->
                    <xsl:variable name="lastIndex" select="count (ancestor-or-self::*[@indent !='']) - 1" as="xs:integer" />
                    <xsl:variable name="theIndent" select="ancestor-or-self::*[$lastIndex][@indent != '']/@indent" as="xs:string" />
                    <xsl:variable name="theLocalName" select="local-name(ancestor-or-self::*[$lastIndex])" as="xs:string" />
                    
                    <!--xsl:if test="$theIndent != $theLocalName"-->
                    <xsl:call-template name="calculateLocator">
                        <xsl:with-param name="level"><xsl:value-of select="./@indent" /></xsl:with-param>
                        <!--xsl:with-param name="level" select="$theIndent"/-->
                        <!-- NB 8/14/2006 - Added parameter to call, so that second loop will work and not be infinite -->
                        <xsl:with-param name="iteration">2</xsl:with-param>
                        <xsl:with-param name="justGetNumberFlag">yes</xsl:with-param>
                    </xsl:call-template>
                    <!--/xsl:if-->
                </xsl:when>												
                <xsl:otherwise>
                    <xsl:value-of select="$val1" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <!-- 	This section is designed to handle any specific overrides that are necessary 
					This could be done as further when clauses in the calculation of val2,
					but as an explicit choose, it is easier to understand when/where coding should take place
				-->
        <xsl:variable name="val3" as="item()*">
            <xsl:choose>
                <xsl:when test="local-name(.)='subparagraph' and ancestor::preamble">
                    29  
                    <xsl:text>Ì</xsl:text>						
                </xsl:when>
                <xsl:when test="local-name(.)='clause' and ancestor::preamble">
                    29   
                    <xsl:text>Ì</xsl:text>						
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$val2" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:choose>
        <xsl:when test="$justGetNumberFlag='no'">
            <para>     
                <xsl:value-of select="$val3" />
                <xsl:choose>
                    <!-- TB Nov2010 Fixing #1178 -->
                    <xsl:when test="//committee-report">
                        <xsl:if test="ancestor-or-self::list ">
                            <xsl:text> </xsl:text>
                        </xsl:if>
                        <!--  <xsl:call-template name="addListTypebyParam"/>-->
                        <xsl:choose>
                            <xsl:when test="ancestor-or-self::list  and ((ancestor-or-self::list/@list-type != 'none'  or not(ancestor-or-self::list/@list-type)))"> </xsl:when>
                            <xsl:otherwise>	
                                <!-- TB Feb-19-2014 Added condition of iteration - if more then one iteration the extra ema space added -->
                                <!-- TB Apr-18-2014 added condition about ASC24 - extra em-space should not be in continuation textfixing #1345 -->
                                <xsl:if test="not(ancestor-or-self::list) and $iteration = '1' and not($addASC24s='no')"> </xsl:if>
                            </xsl:otherwise>
                        </xsl:choose>	
                    </xsl:when>					
                    <xsl:otherwise>
                        <!-- NB 8/14/2006 - added a check for the new flag so that it only goes out when it is requested -->
                        <xsl:if test="$justGetNumberFlag='no' and $addASC24s='yes'">  </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>				
            </para>
        </xsl:when>
            <xsl:otherwise><xsl:value-of select="$val1" /></xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="adjustLevel">
		<xsl:param name="direction" />
		<xsl:param name="position" />
		<xsl:param name="count" />
		<xsl:variable name="newPosition">
			<xsl:if test="$direction='up'">
				<xsl:choose>
					<xsl:when test="$position='20'">20</xsl:when>
					<xsl:when test="$position='22'">20</xsl:when>
					<xsl:when test="$position='24'">22</xsl:when>
					<xsl:when test="$position='26'">24</xsl:when>
					<xsl:when test="$position='28'">26</xsl:when>
					<xsl:when test="$position='30'">28</xsl:when>
					<xsl:when test="$position='31'">30</xsl:when>
					<xsl:otherwise><xsl:value-of select="$position" /></xsl:otherwise>
				</xsl:choose>
			</xsl:if>
			<xsl:if test="$direction='down'">
				<xsl:choose>
					<xsl:when test="$position='20'">22</xsl:when>
					<xsl:when test="$position='22'">24</xsl:when>
					<xsl:when test="$position='24'">26</xsl:when>
					<xsl:when test="$position='26'">28</xsl:when>
					<xsl:when test="$position='28'">30</xsl:when>
					<xsl:when test="$position='30'">31</xsl:when>
					<xsl:when test="$position='31'">31</xsl:when>
					<xsl:otherwise><xsl:value-of select="$position" /></xsl:otherwise>
				</xsl:choose>
			</xsl:if>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$count='1'"><xsl:value-of select="$newPosition" /></xsl:when>
			<xsl:otherwise>
				<xsl:variable name="newCount">
					<xsl:choose>
						<xsl:when test="$count='2'">1</xsl:when>
						<xsl:when test="$count='3'">2</xsl:when>
						<xsl:when test="$count='4'">3</xsl:when>
						<xsl:when test="$count='5'">4</xsl:when>
						<xsl:when test="$count='6'">5</xsl:when>
					</xsl:choose>
				</xsl:variable>
				<xsl:call-template name="adjustLevel">
					<xsl:with-param name="count"><xsl:value-of select="$newCount" /></xsl:with-param>
					<xsl:with-param name="direction"><xsl:value-of select="$direction" /></xsl:with-param>
					<xsl:with-param name="position"><xsl:value-of select="$newPosition" /></xsl:with-param>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
		
	</xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>handleLowLevelStructure</desc>
        <return />
        <gpo:srcXSL>Named Template:  handleLowLevelStructure</gpo:srcXSL>
    </doc><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>applyTemplatesWithMode</desc>
        <return />
        <gpo:srcXSL>Named Template:  applyTemplatesWithMode</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="applyTemplatesWithMode">
        <xsl:param name="mode" />
        <xsl:choose>
            <xsl:when test="$mode='AllCaps'">
                <xsl:apply-templates select="." mode="AllCaps" />
            </xsl:when>
            <xsl:when test="$mode='AllLower'">
                <xsl:apply-templates select="." mode="AllLower" />
            </xsl:when>
            <xsl:when test="$mode='Amendment'">
                <xsl:apply-templates select="." mode="Amendment" />
            </xsl:when>
            <xsl:when test="$mode='AmendmentFinal'">
                <xsl:apply-templates select="." mode="AmendmentFinal" />
            </xsl:when>
            <xsl:when test="$mode='belK'">
                <xsl:apply-templates select="." mode="belK" />
            </xsl:when>
            <xsl:when test="$mode='conference-report'">
                <xsl:apply-templates select="." mode="conference-report" />
            </xsl:when>
            <xsl:when test="$mode='engrossed-amendment'">
                <xsl:apply-templates select="." mode="engrossed-amendment" />
            </xsl:when>
            <xsl:when test="$mode='FirstWord'">
                <xsl:choose>
                    <xsl:when test="starts-with(string(..), string(.))">
                        <xsl:apply-templates select="." mode="FirstWord" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="." mode="AllLower" />
                    </xsl:otherwise>
                </xsl:choose>            
            </xsl:when>
            <xsl:when test="$mode='go'">
                <xsl:apply-templates select="." mode="go" />
            </xsl:when>
            <xsl:when test="$mode='goTrad'">
                <xsl:apply-templates select="." mode="goTrad" />
            </xsl:when>
            <xsl:when test="$mode='InitialCaps'">
                <xsl:apply-templates select="." mode="InitialCaps" />
            </xsl:when>
            <xsl:when test="$mode='PreForm'">
                <xsl:apply-templates select="." mode="PreForm" />
            </xsl:when>
            <xsl:when test="$mode='Sentence'">
                <xsl:apply-templates select="." mode="Sentence" />
            </xsl:when>
            <xsl:when test="$mode='Special'">
                <xsl:apply-templates select="." mode="Special" />
            </xsl:when>
            <xsl:when test="$mode='subpart'">
                <xsl:apply-templates select="." mode="subpart" />
            </xsl:when>
            <xsl:when test="$mode='table'">
                <xsl:apply-templates select="." mode="table" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="." mode="process" />
            </xsl:otherwise>
        </xsl:choose>       
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Hide part</desc>
        <return>Returns value of running-head element if @display is set to 'yes' or is blank. 
        The default value in the DTD is 'yes'.</return>
        <gpo:srcXSL>Named Template:  HidePart</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="HidePart">      
        <xsl:if test="descendant::pre-form/running-header[@display='yes' or not(@display)]">
            <para loc="81">
            <xsl:value-of select="//pre-form/running-header" />   
            </para>
        </xsl:if>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Hide part 2 - confirmed that there can be more than 1 action-desc.</desc>
        <return>Returns value of running-head element if @display is set to 'yes' or is blank. 
            The default value in the DTD is 'yes'.</return>
        <gpo:srcXSL>Named Template:  HidePart</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="HidePart2">
        <para loc="53">
        <xsl:if test="//pre-form and //official-title/text()">
            <command>TITLE</command>
        </xsl:if>
        </para>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Turn text of the starPrint attribute to numerical value</desc>
        <param>star-print-value</param>
        <gpo:srcXSL>Named Template:  starPrint</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:starPrintBetty" as="xs:integer">
        <xsl:param name="star-print-value" as="xs:string" />
    
            <xsl:if test="$star-print-value='first-star-print'">1</xsl:if>
            <xsl:if test="$star-print-value='second-star-print'">2</xsl:if>
            <xsl:if test="$star-print-value='third-star-print'">3</xsl:if>
            <xsl:if test="$star-print-value='fourth-star-print'">4</xsl:if>
            <xsl:if test="$star-print-value='fifth-star-print'">5</xsl:if>
            <xsl:if test="$star-print-value='sixth-star-print'">6</xsl:if>
            <xsl:if test="$star-print-value='seventh-star-print'">7</xsl:if>
            <xsl:if test="$star-print-value='eigthth-star-print'">8</xsl:if>
            <xsl:if test="$star-print-value='ninth-star-print'">9</xsl:if>
            <xsl:if test="$star-print-value='tenth-star-print'"><xsl:text>10</xsl:text>
            </xsl:if>       
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Constrains the indent value</desc>
        <param>Indent Value</param>
        <gpo:srcXSL>Named Template:  hasPreviousAmendmentBlock</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="hasPreviousAmendmentBlock">
        <xsl:param name="currentNode" as="element()" />
        <xsl:param name="distance" />
        <xsl:choose>
            <xsl:when test="$currentNode/preceding-sibling::amendment-block">
                <xsl:value-of select="number($distance) + 1" />
            </xsl:when>
            <xsl:when test="$currentNode/preceding-sibling::amendment-instruction">
                <xsl:variable name="distance" select="number($distance) + 1" as="xs:double" />               
                <xsl:call-template name="hasPreviousAmendmentBlock">
                    <xsl:with-param name="currentNode" select="$currentNode/preceding-sibling::amendment-instruction" />
                    <xsl:with-param name="distance" select="number($distance) + 1" />
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="number(0)" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Get the S6201 Bell code</desc>
        <gpo:srcXSL>Named Template:  OutputForTOC</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:OutputForTOC">
        <para format="6201" />
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Copies all child nodes.</desc>
        <gpo:srcXSL>Named Template:  copy-node-deep</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="copy-node-deep">
        <xsl:element name="{local-name()}">
        <xsl:copy-of select="@*" />
            <xsl:copy><xsl:apply-templates select="node() | @*" mode="process" /></xsl:copy>
        </xsl:element>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Constrains the indent value</desc>
        <param>Indent Value</param>
        <gpo:srcXSL>Named Template:  ConstrainIndentValue</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:ConstrainIndentValue" as="xs:integer">
        <xsl:param name="indent-value" as="xs:integer" />
    	<xsl:choose>
    		<xsl:when test="$indent-value &gt; 31">
    			<xsl:text>31</xsl:text>
    		</xsl:when>
    		<xsl:when test="$indent-value &lt; 20">
    			<xsl:text>20</xsl:text>
    		</xsl:when>   
    		<xsl:otherwise>20</xsl:otherwise>
    	</xsl:choose>
           
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Gets Indent Level</desc>
        <param>default - ?</param>
        <param>down - go down indent level(s)</param>
        <param>up - go up indent level(s)</param>
        <param>indent-string - Assuming it would come as up3 or down3</param>
        <gpo:srcXSL>Named Template:  ConstrainIndentValue</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:GetIndentValue" as="xs:integer">
        <xsl:param name="default" as="xs:integer" />
        <xsl:param name="down" as="xs:integer" />
        <xsl:param name="up" as="xs:integer" />
        <xsl:param name="indent-string" as="xs:string" />
    	<xsl:variable name="val" as="xs:string" select="if (matches($indent-string, '(up|down)([0-9]+)')) then replace($indent-string, '[^0-9]+', '') else '1'" />
        <xsl:variable name="indent-value" select="$up - (number($val) - 1) * 2" as="xs:double" />
        <xsl:variable name="value" select="$indent-value" as="xs:double" />
        <xsl:choose>
            <xsl:when test="contains($indent-string, 'up') ">
                <xsl:variable name="indent-value" select="($up - (number($val) - 1) * 2)" as="xs:double" />
                <xsl:variable name="value" as="xs:double">
                	<xsl:value-of select="$indent-value" />
                </xsl:variable>
                <xsl:value-of select="gpo:ConstrainIndentValue(xs:integer($value))" />
            </xsl:when>
            <xsl:when test="contains($indent-string, 'down' )">
                <xsl:variable name="indent-value" select="($down + ((number($val) - 1) * 2))" />
               <!--
                   The following causes an error because indent-value is double and gpo:ConstrainIndentValue
                   needs integer-->
                   <xsl:variable name="value" select="xs:integer($indent-value)" as="xs:integer" />
                <xsl:value-of select="gpo:ConstrainIndentValue($value)" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$default" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Turns Numeric Congress Into Text</desc>
        <issue>This is identical to gpo:CongressText.</issue>
        <param>Ctext - the contents of the 'Congress' element.</param>
        <gpo:srcXSL>Named Template:  CongressValue</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:CongressValue" as="xs:string">
        <xsl:param name="CText" as="xs:string" />
        <xsl:choose> 
            <xsl:when test="contains($CText , '106')">
                <xsl:text>one hundred sixth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText, '107')">
                <xsl:text>one hundred seventh congress</xsl:text>
            </xsl:when>      
            <xsl:when test="contains($CText , '108')">
                <xsl:text>one hundred eighth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '109')">
                <xsl:text>one hundred ninth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '110')">
                <xsl:text>one hundred tenth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '111')">
                <xsl:text>one hundred eleventh congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '112')">
                <xsl:text>one hundred twelfth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '113') or contains($CText , 'thirteen')">
                <xsl:text>one hundred thirteenth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '114') or contains($CText , 'fourteen')">
                <xsl:text>one hundred fourteenth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '115') or contains($CText , 'fifteen')">
                <xsl:text>one hundred fifteenth congress</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Turns Numeric Congress Into Text</desc>
        <issue>This is identical to gpo:CongressValue.</issue>
        <param>Ctext - the contents of the 'Congress' element.</param>
        <gpo:srcXSL>Named Template:  CongressText</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:CongressText" as="xs:string">
        <xsl:param name="CText" as="xs:string" />
        <xsl:choose>
            <xsl:when test="contains($CText , '106')">
                <xsl:text>one hundred sixth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText, '107')">
                <xsl:text>one hundred seventh congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '108')">
                <xsl:text>one hundred eighth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '109')">
                <xsl:text>one hundred ninth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '110')">
                <xsl:text>one hundred tenth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '111')">
                <xsl:text>one hundred eleventh congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '112')">
                <xsl:text>one hundred twelfth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '113') or contains($CText , 'thirteen')">
                <xsl:text>one hundred thirteenth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '114') or contains($CText , 'fourteen')">
                <xsl:text>one hundred fourteenth congress</xsl:text>
            </xsl:when>
            <xsl:when test="contains($CText , '115') or contains($CText , 'fifteen')">
                <xsl:text>one hundred fifteenth congress</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Returns a string and turns dash (-) into [[ndash]]</desc>
        <issue>This calls a template in the common-structural.xslt file.  It cannot be tested until this
               template is completed.</issue>
        <issue>Need to know what the 'style' and 'noDot' paramaters are?</issue>
        <issue>Need to know the rules when 'noDot' is set to true.</issue>
        <param>style - The 'style' attribute of the node being sent, i.e., OLC.</param>
        <param>noDot - A true or false values.</param>
        <return />
        <gpo:srcXSL>Named Template:  getmdash</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:getmdash">
        <xsl:param name="style" />
        <xsl:param name="noDot" />
         <xsl:variable name="toGenerateEmDash">
          <!--  <xsl:call-template name="GenerateEmDash">
                <xsl:with-param name="IsForFollowingSibling">
                    <xsl:text>false</xsl:text>
                </xsl:with-param>
                <xsl:with-param name="currentStyle" select="$style"/>
            </xsl:call-template>-->
        </xsl:variable>
        <xsl:if test="$toGenerateEmDash='true'">
            <xsl:choose>
                <xsl:when test="$noDot='true'">—</xsl:when>
                <xsl:otherwise>.—</xsl:otherwise>
            </xsl:choose>           
        </xsl:if>      
    </xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="getmdash">
		<xsl:param name="node" as="node()?" />
		<xsl:param name="style" as="xs:string" />
		<xsl:param name="noDot" as="xs:string?" />
		<xsl:variable name="toGenerateEmDash">
			<xsl:call-template name="GenerateEmDash">
				<xsl:with-param name="IsForFollowingSibling" select="'false'" />
				<xsl:with-param name="currentStyle" select="$style" />
			</xsl:call-template>
		</xsl:variable>
		<xsl:if test="$toGenerateEmDash='true'">
			<xsl:choose>
				<xsl:when test="$noDot='true'">—</xsl:when>
				<xsl:otherwise>.—</xsl:otherwise>
			</xsl:choose>           
		</xsl:if>      
	</xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Returns a string and turns dash (-) into [[ndash]]</desc>
        <issue>This template uses the attribute 'dms-version'.  None of the sample has this attribute.</issue>
        <issue>The template has both 'stage' and 'docStage' paramaters but it looks like only 'stage' is used.
            I am deleting docStage.</issue>
        <issue>Do not know what is supposed to be sent for 'OrigValForI90'.  </issue>
        <param>originalData</param>
        <return>113th  - CONGRESS = 1. 13th [[[ndash]]] congress</return>
        <gpo:srcXSL>Named Template:  GenerateI90ForApprop</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="actualDisplayI90">
        <xsl:param name="OrigValForI90" />
        <xsl:param name="stage" />	
        <xsl:param name="dms-version" />
        <xsl:param name="ordered-section-type" />
        <xsl:choose>
        	<xsl:when test="$bill-star-print='first-star-print' or $bill-star-print='second-star-print'">
        		<xsl:variable name="starCount" as="xs:string" select="gpo:starPrint($bill-star-print)" />
        		<xsl:value-of select="$starCount" />
        		<xsl:variable name="starString" as="xs:string" select="gpo:getStarString(xs:integer($starCount))" />
        		<para loc="90">
        			<xsl:call-template name="displayI90Line">
        			<xsl:with-param name="aLegisNumInit" select="substring(legis-num, 1, 1)" />	
        		</xsl:call-template></para>
        		<para loc="91">
        			<xsl:processing-instruction name="xpp">ff;6</xsl:processing-instruction>
        			<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
        			<xsl:value-of select="$starString" />
        			<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
        			
        			<!-- <xsl:text> </xsl:text>
        			<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
        			<xsl:text>(Star Print)</xsl:text>  -->
        			<!-- fixes issue #542 -->
        			<xsl:choose>
        				<xsl:when test="contains($billstage, 'Senate')">
        					<xsl:text>(Star Print) </xsl:text>
        				</xsl:when>
        				<xsl:otherwise>
        					<xsl:text> </xsl:text>
        				</xsl:otherwise>
        			</xsl:choose>
        		</para>
        	</xsl:when>
            <xsl:when test="$billtype='appropriations' and //pre-form and //bill/@key='G' and //bill/@dms-version !=''">
                <para loc="90">
                    <xsl:variable name="ApprpI90Generated">
                        <xsl:value-of select="gpo:GenerateI90ForApprop($dms-version)" />         
                    </xsl:variable>
                    <xsl:value-of select="$ApprpI90Generated" />
                    <xsl:text> </xsl:text>
                </para>
            </xsl:when>
            <xsl:when test="translate($OrigValForI90, ' ', '') = 'HRES'">
            	<para loc="90">
                <xsl:call-template name="displayI90Line">
                    <xsl:with-param name="aLegisNumInit">
                        <xsl:text>HRES</xsl:text>
                    </xsl:with-param>					
                </xsl:call-template>
            	</para>
            </xsl:when>
            <xsl:when test="translate($OrigValForI90, ' ', '') = 'HR'">
            	<para loc="90">
                <xsl:call-template name="displayI90Line">
                    <xsl:with-param name="aLegisNumInit">
                        <xsl:text>HR</xsl:text>
                    </xsl:with-param>					
                </xsl:call-template>
                <xsl:value-of select="gpo:getLegisNumber($OrigValForI90)" />
                <xsl:text> </xsl:text>
                <xsl:value-of select="$stage" />
            	</para>
            </xsl:when>			
            <xsl:when test="translate($OrigValForI90, ' ', '') = 'SCON'">
            	<para loc="90">
                <xsl:call-template name="displayI90Line">
                    <xsl:with-param name="aLegisNumInit">
                        <xsl:text>SCON</xsl:text>
                    </xsl:with-param>					
                </xsl:call-template>	
                <xsl:value-of select="gpo:getLegisNumber($OrigValForI90)" />
                <xsl:text> </xsl:text>
                <xsl:value-of select="$stage" />	
            	</para>
            </xsl:when>
            <xsl:when test="translate($OrigValForI90, ' ', '') = 'SJ'">
            	<para loc="90">
                <xsl:call-template name="displayI90Line">
                    <xsl:with-param name="aLegisNumInit">
                        <xsl:text>SJ</xsl:text>
                    </xsl:with-param>					
                </xsl:call-template>
                <xsl:value-of select="gpo:getLegisNumber($OrigValForI90)" />
                <xsl:text> </xsl:text>
                <xsl:value-of select="$stage" />	
            	</para>
            </xsl:when>	
            <xsl:when test="translate($OrigValForI90, ' ', '') = 'SRES'">
            	<para loc="90">
                <xsl:call-template name="displayI90Line">
                    <xsl:with-param name="aLegisNumInit">
                        <xsl:text>SRES</xsl:text>
                    </xsl:with-param>					
                </xsl:call-template>	
                <xsl:value-of select="gpo:getLegisNumber($OrigValForI90)" />
                <xsl:text> </xsl:text>
                <xsl:value-of select="$stage" />	
            	</para>
            </xsl:when>
            <xsl:when test="translate($OrigValForI90, ' ', '') ='HCON' and $ordered-section-type = 'no'">
            	<para loc="90">
                <xsl:call-template name="displayI90Line">
                    <xsl:with-param name="aLegisNumInit">
                        <xsl:text>HCON</xsl:text>
                    </xsl:with-param>					
                </xsl:call-template>		
                <xsl:value-of select="gpo:getLegisNumber($OrigValForI90)" />
                <xsl:text> </xsl:text>
                <xsl:value-of select="$stage" />		
            	</para>
            </xsl:when>
            <xsl:when test="translate($OrigValForI90, ' ', '') = 'HJ'">
            	<para loc="90">
                <xsl:call-template name="displayI90Line">
                    <xsl:with-param name="aLegisNumInit">
                        <xsl:text>HJ</xsl:text>
                    </xsl:with-param>					
                </xsl:call-template>
                <xsl:value-of select="gpo:getLegisNumber($OrigValForI90)" />
                <xsl:text> </xsl:text>
                <xsl:value-of select="$stage" />
            	</para>
            </xsl:when>	
        	<!--Issue #74 and #161 #207 added 'Introduced-in-Senate' and 'Considered-and-Passed-Senate' because number was being output 2x -->
        	<xsl:when test="$billstage = 'Placed-on-Calendar-Senate' or $billstage = 'Introduced-in-Senate'            or $billstage='Reported-in-Senate' or $billstage='Considered-and-Passed-Senate' or            $billstage='Reference-Change-Senate' or $billstage='Referred-in-House' or $billstage='Engrossed-in-Senate'           or $billstage='Reported-in-House' or $billstage='Referred-to-Committee-Senate'">
        		<para loc="90">
        			<xsl:call-template name="displayI90Line">
        				<xsl:with-param name="aLegisNumInit">
        					<xsl:text>S</xsl:text>
        				</xsl:with-param>					
        			</xsl:call-template>		
        			<!--<xsl:value-of select="gpo:getLegisNumber($OrigValForI90)"/>
        			<xsl:text> </xsl:text>-->
        			<!--<xsl:value-of select="$stage"/>	-->
        		</para>
        	</xsl:when>
        	<!--Issue #118 - I90 wasn't formatted correctly -->
        	<xsl:when test="contains($OrigValForI90, 'S RES') ">
        		<para loc="90">
        			<xsl:text>•SRES</xsl:text>
        			<xsl:text> </xsl:text><xsl:value-of select="gpo:getLegisNumber($OrigValForI90)" />
        			<xsl:text> </xsl:text><xsl:value-of select="$stage" />	
        		</para>
        	</xsl:when>
            <xsl:when test="contains($OrigValForI90, 'S') ">
            	<para loc="90">
                <xsl:call-template name="displayI90Line">
                    <xsl:with-param name="aLegisNumInit">
                        <xsl:text>S</xsl:text>
                    </xsl:with-param>					
                </xsl:call-template>
            		<!-- issue #505. This is commented out because it prints the legis-num twice -->
                <!--<xsl:value-of select="gpo:getLegisNumber($OrigValForI90)"/>
                <xsl:text> </xsl:text>
                <xsl:value-of select="$stage"/>-->
            	</para>
            </xsl:when>
            <xsl:otherwise>
            	<para loc="90">
                <xsl:call-template name="displayI90Line">
                    <xsl:with-param name="aLegisNumInit">
                        <xsl:text />
                    </xsl:with-param>					
                </xsl:call-template>	
            		<!--
                <xsl:choose>
                    <xsl:when test="contains($OrigValForI90, 'AMDT.')">
                        <xsl:value-of select="$OrigValForI90"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="translate($OrigValForI90, '.','')"/>
                    </xsl:otherwise>
                </xsl:choose>
                -->
                <xsl:text> </xsl:text>
            	</para>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Returns a string and turns dash (-) into [[ndash]]</desc>
        <issue>There is nothing in the file to say what gets sent to this template.  It doesn't look like
        it gets called by anything.</issue>
        <param>originalData</param>
        <return>113th  - CONGRESS = 1. 13th [[[ndash]]] congress</return>
        <gpo:srcXSL>Named Template:  GenerateI90ForApprop</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:GenerateI90ForApprop" as="xs:string">
        <xsl:param name="originalData" as="xs:string" />
        <xsl:variable name="tempString" select="lower-case($originalData)" />
        <xsl:variable name="tempString1">			
            <xsl:value-of select="normalize-space(translate($tempString, '.', ''))" />
        </xsl:variable>       
        <xsl:variable name="tempString2">			
            <xsl:value-of select="concat(substring($tempString1,1,1), '. ', substring ($tempString1, 2))" />
        </xsl:variable>      
        <xsl:choose>
            <xsl:when test="contains($tempString2,'-')">
                <xsl:value-of select="concat(substring-before($tempString2,'-'), '[[[ndash]]]', substring-after($tempString2,'-'))" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$tempString2" />
            </xsl:otherwise>
        </xsl:choose>	        
    </xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="toPrintTheSlugNumber">		
        <xsl:choose>
            <xsl:when test="not(//amendment-doc/@amend-type ='engrossed-amendment')">
                <!-- nothing -->
            </xsl:when>
            <xsl:when test="//amendment-doc/@amend-degree='second'">
                <xsl:text>2</xsl:text>
            </xsl:when>
            <xsl:when test="//amendment-doc/@amend-degree='third'">
                <xsl:text>3</xsl:text>
            </xsl:when>
            <xsl:when test="//amendment-doc/@amend-degree='fourth'">
                <xsl:text>4</xsl:text>
            </xsl:when>
            <xsl:when test="//amendment-doc/@amend-degree='fifth'">
                <xsl:text>5</xsl:text>
            </xsl:when>
            <xsl:when test="//amendment-doc/@amend-degree='sixth'">
                <xsl:text>6</xsl:text>
            </xsl:when>
        </xsl:choose>		
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Creates acronym for bill stage.</desc>
        <param />
        <return />
        <gpo:srcXSL>Named Template:  ConvStage</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="ConvStage" as="xs:string?">
        <xsl:param name="CStage" />
        
        <xsl:variable name="theSlugNumber">
            <xsl:call-template name="toPrintTheSlugNumber" />
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="//amendment-doc/@dms-id='G'">				
                <xsl:value-of select="concat('AMDT.', substring-after(upper-case(//amend-num), 'AMENDMENT'))" />
            </xsl:when>
            <xsl:when test="upper-case($CStage) ='printed-as-passed' ">
                <xsl:value-of select="'PAP'" />
            </xsl:when>
            <xsl:when test="$CStage='Public-Print' or //bill/@public-print='yes' or //resolution/@public-print='yes'  or //amendment-doc/@public-print='yes'">
                <xsl:value-of select="'PP'" />
            </xsl:when>			
            <xsl:when test="$CStage='Additional-Sponsors-House'">
                <xsl:value-of select="'ASH'" />
            </xsl:when>
            <xsl:when test="$CStage='Additional-Sponsors-Senate'">
                <xsl:value-of select="'SAS'" />
            </xsl:when>
            <xsl:when test="$CStage='Agreed-to-House'">
                <xsl:value-of select="'ATH'" />
            </xsl:when>
            <xsl:when test="$CStage='Agreed-to-Senate'">
                <xsl:value-of select="'ATS'" />
            </xsl:when>
            <xsl:when test="$CStage='Amendment-in-House'">
                <xsl:value-of select="'AH'" />
            </xsl:when>
            <xsl:when test="$CStage='Amendment-in-Senate'">
                <xsl:value-of select="'AS'" />
            </xsl:when>
            <xsl:when test="$CStage='Committee-Discharged-House'">
                <xsl:value-of select="'CDH'" />
            </xsl:when>
            <xsl:when test="$CStage='Committee-Discharged-Senate'">
                <xsl:value-of select="'CDS'" />
            </xsl:when>
            <xsl:when test="$CStage='Considered-and-Passed-House'">
                <xsl:value-of select="'CPH'" />
            </xsl:when>
            <xsl:when test="$CStage='Considered-and-Passed-Senate'">
                <xsl:value-of select="'CPS'" />
            </xsl:when>
            <xsl:when test="$CStage='Engrossed-Amendment-House'">
                <xsl:value-of select="concat('EAH', $theSlugNumber)" />
            </xsl:when>
            <xsl:when test="$CStage='Engrossed-Amendment-Senate'">
                <xsl:value-of select="concat('EAS', $theSlugNumber)" />
            </xsl:when>
            <xsl:when test="$CStage='Engrossed-in-House'">
                <xsl:value-of select="concat('EH', $theSlugNumber)" />
            </xsl:when>
            <xsl:when test="$CStage='Engrossed-in-Senate'">
                <xsl:value-of select="concat('ES', $theSlugNumber)" />
            </xsl:when>
            <xsl:when test="$CStage='Enrolled-Bill'">
                <xsl:value-of select="'ENR'" />
            </xsl:when>
            <xsl:when test="$CStage='Failed-Amendment-House'">
                <xsl:value-of select="'FAH'" />
            </xsl:when>
            <xsl:when test="$CStage='Failed-Passage-House'">
                <xsl:value-of select="'FPH'" />
            </xsl:when>
            <xsl:when test="$CStage='Failed-Amendment-Senate'">
                <xsl:value-of select="'FAS'" />
            </xsl:when>
            <xsl:when test="$CStage='Failed-Passage-Senate'">
                <xsl:value-of select="'FPS'" />
            </xsl:when>
            <xsl:when test="$CStage='Held-at-Desk-House'">
                <xsl:value-of select="'HDH'" />
            </xsl:when>
            <xsl:when test="$CStage='Held-at-Desk-Senate'">
                <xsl:value-of select="'HDS'" />
            </xsl:when>
            <xsl:when test="$CStage='Indefinitely-Postponed-House'">
                <xsl:value-of select="'IPH'" />
            </xsl:when>
            <xsl:when test="$CStage='Indefinitely-Postponed-Senate'">
                <xsl:value-of select="'IPS'" />
            </xsl:when>
            <xsl:when test="$CStage='Introduced-in-House'">
                <xsl:value-of select="'IH'" />
            </xsl:when>
            <xsl:when test="$CStage='Introduced-in-Senate'">
                <xsl:value-of select="'IS'" />
            </xsl:when>
            <xsl:when test="$CStage='Laid-on-Table-House'">
                <xsl:value-of select="'LTH'" />
            </xsl:when>
            <xsl:when test="$CStage='Laid-on-Table-Senate'">
                <xsl:value-of select="'LTS'" />
            </xsl:when>
            <xsl:when test="$CStage='Ordered-to-be-Printed-House'">
                <xsl:value-of select="'OPH'" />
            </xsl:when>
            <xsl:when test="$CStage='Ordered-to-be-Printed-Senate'">
                <xsl:value-of select="'OPS'" />
            </xsl:when>
            <xsl:when test="$CStage='Placed-on-Calendar-House'">
                <xsl:value-of select="'PCH'" />
            </xsl:when>
            <xsl:when test="$CStage='Placed-on-Calendar-Senate'">
                <xsl:value-of select="'PCS'" />
            </xsl:when>
            <xsl:when test="$CStage='Pre-Introduction'">
                <xsl:value-of select="''" />
            </xsl:when>			
            <xsl:when test="$CStage='Re-Enrolled-Bill'">
                <xsl:value-of select="'RENR'" />
            </xsl:when>
            <xsl:when test="$CStage='Received-in-House'">
                <xsl:value-of select="'RDH'" />
            </xsl:when>
            <xsl:when test="$CStage='Received-in-Senate'">
                <xsl:value-of select="'RDS'" />
            </xsl:when>
            <xsl:when test="$CStage='Reengrossed-Amendment-House'">
                <xsl:value-of select="concat('REAH', $theSlugNumber)" />
            </xsl:when>
            <xsl:when test="$CStage='Reengrossed-Amendment-Senate'">
                <xsl:value-of select="concat('REAS', $theSlugNumber)" />
            </xsl:when>
            <xsl:when test="$CStage='Reference-Change-House'">
                <xsl:value-of select="'RCH'" />
            </xsl:when>
            <xsl:when test="$CStage='Reference-Change-Senate'">
                <xsl:value-of select="'RCS'" />
            </xsl:when>
            <xsl:when test="$CStage='Referral-Instructions-House'">
                <xsl:value-of select="'RIH'" />
            </xsl:when>
            <xsl:when test="$CStage='Referral-Instructions-Senate'">
                <xsl:value-of select="'RIS'" />
            </xsl:when>
            <xsl:when test="$CStage='Referred-in-House'">
                <xsl:value-of select="'RFH'" />
            </xsl:when>
            <xsl:when test="$CStage='Referred-in-Senate'">
                <xsl:value-of select="'RFS'" />
            </xsl:when>
            <xsl:when test="$CStage='Referred-to-Committee-House'">
                <xsl:value-of select="'RTH'" />
            </xsl:when>
            <xsl:when test="$CStage='Referred-to-Committee-Senate'">
                <xsl:value-of select="'RTS'" />
            </xsl:when>
            <xsl:when test="$CStage='Referred-w-Amendments-House'">
                <xsl:value-of select="'RAH'" />
            </xsl:when>
            <xsl:when test="$CStage='Referred-w-Amendments-Senate'">
                <xsl:value-of select="'RAS'" />
            </xsl:when>
            <xsl:when test="$CStage='Reported-in-House'">
                <xsl:value-of select="'RH'" />
            </xsl:when>
            <xsl:when test="$CStage='Reported-in-Senate'">
                <xsl:value-of select="'RS'" />
            </xsl:when>
            <xsl:when test="$CStage='Sponsor-Change'">
                <xsl:value-of select="'SC'" />
            </xsl:when>
            <xsl:when test="$CStage='Engrossed-House' or $CStage='Engrossed-in-House'">
                <xsl:value-of select="concat('EH', $theSlugNumber)" />
            </xsl:when>
            <xsl:when test="$CStage='Reported-House'">
                <xsl:value-of select="'RH'" />
            </xsl:when>
            <xsl:when test="$CStage='Enrolled-House'">
                <xsl:value-of select="'ENR'" />
            </xsl:when>
            <xsl:when test="$CStage='Introduced-House'">
                <xsl:value-of select="'IH'" />
            </xsl:when>
            <xsl:when test="$CStage='Pre-Introduction'">
                <xsl:value-of select="''" />
            </xsl:when>
            <xsl:when test="$CStage='Enrolled-in-Senate'">
                <xsl:value-of select="'ENR'" />
            </xsl:when>
            <xsl:when test="$CStage='Re-Enrolled-in-Senate'">
                <xsl:value-of select="'RENR'" />
            </xsl:when>				
            <xsl:when test="contains(//current-chamber,'House')">
                <xsl:value-of select="concat('EAH', $theSlugNumber)" />
            </xsl:when>
            <xsl:when test="contains(//current-chamber,'Senate')">
                <xsl:value-of select="concat('EAS', $theSlugNumber)" />      
            </xsl:when>
            <xsl:otherwise />        
        </xsl:choose>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc />
        <param />
        <return />
        <gpo:srcXSL>Named Template:  displayI90ForAll</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="displayI90ForAll">
    
        <xsl:variable name="toOutput90">
            <xsl:call-template name="toOutputI90Line" />
        </xsl:variable>	
    	
        <xsl:variable name="stage">
            <xsl:choose>
                <xsl:when test="//bill">
                    <xsl:call-template name="ConvStage">
                        <xsl:with-param name="CStage" as="xs:string" select="xs:string(//bill/@bill-stage)" />
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="//resolution">
                    <xsl:call-template name="ConvStage">
                        <xsl:with-param name="CStage" select="//resolution/@resolution-stage" />
                    </xsl:call-template>
                </xsl:when>	
                <xsl:when test="//amendment-doc">
                    <xsl:call-template name="ConvStage">
                        <xsl:with-param name="CStage" select="//amendment-doc/@amend-stage" />
                    </xsl:call-template>
                </xsl:when>	
                <xsl:otherwise>
                    <xsl:call-template name="ConvStage" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>	
        
        <xsl:variable name="OrigValForI90">
            <xsl:choose>
                <xsl:when test="//bill or //resolution">
                    <xsl:value-of select="upper-case(normalize-space(translate($m_legisNumber, '.', '')))" />
                </xsl:when>
                <xsl:when test="//amendment-doc/@dms-id='G'">
                    <xsl:value-of select="$stage" />
                </xsl:when>
            	<!--BH: I added this because amendments fall through to otherwise and the $text variable has
            		both text and markup and fails. We can revisit this when we do in-depth analysis of original
            		versus XSLT2 files.-->
            	<xsl:when test="//amendment-doc">
            		<xsl:value-of select="$stage" />
            	</xsl:when>
                <xsl:otherwise>
                    <xsl:variable name="text">  <xsl:value-of select="substring-before(substring-after(//engrossed-amendment-body/section/text/text(),'('), ')')" /></xsl:variable>
                  <xsl:value-of select="upper-case(normalize-space($text))" />
                    <!--<xsl:value-of select="translate(normalize-space(upper-case(substring-before(substring-after(//engrossed-amendment-body/section/text/text(),'('),')'),'.','')))"/>-->	
                </xsl:otherwise>
            </xsl:choose>	
        </xsl:variable>		
        <!--call actual template**************************************************************-->
        <xsl:choose>
            <xsl:when test="$toOutput90 = 'false'">
                <!-- nothing in this case. this when must be the first one in the choose statement -->
            </xsl:when>
            <xsl:otherwise>
          
	                <xsl:call-template name="actualDisplayI90">
	                    <xsl:with-param name="OrigValForI90" select="$OrigValForI90" />
	                    <xsl:with-param name="stage" select="$stage" />
	                </xsl:call-template>
            	
            </xsl:otherwise>			
        </xsl:choose>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>This template is written to determine when the I90 line should be printed.
            The rules:
            -If the stage is Pre-Introduction, we do not output
            -If the stage is 'Reported' and contains either the following meta-house or meta-senate, we do not output
            -In all other cases we do output</desc>
        <issues>The original template did not have parameters for 'restype' or 'billtype'. Not sure where these variables were picked up.
        I added the parameters to the template.</issues>
        <param>theOrigI90String</param>
        <return>H.R. 419 = 419</return>
        <gpo:srcXSL>Named Template:  toOutputI90Line</gpo:srcXSL>
    </doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="toOutputI90Line" as="xs:string">
        <xsl:param name="billtype" />
        <xsl:choose>			
            <xsl:when test="$billtype='appropriations' and  //pre-form and //bill/@key='G' and //bill/@dms-version!='' ">
                <xsl:text>true</xsl:text>
            </xsl:when>
            <xsl:when test="//pre-form">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="contains(/bill/@bill-stage,'Pre-Introduction') or contains(/resolution/@resolution-stage,'Pre-Introduction')">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:when test="contains(/bill/@bill-stage, 'Enrolled') or contains(/resolution/@resolution-stage, 'Enrolled')">
                <xsl:text>false</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>true</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Returns just the number from the 'legis-num' element.</desc>
        <param>theOrigI90String</param>
        <return>H.R. 419 = 419</return>
        <gpo:srcXSL>Named Template:  getLegisNumber</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:getLegisNumber" as="xs:string">
        <xsl:param name="theOrigI90String" as="xs:string" />		
        <xsl:choose>
            <xsl:when test="contains(substring-after(translate(normalize-space($theOrigI90String),'.','' ), ' '  ), ' ')">
                <xsl:variable name="theOrigI90String"><xsl:value-of select="substring-after(translate(normalize-space($theOrigI90String),'.','' ),' ')" /></xsl:variable>
                <xsl:value-of select="gpo:getLegisNumber($theOrigI90String)" />			
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="string(substring-after(translate(normalize-space($theOrigI90String),'.','' ), ' '  ))" /> 
            </xsl:otherwise>
        </xsl:choose>        		           
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Function to determine whether to print a dagger or not.</desc>
        <param>root - the root element name, i.e., bill</param>
        <param>stage - the stage where the document resides in the legislative process</param>
        <param>chamber - either the 'senate' or 'house'.</param>
        <return>1, 2, 3, 4, 5, or 6</return>
        <gpo:srcXSL>Named Template:  toPrintDagger</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:toPrintDagger" as="xs:string">
        <xsl:param name="stage" as="xs:string?" />
        <xsl:param name="chamber" as="xs:string?" />
    	
        <xsl:variable name="docStage" as="xs:string?">
            <xsl:choose>
            	<!--Issue #64 - Modified the rule so it would pick up lower-case senate. -->
                <xsl:when test="$stage='engrossed-amendment' and contains(lower-case($chamber), 'senate')">
                    <xsl:text>Engrossed-in-Senate</xsl:text>
                </xsl:when>
                <xsl:when test="$stage=''">Do-Not-Print_Dagger</xsl:when>
                <xsl:otherwise><xsl:value-of select="$stage" /></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:choose>
        	<xsl:when test="$stage ='Engrossed-in-Senate'">
        		<xsl:text>yes</xsl:text>
        	</xsl:when>
            <xsl:when test="lower-case($docStage) ='engrossed-in-senate'">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:when test="lower-case($docStage)='printed-as-passed' and contains(lower-case($chamber),'senate')">
                <xsl:text>yes</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>no</xsl:text>
            </xsl:otherwise>			
        </xsl:choose>		
    </xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0">
        <desc>Turns the text 'second', third, fourth, fifth, sixth into a number.  The original template relied on the amendment-doc 
        element.  However, this function can be used for any of the documents.</desc>
        <requirements>In order for this function to work you must send the attributes amend-type and amend-degree</requirements>
        <param>text</param>
        <return>1, 2, 3, 4, 5, or 6</return>
        <gpo:srcXSL>Named Template:  toPrintTheSlugNumber</gpo:srcXSL>
    </doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="gpo:toPrintTheSlugNumber" as="xs:string">	
        <xsl:param name="amend-type" as="xs:string" />
        <xsl:param name="amend-degree" as="xs:string" />
        <xsl:variable name="output">
        <xsl:choose>
            <xsl:when test="$amend-type = 'engrossed-amendment'" />
            <xsl:when test="$amend-degree = 'second'">2</xsl:when>
            <xsl:when test="$amend-degree = 'third'">3</xsl:when>
            <xsl:when test="$amend-degree = 'fourth'">4</xsl:when>
            <xsl:when test="$amend-degree = 'fifth'">5</xsl:when>
            <xsl:when test="$amend-degree = 'sixth'">6</xsl:when>
            <xsl:otherwise />
        </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="normalize-space(string($output))" />
     
    </xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="displayI90Line">
        <xsl:param name="aLegisNumInit" as="xs:string" />
        
        <xsl:variable name="stage" as="xs:string?">
        	<!--Issue #64: The stage was not getting picked up appropriately for amendment-doc.-->
        	<xsl:choose>
        		<xsl:when test="ancestor::bill">
        			<xsl:value-of select="ancestor::bill/@bill-stage" />
        		</xsl:when>
        		<xsl:when test="ancestor::resolution">
        			<xsl:value-of select="ancestor::resolution/@resolution-stage" />
        		</xsl:when>
        		<xsl:when test="ancestor::amendment-doc">
        			<xsl:value-of select="ancestor::amendment-doc/@amend-type" />
        		</xsl:when>
        		<xsl:otherwise />
        	</xsl:choose>
        	<!--<xsl:value-of select="//@bill-stage | //@resolution-stage | //@amend-stage"/>-->
        </xsl:variable>
    	
    	<xsl:variable name="chamber" as="xs:string?">
    		<xsl:value-of select="//current-chamber" />
    	</xsl:variable>
    	<xsl:variable name="keyValue" as="xs:string">
    		<xsl:value-of select="//@key" />
    	</xsl:variable>
        <xsl:variable name="star-print">
        	<xsl:value-of select="//bill/@star-print" />
        </xsl:variable>
        <xsl:variable name="starCount">
            <xsl:value-of select="gpo:starPrint($star-print)" />
        </xsl:variable>
        <xsl:variable name="starString">
            <xsl:value-of select="gpo:getStarString($starCount)" />
        </xsl:variable>
        <xsl:variable name="toPrintDaggerinI90">
            <xsl:value-of select="gpo:toPrintDagger($stage, $chamber)" />
        </xsl:variable>
    	<xsl:choose>
                <xsl:when test="$keyValue='G'"> 
                    <!--<xsl:value-of select="$aLegisNumInit"/>-->
                    <xsl:text> </xsl:text>
                </xsl:when>
                <xsl:when test="$toPrintDaggerinI90='yes'">
                    <xsl:text>† 1A</xsl:text>
                	<!--<xsl:value-of select="$aLegisNumInit"/>-->
                	<xsl:text> </xsl:text>
                </xsl:when>
    		<xsl:when test="$billstage = 'Engrossed-in-Senate'">
    			<xsl:processing-instruction name="xpp">ff;7</xsl:processing-instruction> 
    			<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  
    			<xsl:text>†</xsl:text>
    			<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
    			<xsl:text> </xsl:text>
    		</xsl:when>
    		<xsl:otherwise>
    			<!-- issue #530; additional PIs needed -->
    			<!-- <?xpp mb;.4q?>•<?xpp mb;0?><?xpp mh;-.5q?> -->
    			<xsl:processing-instruction name="xpp">mb;.4q</xsl:processing-instruction>
    			<xsl:text>•</xsl:text>
    			<xsl:processing-instruction name="xpp">mb;0</xsl:processing-instruction>
    			<xsl:processing-instruction name="xpp">mh;.5q</xsl:processing-instruction>
                	<!--<xsl:value-of select="$aLegisNumInit"/>	-->
                    <xsl:if test="normalize-space($aLegisNumInit) != ''">
                    	<!--BH:  commented out the space because upconversion doesn't have it -->
                        <!--<xsl:text> </xsl:text>-->
                    </xsl:if>
                </xsl:otherwise>
        </xsl:choose>
            
    	<xsl:call-template name="PrintStarAndI90Line" />  
        <xsl:choose>
        	<!--BH: 4-22-2016 - added this rule because this we getting picked up in error-->
        	<xsl:when test="$billstage = 'Placed-on-Calendar-Senate'" />   
        	<!--Issue #52 - Processing instructions being output in error -->
        	<xsl:when test="$billstage = 'Referred-in-Senate'" /> 
        	<!--Issue #74 - Processing instructions being output in error-->
        	<xsl:when test="$billstage = 'Introduced-in-Senate'" /> 
        	<!--Issue #161 - Processing instructions being output in error-->
        	<xsl:when test="$billstage = 'Considered-and-Passed-Senate'" /> 
        	<xsl:when test="$billstage = 'Reference-Change-Senate'" />
        	<!--Issue #129 - Processing instructions being output in error-->
        	<xsl:when test="$billstage = 'Reported-in-Senate'" />
        	<!--Issue #213 - Processing instructions being output in error-->
        	<xsl:when test="$billstage = 'Reported-in-House'" />
        	<!--Issue #207 -->
        	<xsl:when test="$billstage = 'Engrossed-in-Senate'" />
        	<!--Issue #250-->
        	<xsl:when test="$billstage = 'Received-in-Senate'" />
        	<!--Issue #375-->
        	<xsl:when test="$billstage = 'Referred-to-Committee-Senate'" /> 
        	<!-- issue #441 -->
        	<xsl:when test="$billstage = 'Committee-Discharged-Senate'" /> 
            <xsl:when test="contains($billstage, 'Senate')">
                    <xsl:processing-instruction name="xpp">ff;6</xsl:processing-instruction> 
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>  
                    <xsl:value-of select="$starString" />
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction> 
            </xsl:when>
            <xsl:otherwise />  
        </xsl:choose>
    </xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" match="action-desc" as="item()*" mode="process">
		<xsl:choose>
			<xsl:when test="(lower-case($docstage) = 'engrossed-in-senate' or lower-case($docstage) = 'engrossed-amendment-senate')     and (//bill/@public-print = 'yes'     or //resolution/@public-print = 'yes')">
				<!-- nothing - in this case the action date dissappears from the printing -->
			</xsl:when>
			<xsl:when test="($docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-House' or $resstage = 'Enrolled-in-Senate')" />
			<xsl:when test="$billstage = 'Printed-as-Passed'" />
			<xsl:when test="not(parent::endorsement)">
				<para loc="47">
					<xsl:apply-templates mode="process" />
				</para>
			</xsl:when>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" match="legis-num" mode="process">
		<xsl:choose>
			<xsl:when test="ancestor::resolution">
				<xsl:call-template name="legisNumInResolution" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="legisNumInBill" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="legisNumInBill" as="item()*">
		
		<xsl:if test="not($billstage = 'Enrolled-Bill' or $resstage = 'Enrolled-in-Senate')">
			<para loc="43">
				<xsl:if test="starts-with(., 'H. R.')">
					<xsl:text> </xsl:text>
				</xsl:if>
				<xsl:value-of select="." />
			</para>
		</xsl:if>
		<xsl:call-template name="printActionDateForBills" />
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="legisNumInResolution" as="item()*">
		<xsl:choose>
			<xsl:when test="$docstage = 'Enrolled-Bill' or $resstage = 'Enrolled-House' or $resstage = 'Enrolled-in-Senate'">
				<xsl:text />
			</xsl:when>
			<xsl:otherwise>
				<xsl:element name="para">
					<xsl:choose>
						<xsl:when test="$resstage = 'Engrossed-in-Senate' and $restype = 'house-resolution'">	
							<xsl:attribute name="loc" select="'01'" />
							<xsl:text>S. </xsl:text>
							<xsl:choose>
								<xsl:when test="starts-with(.,'H.')">
									<xsl:value-of select="substring-after(.,'H.')" />
								</xsl:when>
								<xsl:when test="starts-with(.,'S.')">
									<xsl:value-of select="substring-after(.,'S.')" />
								</xsl:when>
								<xsl:otherwise>
									<xsl:text />
								</xsl:otherwise>
							</xsl:choose>
						</xsl:when>
						<xsl:when test="contains($resstage, 'Engrossed') and ($restype='senate-resolution' or $restype='house-resolution' )">						
							<xsl:attribute name="loc" select="'01'" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:attribute name="loc" select="'50'" />
						</xsl:otherwise>
					</xsl:choose>
					<xsl:choose>
						<xsl:when test="$restype = 'senate-joint'">
							<xsl:value-of select="substring-before(upper-case(/resolution/form/legis-num), 'RES. ')" />
							<xsl:text>RES. </xsl:text>
							<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction> 
							<xsl:value-of select="substring-after(upper-case(/resolution/form/legis-num), 'RES. ')" />
						</xsl:when>
						<xsl:when test="$restype = 'house-joint'">
							<xsl:value-of select="substring-before(upper-case(/resolution/form/legis-num), 'RES. ')" />
							<xsl:text>RES. </xsl:text>
							<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction> 
							<xsl:value-of select="substring-after(upper-case(/resolution/form/legis-num), 'RES. ')" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:choose>
								<xsl:when test="$restype = 'house-concurrent'">
									<xsl:text>H. CON. RES. </xsl:text>
									<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction> 
									<xsl:value-of select="substring-after(upper-case(/resolution/form/legis-num), 'RES. ')" />
								</xsl:when>
								<xsl:when test="$restype = 'constitutional-amendment' and contains($resstage,'Engrossed') ">
									<xsl:value-of select="upper-case(/resolution/form/legis-num)" />
								</xsl:when>
								<xsl:when test="$resstage = 'Engrossed-House' or $resstage = 'Engrossed-in-House'">
									<xsl:text>H. Res. </xsl:text>
									<xsl:value-of select="substring-after(upper-case(/resolution/form/legis-num), 'RES. ')" />
								</xsl:when>
								<xsl:when test="$resstage = 'Engrossed-in-Senate'">
									<xsl:choose>
										<xsl:when test="$restype = 'senate-resolution'">
											<xsl:text>S. Res. </xsl:text>
											<xsl:value-of select="substring-after(upper-case(/resolution/form/legis-num), 'RES. ')" />
										</xsl:when>
										<xsl:when test="$restype = 'senate-concurrent'">										
											<xsl:text>S. CON. RES. </xsl:text>										
											<xsl:value-of select="substring-after(upper-case(/resolution/form/legis-num), 'RES. ')" />
										</xsl:when>
										<xsl:when test="$restype = 'senate-joint'">
											<xsl:text>S. J. RES. </xsl:text>
											<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction> 
										</xsl:when>
									</xsl:choose>
								</xsl:when>
								<xsl:when test="$resstage='Reported-House'">
									<xsl:text>H. RES. </xsl:text>
									<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction> 
									<xsl:value-of select="substring-after(.,'RES. ')" />
								</xsl:when>
								<xsl:otherwise>
									<xsl:apply-templates mode="process" />
								</xsl:otherwise>
							</xsl:choose>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:element>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:call-template name="printActionDateForBills" />		
	</xsl:template><xsl:variable xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="vbCrLf" as="xs:string">
		<xsl:text>
</xsl:text>
	</xsl:variable><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:InStr" as="xs:integer">
		<xsl:param name="string" as="xs:string" />
		<xsl:param name="substring" as="xs:string" />
		
		<xsl:variable name="result" as="xs:integer" select="string-length(substring-before($string, $substring))+1" />
		<xsl:sequence select="$result" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:Left" as="xs:string">
		<xsl:param name="string" as="xs:string" />
		<xsl:param name="num" as="xs:integer" />
		
		<xsl:variable name="result" as="xs:string" select="substring($string, 1, $num)" />
		<xsl:sequence select="$result" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:substring-before-if-contains" as="xs:string?">
		<xsl:param name="arg" as="xs:string?" />
		<xsl:param name="delim" as="xs:string" />
		
		<xsl:sequence select="    if (contains($arg,$delim))    then substring-before($arg,$delim)    else $arg    " />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:substring-after-if-contains" as="xs:string?">
		<xsl:param name="arg" as="xs:string?" />
		<xsl:param name="delim" as="xs:string" />
		
		<xsl:sequence select="    if (contains($arg,$delim))    then substring-after($arg,$delim)    else $arg    " />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:ReplaceCaseAcronym" as="xs:string">
		<xsl:param name="str" as="xs:string" />
		<xsl:param name="sep" as="xs:string" />
		
		<xsl:variable name="secondString" as="xs:string" select="substring-after($str, $sep)" />
		
		
		
		<xsl:sequence select="    if (not(contains($str, $sep))) then $str    else concat(substring-before($str, $sep), $sep, replace($secondString, '^([A-Z])$', lower-case($secondString)))" />
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Checks if a string contains a hyphen followed by numbers ONLY.</desc>
		<param>inStr: the input string to check</param>
		<return>True if the string contains a hyphen followed only by numbers. Otherwise, it returns false</return>
		<gpo:srcXSL>VB Function:  IsHyphenAndNumbers</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:IsHyphenAndNumbers" as="xs:boolean">
		<xsl:param name="inStr" as="xs:string" />
		
		<xsl:variable name="regex" as="xs:string">
			^(.*)?\-[0-9]+$
		</xsl:variable>
		
		<xsl:sequence select="matches($inStr, $regex, 'x')" />
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Processes a string as follows:
			If the string contains a dash, concatenate the string before the dash, the dash and the string after the dash with the
			first letter capitalized, if it matches the pattern
			If the string doesn't contain a dash, return the string
			</desc>
		<param>str: the string to modify</param>
		<return>The modified string</return>
		<gpo:srcXSL>VB Function:  CheckHyphenation</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:CheckHyphenation" as="xs:string">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:variable name="regex" as="xs:string">
			^(&lt;[^&gt;]+&gt;([ktigKTIG][0-9]*)?)*
			((and)|(up[,])|(up)|(if[,])|(if)|(for)|(on)|(a)|(an)|(as)|(at)|(but)|(by)|(in)|(nor)|(of)|(or)|(to)|(the))$
		</xsl:variable>
		
		<xsl:variable name="first" as="xs:string" select="substring-before($str, '-')" />
		
		<xsl:variable name="second" as="xs:string" select="      if (contains($str, '-')) then substring-after($str, '-')      else $str" />

		<xsl:variable name="secondModified" as="xs:string" select="    if (not(matches($second, $regex, 'x'))) then concat(upper-case(substring($second, 1, 1)), substring($second, 2))    else $second" />
		
		<xsl:sequence select="concat($first, '-', $secondModified)" /> 
			
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Processes a string as follows:
			If the string contains a underscore, concatenate the string before the underscore, the underscore and the string after the underscore with the
			first letter capitalized, if it matches the pattern
			If the string doesn't contain a underscore, return the string
		</desc>
		<param>str: the string to modify</param>
		<return>The modified string</return>
		<gpo:srcXSL>VB Function:  CheckUnderscore</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:CheckUnderscore" as="xs:string">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:variable name="regex" as="xs:string">
			^(&lt;[^&gt;]+&gt;([ktigKTIG][0-9]*)?)*
			((and)|(up[,])|(up)|(if[,])|(if)|(for)|(on)|(a)|(an)|(as)|(at)|(but)|(by)|(in)|(nor)|(of)|(or)|(to)|(the))$
		</xsl:variable>
		
		<xsl:variable name="first" as="xs:string" select="substring-before($str, '_')" />
		
		<xsl:variable name="second" as="xs:string" select="    if (contains($str, '_')) then substring-after($str, '_')    else $str" />
		
		<xsl:variable name="secondModified" as="xs:string" select="    if (not(matches($second, $regex, 'x'))) then concat(upper-case(substring($second, 1, 1)), substring($second, 2))    else $second" />
		
		<xsl:sequence select="concat($first, '_', $secondModified)" /> 
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Processes a string as follows:
			If the string contains $chr, concatenate the string before the $chr, the $chr and the string after the $chr with the
			first letter capitalized, if it matches the pattern
			If the string doesn't contain a $chr, return the string
		</desc>
		<param>str: the string to modify</param>
		<param>chr: the character to look for</param>
		<return>The modified string</return>
		<gpo:srcXSL>VB Function:  Combines CheckHyphenation and CheckUnderscore</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:CheckCharacter" as="xs:string">
		<xsl:param name="str" as="xs:string" />
		<xsl:param name="chr" as="xs:string" />
		
		<xsl:variable name="regex" as="xs:string">
			^(&lt;[^&gt;]+&gt;([ktigKTIG][0-9]*)?)*
			((and)|(up[,])|(up)|(if[,])|(if)|(for)|(on)|(a)|(an)|(as)|(at)|(but)|(by)|(in)|(nor)|(of)|(or)|(to)|(the))$
		</xsl:variable>
		
		<xsl:variable name="first" as="xs:string" select="substring-before($str, $chr)" />
		
		<xsl:variable name="second" as="xs:string" select="    if (contains($str, $chr)) then substring-after($str, $chr)    else $str" />
		
		<xsl:variable name="secondModified" as="xs:string" select="    if (not(matches($second, $regex, 'x'))) then concat(upper-case(substring($second, 1, 1)), substring($second, 2))    else $second" />
		
		<xsl:sequence select="concat($first, $chr, $secondModified)" /> 
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Adds an xpp fv;5 PI before  the month (if it exists) in the input string</desc>
		<param>str: the string to process</param>
		<return>A sequence that contains the modified string (if applicable) or the original string</return>
		<gpo:srcXSL>VB Function:  ActionDateText</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:ActionDateText" as="item()*">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:analyze-string select="$str" regex="(January|February|March|April|May|June|July|August|September|October|November|December)" flags="x">
			<xsl:matching-substring>
				<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
				<xsl:sequence select="regex-group(1)" />
			</xsl:matching-substring>
			<xsl:non-matching-substring>
				<xsl:sequence select="." />
			</xsl:non-matching-substring>
		</xsl:analyze-string>
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Processes a string as follows:
			Tokenize the string using the specified separator.
			Process each token: if it matches the pattern, put it back to the string
			Otherwise, capitalize the first charcater and put it back to the string</desc>
		<param>str: the string to check</param>
		<param>chr: the separation character</param>
		<return>True if the string contains any underscores. Otherwise, it returns false</return>
		<gpo:srcXSL>VB Function:  MultipleDesignatedChars</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:MultipleDesignatedChars" as="xs:string">
		<xsl:param name="str" as="xs:string" />
		<xsl:param name="chr" as="xs:string" />
		
		<xsl:variable name="regex" as="xs:string">
			^(&lt;[^&gt;]+&gt;([ktigKTIG][0-9]*)?)*
			((and)|(up[,])|(up)|(if[,])|(if)|(for)|(on)|(a)|(an)|(as)|(at)|(but)|(by)|(in)|(nor)|(of)|(or)|(to)|(the))$
		</xsl:variable>
			
		
		<xsl:variable name="words" as="xs:string*" select="for $word in tokenize($str, $chr) return     if (matches($word, $regex, 'x')) then $word     else concat(upper-case(substring($word, 1,1)), substring($word, 2))" />
		
		<xsl:sequence select="string-join($words, $chr)" />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Checks whether a string contains any underscores</desc>
		<param>str: the string to check</param>
		<return>True if the string contains any underscores. Otherwise, it returns false</return>
		<gpo:srcXSL>VB Function:  IsAllUnderscore</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:IsAllUnderscore" as="xs:boolean">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:sequence select="contains($str, '_')" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:PreventSplitAbbreviations" as="xs:string">
		<xsl:param name="aStrWithAbbr " as="xs:string" />
		<xsl:param name="isForward  " as="xs:boolean" />
		
		<xsl:sequence select="    if ($isForward) then gpo:PreventSplitAbbreviationsForwardSpecialChars(gpo:PreventSplitAbbreviationsForward($aStrWithAbbr))    else gpo:PreventSplitAbbreviationsBackwardSpecialChars(gpo:PreventSplitAbbreviationsBackward($aStrWithAbbr))    " />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:PreventSplitAbbreviationsForward" as="xs:string">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:variable name="theRegexEtWithDot" as="xs:string">
			(et)(\s+)(al|seq)(\.)([,;:\?\-\*!,'])?
		</xsl:variable>
		
		<xsl:variable name="theRegexOpWithDot" as="xs:string">
			(op)(\s+)(sit)(\.)([,;:\?\-\*!,'])?
		</xsl:variable>
		
		<xsl:variable name="theRegexNoDot" as="xs:string">
			(et)(\s+)(al|seq)([,;:\?\-\*!,'])?
		</xsl:variable>
			
		<xsl:sequence select="replace(replace(replace($str, $theRegexEtWithDot, '$1$3$4$5','x'), $theRegexOpWithDot, '$1$3$4$5', 'x'), $theRegexNoDot, '$1__$3$4', 'x')" />
	
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:PreventSplitAbbreviationsForwardSpecialChars" as="xs:string">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:variable name="regexQuote" as="xs:string">
			\[\[\[rdquo\]\]\] | \[\[\[singleclosequote\]\]\] | \[\[\[apos\]\]\]
		</xsl:variable>
		<xsl:variable name="regexMdash" as="xs:string">
			\[\[\[mdash\]\]\]
		</xsl:variable>
		
		<xsl:variable name="subSpecialChars" as="xs:string" select="replace(replace($str, $regexMdash, '$1 ', 'x'), $regexQuote, ' $1', 'x')" />
		
		<!-- remove the trailing space after [[[mdash]]], if any -->
		<xsl:sequence select="    if (ends-with($subSpecialChars, '\[\[\[mdash\]\]\] ')) then substring($subSpecialChars, 0, string-length($subSpecialChars)-1)    else $subSpecialChars" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:PreventSplitAbbreviationsBackward" as="xs:string">
		<xsl:param name="aStrWithAbbr" as="xs:string" />
		
		<xsl:variable name="theRegexEt" as="xs:string">
			(et)(__)?(al|seq)(\.)?([,;:\?\-\*!,'])?
		</xsl:variable>
		
		<xsl:variable name="theRegexOp" as="xs:string">
			(op)(sit)(\.)([,;:\?\-\*!,']?)"
		</xsl:variable>
		
		<xsl:sequence select="    if (matches($aStrWithAbbr, $theRegexEt, 'x')) then replace($aStrWithAbbr, $theRegexEt, '$1 $3$4$5', 'x')    else if (matches($aStrWithAbbr, $theRegexOp, 'x')) then replace($aStrWithAbbr, $theRegexOp, '$1 $2$3$4', 'x')    else $aStrWithAbbr" />

	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:PreventSplitAbbreviationsBackwardSpecialChars" as="xs:string">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:variable name="regexQuote" as="xs:string">
			(\s)(\[\[\[rdquo\]\]\]) | (\s)(\[\[\[singleclosequote\]\]\]) | (\s)(\[\[\[apos\]\]\])
		</xsl:variable>
		<xsl:variable name="regexMdash" as="xs:string">
			(\[\[\[mdash\]\]\])(\s)
		</xsl:variable>
		
		<xsl:sequence select="replace(replace($str, $regexMdash, '$1', 'x'), $regexQuote, ' $2', 'x')" />
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Checks whether a string contains any special characters.</desc>
		<param>str: the string to check</param>
		<return>True if the string contains spaecial characters. Otherwise, it returns false</return>
		<gpo:srcXSL>VB Function:  CheckForSpecial</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:CheckForSpecial" as="xs:boolean">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:variable name="specialCharPattern" as="xs:string*" select="    '\[agrave\] | \[egrave\] | \[igrave\] | \[ograve\] | \[ugrave\] | \[aacute\] |    \[iacute\] | \[oacute\] | \[uacute\] | \[yacute\] | \[acirc\] | \[ecirc\] | \[icirc\] | \[ocirc\] | \[ucirc\] |    \[auml\] | \[euml\] | \[iuml\] | \[ouml\] | \[uuml\] | \[atilde\] | \[ntilde\] | \[otilde\] | \[bslash\] |    \[cents\] | \[secmark\] | \[ellipsis\] | \[lessequal\] | \[greaterequal\] | \[alig\] | \[ccedil\] |    \[eth\] | \[oslash\] | \[thorn\] | \[szlig\] | \[aring\] | \[lowereth\] | \[ygrave\] | \[yuml\] |    \[upsideexclamation\] | \[upsidequestionmark\] | \[pounds\] | \[spikydot\] | \[yen\] |    \[paramark\] | \[copyright\] | \[tm\] | \[superundera\] | \[superundero\] | \[doublelessthan\] |    \[doublegreaterthan\] | \[micro\] | \[slanty\] | \[degree\] | \[dot\] | \[times\] | \[div\] | \[superone\] |    \[supertwo\] | \[superthree\] | \[onefourth\] | \[onehalf\] | \[threefourth\] | \[onethird\] | \[twothird\] |    \[oneeight\] | \[threeeight\] | \[fiveeight\] | \[seveneight\] | \[pipe\] | \[enddoublequote\] |    \[singleclosequote\] | \[doubleclosequote\] | \[euro\] | \[doubleprime\] | \[prime\] | \[tilde\] |    \[thinspace\] | \[loweralpha\] | \[upperalpha\] | \[lowerbeta\] | \[upperbeta\] |    \[lowergamma\] | \[uppergamma\] | \[lowerdelta\] | \[upperdelta\] | \[lowerepsilon\] | \[upperepsilon\] |    \[lowerpi\] | \[upperpi\]'    " />

		<xsl:sequence select="    if (matches($str, $specialCharPattern, 'x')) then true()    else false()" />
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Checks whether the chars before and after a certain position in the string is lower case and if they are, it converts the string to upper case</desc>
		<param>str: the string to check</param>
		<return>The modified string or the original string if the condition is not met</return>
		<gpo:srcXSL>VB Function:  convertWordToUpperByCondition</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:convertWordToUpperByCondition" as="xs:string">
		<xsl:param name="aWord" as="xs:string" />
		<xsl:param name="aSepPos" as="xs:integer" />
		
		<xsl:sequence select="    if (matches(substring($aWord, $aSepPos - 1, 1), '[a-z]')    and matches(substring($aWord, $aSepPos + 1, 1), '[a-z]'))then upper-case($aWord)    else $aWord" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:firstLetterToLower" as="xs:string">
		<xsl:param name="aWord" as="xs:string" />
		<xsl:param name="aIsFirstWord" as="xs:boolean" />
		<xsl:param name="aIsHeaderInText" as="xs:boolean" />
		
		<xsl:variable name="aWordLower" as="xs:string" select="lower-case($aWord)" />
		<xsl:variable name="aWordFirstCharUpper" as="xs:string" select="concat(upper-case(substring($aWord, 0, 1)), substring($aWord, 1))" />
		<xsl:variable name="aWordFirstCharLower" as="xs:string" select="concat(lower-case(substring($aWord, 0, 1)), substring($aWord, 1))" />
		<xsl:choose>
			<xsl:when test="$aIsFirstWord">
				<xsl:choose>
					<xsl:when test="not($aIsHeaderInText)">
						<xsl:sequence select="$aWordFirstCharUpper" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:sequence select="$aWord" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="$aWord eq 'to'">
						<xsl:sequence select="$aWord" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:sequence select="$aWordFirstCharLower" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
		
		
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Checks whether a string contains all UpperCase charcaters before a specific character in the string</desc>
		<param>str: the string to check</param>
		<param>chr: checks for characters before the first occurence of this character </param>
		<return>True if the string contains all upper case characters before chr. Otherwise, it returns false</return>
		<gpo:srcXSL>VB Function:  isAllCapsBefore</gpo:srcXSL>
	</doc><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:isAllCapsBefore" as="xs:boolean">
		<xsl:param name="str" as="xs:string" />
		<xsl:param name="chr" as="xs:string" />
		
		<xsl:variable name="regex" as="xs:string">
			<xsl:text />
		</xsl:variable>
		
		<xsl:variable name="index" as="xs:integer" select="gpo:InStr($str, $chr)" />
		<xsl:variable name="word" as="xs:string" select="gpo:Left($str, $index)" />
		
		<xsl:sequence select="    if (matches($word, '^((&lt;[^&gt;]+&gt;([ktigKTIG][0-9]+)?)*)[A-Z0-9]+$')) then true()    else false()" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:ExtractEnumInHeaderTrue" as="xs:string*">
		<xsl:param name="aHeader" as="xs:string" />
		<xsl:param name="enumInHeaderOrigValue" as="item()*" />
		
		<xsl:variable name="stringToReplace" as="xs:string" select="'enuminheader01272009'" />
		<xsl:variable name="startIndex" as="xs:integer" select="gpo:InStr(lower-case($aHeader), '&lt;bel&gt;t1')" />
		
		<xsl:sequence select="''" />
	</xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="officialTitleSpace" as="item()*">
		<xsl:param name="officalTitle" as="xs:string" />
		<xsl:param name="EclauseType" as="xs:string" />
		<xsl:param name="DocType" as="xs:string?" />
		
		<xsl:variable name="belA" as="xs:string" select="'&lt;BEL&gt;A'" />
		
		<!-- get the string before $belA -->
		<xsl:variable name="vOfficialTitle" as="xs:string" select="    if (contains($officalTitle, $belA)) then substring-before($officalTitle, $belA)    else $officalTitle" />
		
		<xsl:variable name="offtitlelines" as="xs:integer" select="    if ($EclauseType = 'yes') then 4 + xs:integer((string-length($vOfficialTitle) + 54) div 55 )    else 2 + xs:integer((string-length($vOfficialTitle) + 54) div 55 )" />
		
		<xsl:variable name="padcount" as="xs:integer">
			<xsl:choose>
				<xsl:when test="not($DocType = 'house-joint'       or $DocType = 'house-concurrent'      or $DocType = 'constitutional-amendment'       or $DocType = 'un-sec')">
					
					<xsl:sequence select="       if ($EclauseType = 'yesPP') then gpo:CalculatePadLinesForPP($offtitlelines, string-length($vOfficialTitle))       else if ($EclauseType = 'yesPAP') then gpo:CalculatePadLinesForPP($offtitlelines+6, string-length($vOfficialTitle))       else if ($offtitlelines &lt; 5) then min((30, 48 - (2 * $offtitlelines)))       else if ($offtitlelines &lt; 8) then min((27, 48 - (2 * $offtitlelines)))       else 44 - (2 * $offtitlelines)       " />
				</xsl:when>
				<xsl:otherwise>
					<xsl:sequence select="       if ($DocType = 'constitutional-amendment') then 23       else if ($DocType = 'house-joint') then 23       else if ($DocType = 'house-concurrent' and $EclauseType = 'preamble') then 26       else if ($DocType = 'house-concurrent') then 23       else if ($DocType = 'un-sec') then 23       else 28" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:call-template name="ActualInsertEmptyLines">
			<xsl:with-param name="padcount" as="xs:integer" select="$padcount" />
		</xsl:call-template>
		
	</xsl:template><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:CalculatePadLinesForPP" as="xs:integer">
		<xsl:param name="officialTitleLinesNumber" as="xs:integer" />
		<xsl:param name="officialTitleCharsCount" as="xs:integer" />
		
		<xsl:sequence select="    if ($officialTitleLinesNumber = 0) then 28    else if ($officialTitleLinesNumber = 1) then 26    else if ($officialTitleLinesNumber = 2) then 26    else if ($officialTitleLinesNumber = 3) then 23    else if ($officialTitleLinesNumber = 4) then 23    else if ($officialTitleLinesNumber = 5 and $officialTitleCharsCount &lt; 270) then 23    else if ($officialTitleLinesNumber = 5) then 27    else if ($officialTitleLinesNumber = 6) then 24    else if ($officialTitleLinesNumber = 7) then 22    else if ($officialTitleLinesNumber = 8) then 20    else if ($officialTitleLinesNumber = 9) then 18    else if ($officialTitleLinesNumber = 10) then 18    else if ($officialTitleLinesNumber = 11) then 18    else if ($officialTitleLinesNumber = 12) then 18    else 20" />
	</xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="ActualInsertEmptyLines" as="item()*">
		<xsl:param name="padcount" as="xs:integer" />
			
		<xsl:choose>
			<xsl:when test="$padcount &gt; 0">
				<xsl:value-of select="$vbCrLf" />
				<para loc="20">
					<xsl:value-of select="$vbCrLf" /> </para>
				<xsl:call-template name="ActualInsertEmptyLines">
					<xsl:with-param name="padcount" as="xs:integer" select="$padcount - 1" />
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise><xsl:text /></xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:isUpperAlpha" as="xs:boolean">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:sequence select="matches($str, '^[A-Z]+$')" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:isUpper" as="xs:boolean">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:sequence select="$str eq upper-case($str)" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:capFW" as="xs:string">
		<xsl:param name="PString" as="xs:string" />
		<xsl:variable name="tokenizedPString" as="xs:string*" select="tokenize(normalize-space($PString), '\s+')" />
		<xsl:variable name="capFWsequence" as="item()*" select="    for $i in $tokenizedPString    return    (gpo:capitalize-first($i))" />
		
		<xsl:sequence select="normalize-space(string-join($capFWsequence, ' '))" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:capitalize-first" as="xs:string">
		<xsl:param name="arg" as="xs:string" />
		<xsl:choose>
			<xsl:when test="$arg='and' or $arg='for' or $arg='on' or $arg='a' or $arg='an' or $arg='as' or $arg='at' or $arg='but' or $arg='by'      or $arg='in' or $arg='nor' or $arg='of' or $arg='or' or $arg='to' or $arg='the' or $arg='etc'">
				<xsl:value-of select="$arg" />
			</xsl:when>
			<xsl:otherwise><xsl:sequence select="     concat(upper-case(substring($arg, 1, 1)),     lower-case(substring($arg, 2)))     " /></xsl:otherwise>
		</xsl:choose>	
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:rawRegexReplace" as="xs:string?">
	 <xsl:param name="input" as="xs:string" />
	 <xsl:param name="pattern" as="xs:string" />
	 <xsl:param name="replacement" as="xs:string" />
		
		<xsl:sequence select="replace($input, $pattern, $replacement)" />
	</xsl:function><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common">
		<desc>Tokenizes the input string based on the input parameter char and it turns each token to Initial Cap (IC)
		except connectors such as 'the', 'or', etc. as specified in the FirstWordCapitalize template
		</desc>
		<param>text: the string to convert</param>
		<param>char: the character to use as a delimeter</param>
		<return>the converted string</return>
		<gpo:srcXSL />
	</doc><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="CapICHeader-WordWithSpecialChar">
		<xsl:param name="text" as="xs:string" />
		<xsl:param name="char" as="xs:string" />
		<xsl:variable name="string">
			<xsl:for-each select="tokenize(., $char)">
				<xsl:choose>
					<!-- first word is always init cap -->
					<xsl:when test="position() = 1">
						<xsl:value-of select="concat(upper-case(substring(., 1, 1)), substring(., 2, string-length(.)))" />
					</xsl:when>
					<!-- if a word after the hypen starts with upper case, leave as is -->
					<xsl:when test="upper-case(substring(., 1, 1)) = substring(., 1, 1)">
						<xsl:value-of select="." />
					</xsl:when>
					<!-- all other are lower case -->
					<xsl:otherwise>
						<xsl:value-of select="lower-case(.)" />
					</xsl:otherwise>
				</xsl:choose>
				<xsl:if test="not(position() = last())">
					<xsl:value-of select="$char" />
				</xsl:if>
			</xsl:for-each>
		</xsl:variable>
		<xsl:value-of select="translate($string, ' ', '')" />
	</xsl:template><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:capICHeader" as="xs:string*">
		<xsl:param name="in" as="xs:string?" />     
		
		<!-- save any pre-text that doesn't need to be capitalzie such
			as "PART II" and put it back after done with the capitalization
		-->
		<xsl:variable name="pretext" as="xs:string?">
			<xsl:choose>
				<!-- fixes issue #216. The word Part could be in all upper or first initial -->
				<!-- fixes issue #287 -->
				<xsl:when test="matches($in, '^((PART|Part|Subtitle|Subchapter) [A-Z]+—)')">
					<xsl:sequence select="concat(substring-before($in, '—'), '—')" />
				</xsl:when>
				<!-- issue #295 -->
				<xsl:when test="matches($in, '^((Chapter) [0-9]+—)')">
					<xsl:sequence select="concat(substring-before($in, '—'), '—')" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:sequence select="''" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="toProcess" as="xs:string?" select="substring-after($in, $pretext)" />
		
		<xsl:variable name="s">
			<xsl:for-each select="tokenize($toProcess, '\s+')">
				<xsl:choose>
					<!-- special words stay asis issue #413-->
					<!-- allow optional non-alpanumeric chareacters before and after the word: example: to, -->
					<xsl:when test="matches(., '^([^a-zA-Z0-9]*)(and|for|on|a|an|as|at|but|by|in|nor|of|or|to|the|etc)([^a-zA-Z0-9]*)$')">
						<xsl:value-of select="." />
					</xsl:when>
					<xsl:when test="matches(., '\(.*\)')">
						<xsl:value-of select="." />
					</xsl:when>
					<!-- when the word starts with quote, capitalize the word after the quote -->
					<xsl:when test="matches(., '^(“)([a-z])')">
						<xsl:analyze-string select="." regex="^(“)([a-z])">
							<xsl:matching-substring>
								<xsl:value-of select="concat(regex-group(1), upper-case(regex-group(2)))" />
							</xsl:matching-substring>
							<xsl:non-matching-substring>
								<xsl:value-of select="." />
							</xsl:non-matching-substring>
						</xsl:analyze-string>
					</xsl:when>
					<!-- fixes issue #235. Handles words that contain multiple hyphens -->
					<xsl:when test="contains(., '-')">
						<xsl:call-template name="CapICHeader-WordWithSpecialChar">
							<xsl:with-param name="text" select="." />
							<xsl:with-param name="char" select="'-'" />
						</xsl:call-template>
					</xsl:when>
					<xsl:when test="matches(., '([A-Za-z_]+)([\-|&amp;|/|—])([A-Za-z_]+)')">
						<xsl:analyze-string select="." regex="([A-Za-z_]+)([\-|&amp;|/|—])([A-Za-z_]+)">
							<xsl:matching-substring>
								<xsl:value-of select="concat(gpo:capitalize-first(regex-group(1)), regex-group(2), gpo:capitalize-first(regex-group(3)))" />
							</xsl:matching-substring>
							<xsl:non-matching-substring>
								<xsl:value-of select="gpo:capitalize-first-word(.)" />
							</xsl:non-matching-substring>
						</xsl:analyze-string>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="gpo:capitalize-first-word(.)" />
					</xsl:otherwise>
				</xsl:choose>
				<xsl:if test="position() != last()"><xsl:text> </xsl:text></xsl:if>
			</xsl:for-each>
		</xsl:variable>
		
		<xsl:value-of select="concat($pretext, $s)" />
		<!--<xsl:sequence select="normalize-space(concat($pretext, string-join($s, ' ')))"/>-->
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:capICHeaderInText" as="xs:string?">
		<xsl:param name="str" as="xs:string" />
		
		<xsl:sequence select="concat('todo-capICHeaderInText(', $str, ')')" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:capFWHeader">
		<xsl:param name="in" />
		<xsl:apply-templates select="$in" mode="capFWHeader" />
	</xsl:function><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" match="processing-instruction()" mode="capFWHeader">
		<xsl:processing-instruction name="{name(.)}" select="." />
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" match="text()" mode="capFWHeader">
		
		<xsl:variable name="normalizedText" as="xs:string" select="." />
		
		<!-- get the first word of the text node, we need it for more additional tests later in the code below -->
		<xsl:variable name="firstWord" as="xs:string" select="tokenize($normalizedText, '\s+')[1]" />
		<xsl:variable name="strAfterFirstWord" as="xs:string?" select="substring-after($normalizedText, $firstWord)" />
		
		<!--[<xsl:value-of select="$normalizedText"/>
		<xsl:text>:</xsl:text>
		<xsl:value-of select="position()"/>
		<xsl:text>:</xsl:text>
		<xsl:value-of select="count(preceding-sibling::text())"/>
		<xsl:text>:</xsl:text>
		<xsl:value-of select="$firstWord"/>]-->
		
		<xsl:choose>
			<!-- if this is a one character word, use it asis -->
			<xsl:when test="string-length($normalizedText) = 1">
				<xsl:value-of select="$normalizedText" />
			</xsl:when>
			<!-- handle the first text node in the sentence -->
			<xsl:when test="count(preceding-sibling::text()) = 0">
					<xsl:choose>
						<!-- if the first word of the text node is an acronym or all caps, return the string as is -->
						<xsl:when test="position() = 1 and upper-case($firstWord) = $firstWord">
							<!--<xsl:value-of select="$normalizedText"/>-->
							<xsl:value-of select="concat($firstWord, lower-case($strAfterFirstWord))" />
						</xsl:when>
						<!-- if the first node starts with space, initialCap the first letter after the space -->
						<xsl:when test="position() = 1 and (starts-with($normalizedText, ' '))">
							<xsl:text> </xsl:text>
							<xsl:value-of select="concat(upper-case(substring(normalize-space($normalizedText), 1, 1)), lower-case(substring(normalize-space($normalizedText), 2, string-length($normalizedText))))" />
						</xsl:when>
						<!-- issue #424: if the first word contains a hyphen and more than one upper-case character, 
							keep the first word and lower-case everything else
							otherwise, upper-case the first character, lower-case the rest (logic taken from VB script)
							-->
						<xsl:when test="position() = 1 and contains($firstWord, '-')">
							<xsl:choose>
								<xsl:when test="string-length(replace($firstWord, '[^A-Z]', '')) &gt; 2">
									<xsl:value-of select="concat($firstWord, lower-case($strAfterFirstWord))" />
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="concat(upper-case(substring(normalize-space($normalizedText), 1, 1)), lower-case(substring(normalize-space($normalizedText), 2, string-length($normalizedText))))" />
								</xsl:otherwise>
							</xsl:choose>
							
						</xsl:when>
						<!-- Turn the first letter of the first text node to upper case -->
						<xsl:when test="position() = 1">
							<xsl:value-of select="concat(upper-case(substring($normalizedText, 1, 1)), lower-case(substring($normalizedText, 2, string-length($normalizedText))))" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="lower-case($normalizedText)" />
						</xsl:otherwise>
					</xsl:choose>
					<!--<xsl:if test="position() != last()">
						<xsl:text> </xsl:text>
					</xsl:if>-->
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="lower-case($normalizedText)" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" match="text()" mode="XXXcapFWHeader">
		[<xsl:value-of select="." />
		<xsl:text>:</xsl:text>
		<xsl:value-of select="position()" />
		<xsl:text>:</xsl:text>
		<xsl:value-of select="count(preceding-sibling::text())" />]
		<xsl:choose>
			<xsl:when test="string-length(.) = 1 or count(tokenize(., '\s+')) = 1">
				<xsl:sequence select="." />
			</xsl:when>
			<!-- handle the first text node in the sentence -->
			<xsl:when test="count(preceding-sibling::text()) = 0">
				<xsl:for-each select="tokenize(., '\s+')">
					<xsl:choose>
						<!-- if the first node starts with upper-case, leave it as is -->
						<xsl:when test="position() = 1 and (upper-case(substring(., 1, 1)) = substring(., 1, 1))">
							<xsl:sequence select="." />
						</xsl:when>
						<xsl:when test="position() = 1 and (upper-case(substring(., 1, 1)) = substring(., 1, 1))">
							<xsl:sequence select="concat(upper-case(substring(., 1, 1)), lower-case(substring(., 2, string-length(.))))" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:sequence select="lower-case(.)" />
						</xsl:otherwise>
					</xsl:choose>
					<xsl:if test="position() != last()">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:for-each>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="lower-case(.)" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:OLD_capFWHeader" as="item()*">
		<xsl:param name="in" as="item()*" />
		
		<xsl:variable name="out" as="item()*">
		<xsl:for-each select="$in">
			<xsl:choose>
				<xsl:when test="self::text()">
					<xsl:variable name="text" select="." />
					<xsl:for-each select="tokenize($text, '\s+')">
						<xsl:choose>
							<xsl:when test="position()=1">
								<xsl:value-of select="concat(upper-case(substring(., 1, 1)), substring(., 2, string-length(.)))" />
							</xsl:when>
							<xsl:when test="matches(., '\(.*\)')">
								<xsl:value-of select="." />
							</xsl:when>
							<!-- this doesn't seem to apply for capFWHeader(); commeting out for now until
								we find a case where we will need to handle words separated with the charcaters below that
								need to be capitalized on each side -->
							<!--
							<xsl:when test="matches(., '([A-Za-z_]+)([\-|&amp;|/|—])([A-Za-z_]+)')">
								<xsl:analyze-string select="." regex="([A-Za-z_]+)([\-|&amp;|/|—])([A-Za-z_]+)">
									<xsl:matching-substring>
										<xsl:value-of select="concat(gpo:capitalize-first(regex-group(1)), regex-group(2), gpo:capitalize-first(regex-group(3)))"/>
									</xsl:matching-substring>
									<xsl:non-matching-substring>
										<xsl:value-of select="gpo:capitalize-first-word(.)"/>
									</xsl:non-matching-substring>
								</xsl:analyze-string>
							</xsl:when>
							-->
							<xsl:otherwise>
								<xsl:value-of select="lower-case(.)" />
							</xsl:otherwise>
						</xsl:choose>
						<xsl:if test="position() != last()">
							<xsl:text> </xsl:text>
						</xsl:if>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<xsl:sequence select="." />
				</xsl:otherwise>
			</xsl:choose>
		   </xsl:for-each>
		</xsl:variable>
		
		<xsl:sequence select="$out" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:TocEntry" as="item()*">
		<xsl:param name="str" as="xs:string" />
		<xsl:param name="toUpper" as="xs:boolean" />
		
		<xsl:variable name="nstr" as="xs:string" select="normalize-space($str)" />
		<xsl:sequence select="if (starts-with(upper-case($nstr), 'SEC.')) then gpo:handleTocEntryWithSec($nstr)        else if (starts-with(upper-case($nstr), 'TITLE') or starts-with(upper-case($nstr), 'DIVIS')) then gpo:handleTocEntryWithTitleOrDivis($nstr, $toUpper)        else $nstr" />
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:handleTocEntryWithSec" as="item()*">
		<xsl:param name="str" as="xs:string" />
		<xsl:variable name="sectionNum" select="tokenize($str, ' ')[2]" />
		<xsl:variable name="restOfString" select="substring-after($str, $sectionNum)" />
		<xsl:choose>
			<xsl:when test="contains($str, ' ') or contains($str, ' ')">
				<xsl:sequence select="$str" />
			</xsl:when>
			<xsl:when test="upper-case($str) = 'SEC.'">
				<xsl:sequence select="$str" />
			</xsl:when>
			<xsl:when test="$sectionNum != ''">
				<!-- fixes issues #266, #198, #278, #270 -->
				<xsl:analyze-string select="$str" regex="^Sec\.( | \s|\s)+([0-9]+[A-Z]?\.)( | \s|\s)+(.*)$">
					<xsl:matching-substring>
						<!-- issue #198 -->
						<xsl:sequence select="concat('Sec. ', regex-group(2), ' ', regex-group(4))" />
					</xsl:matching-substring>
					<xsl:non-matching-substring>
						<!--BH:  Some strings were falling past the regex -->
						<xsl:text>Sec. </xsl:text><xsl:value-of select="$sectionNum" />
						<xsl:text> </xsl:text>
						<xsl:sequence select="substring-after($restOfString, ' ')" />
					</xsl:non-matching-substring>
				</xsl:analyze-string>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="$str" />
			</xsl:otherwise>
		</xsl:choose>
		
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:handleTocEntryWithTitleOrDivis" as="item()*">
		<xsl:param name="str" as="xs:string" />
		<xsl:param name="toUpper" as="xs:boolean" />
		
		<xsl:analyze-string select="$str" regex="^(.*)(&lt;BEL&gt;T1)(.*)(&lt;BEL&gt;TT)(.*)$" flags="i">
			<xsl:matching-substring>
				<xsl:sequence select="concat(upper-case(regex-group(1)), regex-group(3), upper-case(regex-group(5)))" />
			</xsl:matching-substring>
			<xsl:non-matching-substring>
				<xsl:sequence select="if ($toUpper) then upper-case($str) else ($str)" />
			</xsl:non-matching-substring>
		</xsl:analyze-string>
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:convertGraphic" as="xs:string?">
		<xsl:param name="imagedata" as="xs:string" />
		<xsl:param name="file" as="xs:string" />
		
		<xsl:sequence select="concat('todo-convertGraphic(', $imagedata, $file, ')')" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:convertTable" as="xs:string?">
		<xsl:param name="s1" as="xs:string" />
		<xsl:param name="s2" as="xs:string" />
		<xsl:param name="s3" as="xs:string" />
		<xsl:param name="s4" as="xs:string" />
		<xsl:param name="s5" as="xs:string" />
		
		<xsl:sequence select="concat('todo-convertTable(', $s1, $s2, $s3, $s4, $s5, ')')" />
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:escapeWithBelKandBelT4" as="item()*">
		<xsl:param name="str" as="xs:string" />
		<xsl:param name="patt" as="xs:string" />
		
		<xsl:analyze-string select="$str" regex="$patt">
			<xsl:matching-substring>
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:sequence select="regex-group(1)" />
				<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction> 
			</xsl:matching-substring>
			<xsl:non-matching-substring>
				<xsl:sequence select="$str" />
			</xsl:non-matching-substring>
		</xsl:analyze-string>
	</xsl:function><xsl:function xmlns:uc="http://www.infinity-loop.de/DTD/upcast/V3.0/" xmlns:str="http://xsltsl.org/string" xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:exslt="http://exslt.org/common" name="gpo:printType">
		<xsl:param name="node" />
		<xsl:choose>
			<xsl:when test="$node/self::text()">text</xsl:when>
			<xsl:when test="$node/self::processing-instruction()">pi</xsl:when>
			<xsl:when test="$node/self::comment()">comment</xsl:when>
			<xsl:otherwise>other</xsl:otherwise>
		</xsl:choose>
	</xsl:function><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="paragraph/text" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="paragraph/enum" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="paragraph/header" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="paragraph[@display-inline = 'yes-display-inline'][subparagraph[@display-inline != 'yes-display-inline']][not(@other-style='archaic')]" mode="process">
        <xsl:apply-templates select="subparagraph[not(@display-inline) or @display-inline='no-display-inline']" mode="inline" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="paragraph[@display-inline = 'no-display-inline' or not(@display-inline)]" mode="process">
        <xsl:variable name="levelLocator" as="xs:double">
            <xsl:call-template name="createLevelLocator" />
        </xsl:variable>
        <xsl:variable name="actualLevelLocator" as="item()*">
            <xsl:choose>
                <xsl:when test="@indent"> 
                    <xsl:call-template name="findActualLocator">
                        <xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator" /></xsl:with-param>
                    </xsl:call-template></xsl:when>
                <xsl:otherwise><xsl:value-of select="$levelLocator" /></xsl:otherwise>
            </xsl:choose>          
        </xsl:variable>
        <xsl:variable name="comment">paragraph[@display-inline = 'no-display-inline' or not(@display-inline)] - <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:choose>
            <xsl:when test="child::subparagraph/@display-inline = 'yes-display-inline'">
                <para loc="{$actualLevelLocator}">
                     <xsl:text>  </xsl:text>
                     <xsl:if test="ancestor::quoted-block">
                         <xsl:text>“</xsl:text>
                     </xsl:if>
                     <xsl:value-of select="enum" />
                     <!-- fix for issue #225; space ONLY if there is a header -->
                     <xsl:if test="header">
                         <xsl:text> </xsl:text>
                         <xsl:call-template name="createHeader" />
                     </xsl:if>
                     <xsl:call-template name="createSubparagraphInline" />
                     <xsl:if test="quoted-block[display-inline='yes-display-inline']/text">
                         <xsl:apply-templates select="quoted-block[display-inline='yes-display-inline']/text" />
                     </xsl:if>
                 </para>
                <!--Issue #526 - We need to take care of subparagraph/clause/subclause that is not in-line-->
                <xsl:apply-templates select="subparagraph[@display-inline='yes-display-inline']/clause[@display-inline='yes-display-inline']/subclause[not(@display-inline) or @display-inline='no-display-inline']" mode="process" />
                 <!--We need to take care of clauses in the Subparagraph--> 
                 <xsl:apply-templates select="subparagraph[@display-inline='yes-display-inline']/clause[not(@display-inline) or @display-inline='no-display-inline']" mode="process" />
                <xsl:apply-templates select="subparagraph[@display-inline='yes-display-inline']/clause[@display-inline='yes-display-inline']/clause[not(@display-inline) or @display-inline='no-display-inline']" mode="process" />
                <!-- Issue #107 - continuation-text was not being output when the subparagraph was 'yes-display-inline -->
                 <xsl:apply-templates select="subparagraph[@display-inline='yes-display-inline']/continuation-text" mode="process" />
                 <xsl:apply-templates select="subparagraph[not(@display-inline) or @display-inline='no-display-inline']" mode="process" />
                <!--Issue #535-->
                <xsl:apply-templates select="continuation-text" mode="process" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="paragraph-no-display-inline" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="paragraph-no-display-inline">
        <xsl:variable name="subparagraphNumber" select="count(child::subparagraph)" />
        <xsl:variable name="inQuotedBlock" as="xs:string">
            <xsl:choose>
                <xsl:when test="ancestor::quoted-block">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="isPrecedingTable">
            <xsl:choose>
                <xsl:when test="preceding-sibling::table">yes</xsl:when>
                <xsl:when test="preceding-sibling::*/name() = name()">
                    <xsl:if test="descendant::table[position() = last()]">yes</xsl:if>
                </xsl:when>
           <xsl:otherwise />
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="isCommented" as="xs:string">
            <xsl:choose>
                <xsl:when test="./@commented='yes'">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:variable name="node" select="." as="item()" />
        <xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
        <xsl:variable name="style" as="xs:string">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>
        <xsl:variable name="levelLocator" as="xs:string">
            <xsl:call-template name="calculateLocator">
                <xsl:with-param name="level" select="local-name(.)" />
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="comment">paragraph 2 - <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <para>
            <xsl:attribute name="loc">
                <xsl:value-of select="translate($levelLocator, '  ', '')" />
            </xsl:attribute>
            <xsl:choose>
                <xsl:when test="@style='OLC' and @vbattChangedForReported='italic' and                      @vbattParentFormat='AddOrDelete'  and ($subparagraphNumber = 1) and not(subparagraph/clause)">
                    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise />
            </xsl:choose>
            <!-- TASSOS: Added two emspaces per Deb's suggestion -->
            <xsl:text>  </xsl:text>
            <xsl:if test=" $inQuotedBlock='yes' and not(parent::subsection and @display-inline='yes-display-inline')  and  header and $style='archaic-paragraph' ">
                <xsl:choose>
                    <xsl:when test="./header/enum-in-header">
                        <xsl:value-of select="$insertNewlineBeforeElement" />
                        <xsl:attribute name="loc">74</xsl:attribute>
                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$insertNewlineBeforeElement" />
                        <xsl:attribute name="loc">89</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>      
                <xsl:value-of select="gpo:QuotedBlockNextingStart" />
                <xsl:if test="header/enum-in-header or header/child::*">
                    <xsl:variable name="headerText" as="xs:string">
                        <xsl:apply-templates select="header" mode="AllCaps" />
                    </xsl:variable>
                    <xsl:call-template name="lowerCaseExceptEnumInHeader">
                        <xsl:with-param name="aHeaderText" select="$headerText" />
                    </xsl:call-template>
                </xsl:if>
                <xsl:if test="not(./header/enum-in-header) and not (./header/child::*)">				
                    <xsl:value-of select="lower-case(./header)" />
                </xsl:if>
            </xsl:if>
            
            <xsl:if test="ancestor::whereas">
                <xsl:choose>
                    <xsl:when test="@changed='deleted'">
                        <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="@changed='added'">
                        <xsl:choose>
                            <xsl:when test="@reported-display-style='strikethrough' or @vbattChangedForReported='strikethrough' ">
                                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="(contains(./@reported-display-style, 'boldface-italic') or contains(@vbattChangedForReported, 'boldface-italic') )">
                                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="(contains(./@reported-display-style, 'boldface-roman') or contains(@vbattChangedForReported, 'boldface-roman'))">
                                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>					
                            </xsl:otherwise>
                        </xsl:choose>	
                        
                    </xsl:when>
                    <xsl:when test="not(@changed) and ancestor::whereas/@changed='added'">
                        <xsl:choose>
                            <xsl:when test="@reported-display-style='italic' or @vbattChangedForReported='italic' ">
                                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="(contains(./@reported-display-style, 'boldface-italic') or contains(@vbattChangedForReported, 'boldface-italic') )">
                                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="(contains(./@reported-display-style, 'boldface-roman') or contains(@vbattChangedForReported, 'boldface-roman'))">
                                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                            </xsl:when>
                            
                        </xsl:choose>	
                    </xsl:when>
                    <xsl:when test="ancestor::whereas/@changed='deleted' and (@reported-display-style='strikethrough' or @vbattChangedForReported='strikethrough') ">
                        <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    </xsl:when>
                </xsl:choose>
            </xsl:if>
            <xsl:if test="not(@display-inline='yes-display-inline') or not(@display-inline)">
                <xsl:call-template name="OpeningSectionTemplate">
                    <xsl:with-param name="aToPrintLevelLocator"><xsl:text>no</xsl:text></xsl:with-param>
                    <xsl:with-param name="aLevelLocator" select="$levelLocator" />
                </xsl:call-template>			
            </xsl:if>
            <xsl:if test="enum">			
                <xsl:if test="ancestor::section and ancestor::section/child::text[position()=1] and ../subsection[1] = . ">
                    <xsl:text> </xsl:text>
                </xsl:if>
                <xsl:apply-templates select="./enum" mode="go" />
                <xsl:if test="(header or text) and not(string(enum)='')">
                    <xsl:text> </xsl:text>
                </xsl:if>
            </xsl:if>
            
            <xsl:if test="header and not($style='archaic-paragraph' )">
                <xsl:choose>
                    <xsl:when test="contains($levelLocator,'20')  or contains(substring-before(.,' '),'&amp;') ">
                        <!-- fixes issue #174. It looks like the same PI is created below when processing header in Special mode
                            It is posible that the code below is still needed in certain cases (it is in the original LXL code).
                            I am disabling this code but leaving it here for now. Be aware if the code below is needed, it will
                            create a duplicate fv;5 xpp PI in certain cases (see issue #174 in GitHub) -->
                        <!-- fixes issue #322; it looks like we are not processing header in Special mode anymore (see code below)
                            so the PI needs to be added manually -->
                         <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="starts-with($style , 'archaic') and //legis-body[@style='OLC']">
                        <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:choose>
                    <xsl:when test="starts-with($style , 'archaic') and //legis-body[@style='OLC']">
                        <xsl:apply-templates select="header" mode="InitialCaps">
                            <xsl:with-param name="level" select="$levelLocator" />
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:variable name="textCount" select="string-length(header)" as="xs:integer" />
                        <!-- issue #54 -->
                        <!-- right here, we are supposed to turn the first letter of the text into upper case and the rest into
                            lower case. However, we need to take care of special cases such as TSA or (TSA) -->
                        <!--
                        <xsl:call-template name="initialCapsFirstLetterInSentence">
                            <xsl:with-param name="s" select="header"/>
                        </xsl:call-template>-->
                        
                        <!--<xsl:value-of select="upper-case(substring(header, 1, 1))"/>
                        <xsl:value-of select="lower-case(substring(header, 2, $textCount))"/>-->
                        
                        <!-- original LXL code -->
                        <!-- fixes issue #399 -->
                        
                       
                       <xsl:apply-templates select="header" mode="Special" />
                        <!--Issue #251-->
                        
                  <!--    
                 <xsl:variable name="text" select="substring(normalize-space(header), 2, $textCount)"/>  
				 <xsl:value-of select="substring(upper-case(normalize-space(header)), 1, 1)"/>
                     <xsl:choose>
                         <xsl:when test="not(contains($text, ' '))"><xsl:call-template name="TestForUppercase">
                             <xsl:with-param name="text" select="$text"/>
                         </xsl:call-template>
                         </xsl:when>
                         <xsl:when test="contains(text,' ')">
                             <xsl:call-template name="TestForUppercase">
                                 <xsl:with-param name="text" select="substring-before($text,' ')"/>
                             </xsl:call-template>
                             <xsl:text> </xsl:text>
                             <xsl:call-template name="TestForUppercase">
                                 <xsl:with-param name="text" select="substring-after($text,' ')"/>
                             </xsl:call-template>
                         </xsl:when>
                         <xsl:otherwise>
                             <xsl:call-template name="TestForUppercase">
                                 <xsl:with-param name="text" select="$text"/>
                             </xsl:call-template>
                         </xsl:otherwise>
                     </xsl:choose> -->
                        
                         <xsl:choose>
                             <!--Issue #367-->
                             <xsl:when test="@style='OLC' and ancestor::amendment-doc">
                                 <xsl:text>.—</xsl:text>
                                 <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                             </xsl:when>
                             <xsl:otherwise>
                                 <!-- TASSOS added PI rs-font -->
                                 <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                                 <xsl:text>.—</xsl:text> 
                             </xsl:otherwise>
                         </xsl:choose>      
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:if>
            
            <xsl:if test=" header  and not(text) and $isCommented='yes' and $inQuotedBlock='yes' ">❩</xsl:if>
            
            <xsl:apply-templates select="text" mode="inline" />
            <xsl:if test="quoted-block[@display-inline = 'yes-display-inline']">
            <xsl:apply-templates select="quoted-block[@display-inline = 'yes-display-inline']" mode="inline" />
            </xsl:if>
            <xsl:if test="ancestor::quoted=block and not(../*/enum) and not(../*/header) and not(../*/text) and not(ancestor::quoted-block/continuation-text)">
            <xsl:value-of select="gpo:addClosingCharacter(.)" />
            </xsl:if>
            <!--Issue #221-->
            <!-- Issue #323; this fix undoes fix #221;  I have checked the LXL code and the
                code below is not there so I am commenting it. it is possible that
                issue #221 will resurface in which case we need to take care of it
                -->
            <!-- <xsl:if test="quoted-block[@display-inline = 'yes-display-inline']/text">
                <xsl:text> &#x201C;</xsl:text>
                <xsl:for-each select="quoted-block[@display-inline = 'yes-display-inline']/text">
                    <xsl:apply-templates mode="process"/>
                </xsl:for-each>
            </xsl:if>-->
        </para>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="TestForUppercase">
        <xsl:param name="text" />
        <xsl:variable name="charCount" select="string-length($text)" />
        <xsl:choose>
            <xsl:when test="upper-case($text) = $text"><xsl:value-of select="$text" /></xsl:when>
            <!--Issue #313-->
            <xsl:when test="count(replace($text, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"><xsl:value-of select="$text" /></xsl:when>
            <xsl:when test="count(replace($text, 'abcdefghijklmnopqrstuvwxyz', '')) &gt; ($charCount - 1)"><xsl:value-of select="$text" /></xsl:when>
            <xsl:otherwise><xsl:value-of select="lower-case($text)" /></xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="header" mode="paragraph">
       <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="paragraph/header/text()[1]" mode="process">
        <xsl:variable name="string-length" select="string-length(.)" />
        <xsl:value-of select="upper-case(substring(., 1, 1))" /><xsl:value-of select="lower-case(substring(., 2, $string-length))" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="paragraph/header/text()[position() &gt; 1]" mode="process">
        <xsl:value-of select="lower-case(.)" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="paragraph">
        <xsl:variable name="inQuotedBlock" as="xs:string">
            <xsl:choose>
                <xsl:when test="ancestor::quoted-block">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="isCommented" as="xs:string">
            <xsl:choose>
                <xsl:when test="./@commented='yes'">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:variable name="node" select="." as="item()" />
        <xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
        <xsl:variable name="style" as="xs:string">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>
        <xsl:variable name="levelLocator" as="xs:string">
            <xsl:call-template name="calculateLocator">
                <xsl:with-param name="level" select="local-name(.)" />
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="comment">Paragraph 1 <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <para>
            <xsl:attribute name="loc"><xsl:value-of select="translate($levelLocator, '  ', '')" /></xsl:attribute>
            <xsl:if test=" $inQuotedBlock='yes' and not(parent::subsection and @display-inline='yes-display-inline')  and  header and $style='archaic-paragraph' ">
                <xsl:choose>
                    <xsl:when test="./header/enum-in-header">
                        <xsl:value-of select="$insertNewlineBeforeElement" />
                        <xsl:attribute name="loc">74</xsl:attribute>
                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$insertNewlineBeforeElement" />
                        <xsl:attribute name="loc">89</xsl:attribute>
                    </xsl:otherwise>
                </xsl:choose>      
                <xsl:value-of select="gpo:QuotedBlockNextingStart" />
                <xsl:if test="header/enum-in-header or header/child::*">
                    <xsl:variable name="headerText" as="xs:string">
                        <xsl:apply-templates select="header" mode="AllCaps" />
                    </xsl:variable>
                    <xsl:call-template name="lowerCaseExceptEnumInHeader">
                        <xsl:with-param name="aHeaderText" select="$headerText" />
                    </xsl:call-template>
                </xsl:if>
                <xsl:if test="not(./header/enum-in-header) and not (./header/child::*)">				
                    <xsl:value-of select="lower-case(./header)" />
                </xsl:if>
            </xsl:if>
            
            <xsl:if test="ancestor::whereas">
                <xsl:choose>
                    <xsl:when test="@changed='deleted'">
                        <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="@changed='added'">
                        <xsl:choose>
                            <xsl:when test="@reported-display-style='strikethrough' or @vbattChangedForReported='strikethrough' ">
                                <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="(contains(./@reported-display-style, 'boldface-italic') or contains(@vbattChangedForReported, 'boldface-italic') )">
                                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="(contains(./@reported-display-style, 'boldface-roman') or contains(@vbattChangedForReported, 'boldface-roman'))">
                                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>					
                            </xsl:otherwise>
                        </xsl:choose>	
                        
                    </xsl:when>
                    <xsl:when test="not(@changed) and ancestor::whereas/@changed='added'">
                        <xsl:choose>
                            <xsl:when test="@reported-display-style='italic' or @vbattChangedForReported='italic' ">
                                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="(contains(./@reported-display-style, 'boldface-italic') or contains(@vbattChangedForReported, 'boldface-italic') )">
                                <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                            </xsl:when>
                            <xsl:when test="(contains(./@reported-display-style, 'boldface-roman') or contains(@vbattChangedForReported, 'boldface-roman'))">
                                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                            </xsl:when>
                            
                        </xsl:choose>	
                    </xsl:when>
                    <xsl:when test="ancestor::whereas/@changed='deleted' and (@reported-display-style='strikethrough' or @vbattChangedForReported='strikethrough') ">
                        <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    </xsl:when>
                </xsl:choose>
            </xsl:if>
            <xsl:if test="not(@display-inline='yes-display-inline') or not(@display-inline)">
                <xsl:call-template name="OpeningSectionTemplate">
                    <xsl:with-param name="aToPrintLevelLocator"><xsl:text>no</xsl:text></xsl:with-param>
                    <xsl:with-param name="aLevelLocator" select="$levelLocator" />
                </xsl:call-template>			
            </xsl:if>
            <xsl:if test="enum">			
                <xsl:if test="parent::section and parent::section/child::text[position()=1] and ../subsection[1] = . ">
                    <xsl:text> </xsl:text>
                </xsl:if>
                <xsl:apply-templates select="./enum" mode="go" />
                <xsl:if test="(header or text) and not(string(enum)='')">
                    <xsl:text> </xsl:text>
                </xsl:if>
            </xsl:if>
            
            <xsl:if test="header and not($style='archaic-paragraph' )">
                <xsl:choose>
                    <xsl:when test="contains($levelLocator,'20')  or contains(substring-before(.,' '),'&amp;') ">
                        <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:when test="starts-with($style , 'archaic') and //legis-body[@style='OLC']">
                        <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:choose>
                    <xsl:when test="starts-with($style , 'archaic') and //legis-body[@style='OLC']">
                        <xsl:apply-templates select="header" mode="InitialCaps">
                            <xsl:with-param name="level" select="$levelLocator" />
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="header" />—
                        <!--<xsl:apply-templates select="header" mode="Special">
							<xsl:with-param name="level" select="$levelLocator"/>
						</xsl:apply-templates>-->
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:if>
            
            <xsl:if test=" header  and not(text) and $isCommented='yes' and $inQuotedBlock='yes' ">❩</xsl:if>
            
            <xsl:apply-templates select="text" mode="inline" />
            <xsl:value-of select="gpo:addClosingCharacter(.)" /> 
        </para>
        <xsl:apply-templates mode="process" />		
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="paragraph[@other-style='archaic']         [@display-inline='yes-display-inline']" mode="process">
        
        <para format="6201" loc="20">
            <xsl:text>  </xsl:text>
            <xsl:if test="ancestor::quoted-block">
                <xsl:text>“</xsl:text>
            </xsl:if><xsl:value-of select="../enum" /><xsl:value-of select="enum" /><xsl:text> </xsl:text>
            <xsl:apply-templates select="text" mode="inline" />
        </para>
        <xsl:apply-templates select="subparagraph" mode="process" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="paragraph" mode="inline">
        <xsl:apply-templates select="enum" mode="inline" /><xsl:text> </xsl:text><xsl:apply-templates select="text" mode="inline" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="initialCapsFirstLetterInSentence">
        <xsl:param name="s" as="xs:string?" />
        
        <xsl:for-each select="tokenize($s, '\s+')">
            <xsl:choose>
                <xsl:when test=". = upper-case(.)">
                    <xsl:value-of select="." />
                </xsl:when>
                <xsl:when test="position() = 1">
                    <xsl:value-of select="concat(upper-case(substring(., 1, 1)), lower-case(substring(., 2, string-length(.))))" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="lower-case(.)" />
                   </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="position() != last()">
                <xsl:text> </xsl:text>
            </xsl:if>
            
        </xsl:for-each>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section" mode="process">
    	<xsl:variable name="countHeaderFollowingSiblings" select="count(./header[following-sibling::node()])" as="xs:integer" />
    	<xsl:variable name="section-type" as="xs:string">
            <xsl:choose>
                <xsl:when test="@section-type">
                	<xsl:value-of select="@section-type" />
                </xsl:when>
                <xsl:otherwise>not-set</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
    	<xsl:variable name="inQuotedBlock" as="xs:string">
            <xsl:choose>
                <xsl:when test="ancestor::quoted-block">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
    	<xsl:variable name="node" select="." as="node()" />
    	<xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
    	<xsl:variable name="style" as="xs:string">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>
    	<xsl:variable name="levelLocator" as="item()*">
            <xsl:call-template name="locatorForSection">
                <xsl:with-param name="style" select="$style" />
                <xsl:with-param name="section-type" select="$section-type" />
            </xsl:call-template>
        </xsl:variable>
    	
    	<xsl:variable name="linesOffOn" as="xs:string?" select="gpo:getLineNumbersValue(.)" />
           
    	<xsl:variable name="reportedDisplayStyle" as="xs:string?">			
            <xsl:if test="@vbattChangedForReported != ''">
                <xsl:value-of select="@vbattChangedForReported" />
            </xsl:if>
            <xsl:if test="not(@vbattChangedForReported != '') and @reported-display-style !=''">
                <xsl:value-of select="@reported-display-style" />
            </xsl:if>
        </xsl:variable>
    	<xsl:variable name="beginingOfEnumTextPhrase" as="xs:string?">
            <xsl:if test="$linesOffOn = 'off'">
                <xsl:call-template name="getBegginingOfThePhraseLiseOff">
                    <xsl:with-param name="aBeginingFor">
                        <xsl:text>enumText</xsl:text>
                    </xsl:with-param>
                    <xsl:with-param name="aReportingStyle" select="$reportedDisplayStyle" />
                    <xsl:with-param name="aStyle" select="$style" />
                </xsl:call-template>
            </xsl:if>
        </xsl:variable>
    	<xsl:variable name="endOfEnumTextPhrase" as="xs:string?">
            <xsl:if test="$linesOffOn = 'off'">
                <xsl:call-template name="getEndOfThePhraseLiseOff">
                    <xsl:with-param name="aBeginingFor">
                        <xsl:text>enumText</xsl:text>
                    </xsl:with-param>
                    <xsl:with-param name="aReportingStyle" select="$reportedDisplayStyle" />
                    <xsl:with-param name="aStyle" select="$style" />
                </xsl:call-template>
            </xsl:if>
        </xsl:variable>
    	<!--BH: Created to cure datatype issues-->
    	<xsl:variable name="beginText" select="substring-before(., ' ')" />
    	<xsl:variable name="isCommented" as="xs:string?">
            <xsl:choose>
                <xsl:when test="./@commented='yes'">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>	
    	<xsl:variable name="firstUndesignatyedInBlock" as="xs:string">
            <xsl:call-template name="IsSectionFirstInBlockUndesignated" />
        </xsl:variable>
    	<xsl:variable name="comment">standard-section <xsl:value-of select="@id" /></xsl:variable>
    	<xsl:sequence select="gpo:outputComment($comment)" />
        <xsl:choose>
        	<xsl:when test="$section-type='section-one'">
        		<xsl:call-template name="section-section-one" />
        	</xsl:when>
        	<xsl:when test="(child::subsection/@display-inline = 'yes-display-inline' or child::subsection/text/@display-inline = 'yes-display-inline')           and (@section-type != 'section-one' or @section-type != 'subsequence-section') and @style != 'traditional'">
        		<xsl:call-template name="sectionSubsectionDisplayInline" />
        	</xsl:when>
        	<xsl:when test="(child::paragraph/@display-inline = 'yes-display-inline' or child::paragraph/text/@display-inline = 'yes-display-inline') and           @style != 'traditional'">
        		<xsl:call-template name="sectionParagraphDisplayInline" />
        	</xsl:when>
        	<xsl:when test="$section-type='subsequent-section' and $style='USC' and (not(child::subsection) or not(child::paragraph))">
        		<xsl:call-template name="createSectionLoc75" />
        	</xsl:when>
            <xsl:when test="$style='tradition'">
                <xsl:call-template name="createGenericSection">
                    <xsl:with-param name="firstUndesignatyedInBlock" select="$firstUndesignatyedInBlock" />
                    <xsl:with-param name="levelLocator" select="$levelLocator" />
                    <xsl:with-param name="countHeaderFollowingSiblings" select="$countHeaderFollowingSiblings" />
                </xsl:call-template>
            </xsl:when>
        	<xsl:when test="@style='traditional'">
        		<xsl:if test="header">
        			<para>
        				<xsl:call-template name="createFormat" />
        				<xsl:choose>
        					<xsl:when test="contains(./header, '__') or descendant::header/enum-in-header">
        						<xsl:attribute name="loc">74</xsl:attribute>&gt;
        						<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
        					</xsl:when>
        					<xsl:otherwise>
        						<xsl:attribute name="loc">89</xsl:attribute> 
        					</xsl:otherwise>
        				</xsl:choose>
        				<xsl:call-template name="OpeningSectionTemplate">
        					<xsl:with-param name="aToPrintLevelLocator">no</xsl:with-param>
        					<xsl:with-param name="aLevelLocator" select="$levelLocator" />
        				</xsl:call-template>
        				<xsl:apply-templates select="./header" mode="AllLower" />
        			</para>
        		</xsl:if>			
        		<para loc="20">
        			<xsl:call-template name="createFormat" />
        			<xsl:if test="ancestor::quoted-block">
        				<xsl:text>“</xsl:text>
        			</xsl:if>
        			<xsl:processing-instruction name="xpp">fv:3</xsl:processing-instruction>
        			<!--Issue #82: suppressed the word 'Sec.' when the 'enum' element is empty. -->
        			<xsl:choose>
        				<xsl:when test="@section-type = 'undesignated-section'" />
        				<xsl:otherwise><xsl:text>Sec. </xsl:text>
        					<xsl:value-of select="enum" /></xsl:otherwise>
        			</xsl:choose>
        			<xsl:apply-templates select="text" mode="inline" />
        		</para>
        		<xsl:apply-templates select="* except text" mode="process" />
        	</xsl:when>
            <xsl:when test="$style='OLC'">
                <xsl:call-template name="createGenericSection">
                    <xsl:with-param name="firstUndesignatyedInBlock" select="$firstUndesignatyedInBlock" />
                    <xsl:with-param name="levelLocator" select="$levelLocator" />
                    <xsl:with-param name="countHeaderFollowingSiblings" select="$countHeaderFollowingSiblings" />
                </xsl:call-template>
            </xsl:when>
        	<xsl:when test="$style='USC'">
        		<xsl:call-template name="createGenericSection">
        			<xsl:with-param name="firstUndesignatyedInBlock" select="$firstUndesignatyedInBlock" />
        			<xsl:with-param name="levelLocator" select="$levelLocator" />
        			<xsl:with-param name="countHeaderFollowingSiblings" select="$countHeaderFollowingSiblings" />
        		</xsl:call-template>
        	</xsl:when>
        	<xsl:otherwise>
            <!--Original Code that does not work -->
        
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:choose>
			<xsl:when test="@section-type='ordered' ">
				<xsl:value-of select="$levelLocator" />
				<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction><xsl:text>Ordered, </xsl:text><xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				<xsl:apply-templates select="*" mode="process" />
			</xsl:when>	
			<xsl:when test="$style='USC'">
				<xsl:if test="not(@display-inline) or @display-inline != 'yes-display-inline' or ($firstUndesignatyedInBlock='yes' and @display-inline='yes-display-inline' )">
					<xsl:call-template name="OpeningSectionTemplate">
						<xsl:with-param name="aToPrintLevelLocator">yes</xsl:with-param>
						<xsl:with-param name="aLevelLocator" select="$levelLocator" />
					</xsl:call-template>
				</xsl:if>
				<xsl:variable name="resolvedPhrase" as="item()*">
					<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>Resolved, <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				</xsl:variable>
				<xsl:call-template name="printGeneratedSectionWord">
					<xsl:with-param name="aSectionOnePhrase"><xsl:text>§ 1A</xsl:text></xsl:with-param><!-- <xsl:text>&lt;ACK&gt;&lt;ASC255&gt;1A</xsl:text> --><!-- 08/26/2015 mharcourt Revision based on updated character replacements in xmlOutputSpec.docx file. -->
					<xsl:with-param name="aResolvedPhrase" select="$resolvedPhrase" /><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
					<xsl:with-param name="aUndesignatedPhrase"><xsl:text /></xsl:with-param>
					<xsl:with-param name="aDefaultPhrase"><xsl:text>§ 1A</xsl:text></xsl:with-param><!-- <xsl:text>&lt;ACK&gt;&lt;ASC255&gt;1A</xsl:text> --><!-- 08/26/2015 mharcourt Revision based on updated character replacements in xmlOutputSpec.docx file. -->
				</xsl:call-template>						    
				<xsl:if test="enum">
					<xsl:apply-templates select="enum" mode="goTrad" />
					<xsl:if test="(./header or ./text) and not(string(./enum)='')">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>
				<xsl:if test="./header">
					<xsl:apply-templates select="./header" mode="Sentence" />
					
				</xsl:if>
				<!-- TB Bug fixing #1308 -->
				<xsl:if test="@external-xref and @external-xref != '' and (ancestor::ramseyer or ancestor::cordon)">
						<para loc="71">
							<xsl:call-template name="createFormat" />
						<xsl:value-of select="@external-xref " />
						</para>
				</xsl:if>
				<!-- end TB Bug fixing #1308 -->
				<xsl:apply-templates select="*" mode="process" />
			</xsl:when>
			<xsl:when test="starts-with($style ,'traditional')">
				<xsl:variable name="notDeleted" as="xs:string">no</xsl:variable>
				<xsl:if test="header">
					<xsl:choose>
						<xsl:when test="$style ='traditional-inline'" />		
						<xsl:otherwise>
							<para>
								<xsl:call-template name="createFormat" />
								<xsl:choose>
									<xsl:when test="contains(./header, '__') or descendant::header/enum-in-header">
										<xsl:attribute name="loc">74</xsl:attribute>&gt;
										<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
									</xsl:when>
									<xsl:otherwise>
										<xsl:attribute name="loc">89</xsl:attribute> 
									</xsl:otherwise>
								</xsl:choose>
								<xsl:call-template name="OpeningSectionTemplate">
									<xsl:with-param name="aToPrintLevelLocator">no</xsl:with-param>
									<xsl:with-param name="aLevelLocator" select="$levelLocator" />
								</xsl:call-template>
								<xsl:apply-templates select="./header" mode="AllLower" />
							</para>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:if test="$countHeaderFollowingSiblings &gt; 0 and  not($style ='traditional-inline')">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>				
				<xsl:if test="not(@display-inline = 'yes-display-inline') or  $firstUndesignatyedInBlock='yes'">				
					<xsl:if test="(./enum or ./text) and not(parent::constitution-article and ./@section-type='undesignated-section')">		
						<xsl:call-template name="OpeningSectionTemplate">
							<xsl:with-param name="aToPrintLevelLocator">yes</xsl:with-param>
							<xsl:with-param name="aLevelLocator" select="$levelLocator" />
						</xsl:call-template>
					</xsl:if>  
				</xsl:if>
				<xsl:if test="$notDeleted='yes'">
					<xsl:choose>
						<xsl:when test="@section-type='section-one'">
							<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction><xsl:text>Section </xsl:text>
						</xsl:when>
						<xsl:when test="@section-type='resolved' ">
							<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction><xsl:text>Resolved, </xsl:text>
							<xsl:if test="not(string(./enum)='') ">
								<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
								<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
								<xsl:text>Sec. </xsl:text>
							</xsl:if>
						</xsl:when>
						<xsl:when test="@section-type='undesignated-section'  and $firstUndesignatyedInBlock='no' ">				    			
							<xsl:choose>
								<xsl:when test="@reported-display-style='strikethrough' or @vbattChangedForReported='strikethrough' ">
									<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
								</xsl:when>
								<xsl:when test="(contains(./@reported-display-style, 'boldface-italic') or contains(@vbattChangedForReported, 'boldface-italic') )">
									<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
								</xsl:when>
								<xsl:when test="(contains(./@reported-display-style, 'boldface-roman') or contains(@vbattChangedForReported, 'boldface-roman'))">
									<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
								</xsl:when>				    					
								<xsl:otherwise />
							</xsl:choose>
						</xsl:when>		
						<xsl:when test="@section-type='undesignated-section'  and $firstUndesignatyedInBlock='yes' ">				    			
							<xsl:choose>
								<xsl:when test="(./@reported-display-style = 'italic' or @vbattChangedForReported = 'italic') and not (ancestor-or-self::resolution-body/@vbattChangedForReported = 'italic'  ) ">
									<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
								</xsl:when>	
								<xsl:when test="@reported-display-style='strikethrough' or @vbattChangedForReported='strikethrough' ">
									<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
								</xsl:when>
								<xsl:when test="(contains(./@reported-display-style, 'boldface-italic') or contains(@vbattChangedForReported, 'boldface-italic') )">
									<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction><xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
								</xsl:when>
								<xsl:when test="(contains(./@reported-display-style, 'boldface-roman') or contains(@vbattChangedForReported, 'boldface-roman')) and not (contains(ancestor-or-self::resolution-body/@vbattChangedForReported,'boldface-roman'))">
									<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
								</xsl:when>				    					
								<xsl:otherwise />
							</xsl:choose>
						</xsl:when>		
							<xsl:otherwise>	
							<xsl:if test="not(@section-type='undesignated-section'  )">
								<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
								<xsl:value-of select="$beginingOfEnumTextPhrase" />
								<xsl:text>Sec.</xsl:text>	
								<xsl:value-of select="$endOfEnumTextPhrase" />
								<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><xsl:text> </xsl:text>
							</xsl:if>
							<xsl:if test="contains(./@section-type,'undesignated')">    		
								<xsl:text> </xsl:text>    		
							</xsl:if>
						</xsl:otherwise>
					</xsl:choose>					    		
				</xsl:if>
				<xsl:if test="./@changed and not(./@changed='no-change') and ./@reported-display-style='strikethrough'">
					<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
				</xsl:if>
				<xsl:if test="@section-type='resolved' and not (position()=1) and $notDeleted='no'">
					<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction><xsl:text>Resolved, </xsl:text>
				</xsl:if>	
				<xsl:if test="not(string(./enum)='') and $notDeleted='no' ">
					 <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					<xsl:text>Sec. </xsl:text>
				</xsl:if>
				<xsl:choose>
					<!--<xsl:when
						test="contains($levelLocator,'I20')   and not(/amendment-doc[@amend-type='conference-report'])">-->
					<xsl:when test="(contains($beginText, '&amp;') or contains($levelLocator/text(), '20'))   and not(/amendment-doc[@amend-type='conference-report'])">
						<xsl:if test="./enum">
							<xsl:apply-templates select="./enum" mode="goTrad" />
							<xsl:if test="(./header or ./text) and not(string(./enum)='')">
								<xsl:text> </xsl:text>
							</xsl:if>
							<xsl:if test="local-name(../..)='quoted-block' and local-name(..)='constitution-article' and ../enum">
								<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
							</xsl:if>
						</xsl:if>
						<xsl:if test="$style ='traditional-inline'">
							<xsl:if test="./header">
								<xsl:apply-templates select="./header" mode="InitialCaps">
									<xsl:with-param name="insertPeriod">Yes</xsl:with-param>
								</xsl:apply-templates>						           
							</xsl:if>
						</xsl:if>
						<xsl:if test="not(parent::constitution-article)">
							<xsl:if test="$firstUndesignatyedInBlock='no' and not(@section-type='section-one')">
								<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
							</xsl:if>
							<xsl:if test="not($style='traditional-inline' and ./header/following-sibling::subsection[1]/@display-inline='yes-display-inline') and not (header/text() != '' and header/following-sibling::text !='') and $firstUndesignatyedInBlock='no'">
								<xsl:text> </xsl:text>
							</xsl:if>
						</xsl:if>	  
					</xsl:when>
					<xsl:otherwise>
						<xsl:if test="./enum">
							<xsl:apply-templates select="./enum" mode="go" />
							<xsl:if test="(./header or ./text or ./subsection[1][@display-inline='yes-display-inline'])">
								<xsl:text> </xsl:text>
							</xsl:if>
						</xsl:if>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:if test="@section-type='section-one' and not (local-name(../..)='quoted-block' and local-name(..)='constitution-article' and ../enum)">
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				</xsl:if>	     
				<xsl:apply-templates select="*" mode="process" />					
			</xsl:when>
			<xsl:when test="starts-with($style ,'archaic')">
				<xsl:if test="./header">
					<xsl:choose>
						<xsl:when test="contains(./header, '__')">
								<xsl:element name="para">
									<xsl:call-template name="createFormat" />
								<xsl:attribute name="loc">74</xsl:attribute>
								<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
								<xsl:call-template name="OpeningSectionTemplate">
									<xsl:with-param name="aToPrintLevelLocator">no</xsl:with-param>
									<xsl:with-param name="aLevelLocator" select="$levelLocator" />
								</xsl:call-template>
									<xsl:apply-templates select="./header" mode="AllLower">
									<xsl:with-param name="insertPeriod">
										<xsl:if test="not(descendant::added-phrase) and not(//legis-body[@style='OLC']) and not(ancestor::quoted-block)">Yes</xsl:if>            		
									</xsl:with-param>
								</xsl:apply-templates>
							</xsl:element>
						</xsl:when>
						<xsl:otherwise>
								<para loc="89">
									<xsl:call-template name="createFormat" />
								<xsl:call-template name="OpeningSectionTemplate">
									<xsl:with-param name="aToPrintLevelLocator">no</xsl:with-param>
									<xsl:with-param name="aLevelLocator" select="$levelLocator" />
								</xsl:call-template>
								<xsl:apply-templates select="./header" mode="AllCaps">
									<xsl:with-param name="insertPeriod">
										<xsl:if test="not(descendant::added-phrase) and not(//legis-body[@style='OLC']) and not(ancestor::quoted-block)">Yes</xsl:if>            		
									</xsl:with-param>
								</xsl:apply-templates>
								</para>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:if test="$countHeaderFollowingSiblings &gt; 0">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>
				<xsl:if test="./subsection[1]/header">
					<para loc="74">
						<xsl:call-template name="createFormat" />
						<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						<xsl:call-template name="OpeningSectionTemplate">
							<xsl:with-param name="aToPrintLevelLocator">no</xsl:with-param>
							<xsl:with-param name="aLevelLocator" select="$levelLocator" />
						</xsl:call-template>
						<xsl:apply-templates select="./subsection[1]/header" mode="InitialCaps">
							<xsl:with-param name="insertPeriod">
								<xsl:if test="not(descendant::header/deleted-phrase or descendant::header/added-phrase) and not(//legis-body[@style='OLC']) and not(ancestor::quoted-block)">Yes</xsl:if>      			
							</xsl:with-param>
						</xsl:apply-templates>
						<xsl:if test="not(descendant::header/deleted-phrase or descendant::header/added-phrase) and not(//legis-body[@style='OLC']) and not(ancestor::quoted-block)">
							<xsl:text> </xsl:text>
						</xsl:if>
					</para>
				</xsl:if>
				<xsl:if test="./subsection/paragraph[@display-inline='yes-display-inline']//header and $style='archaic-paragraph' ">		
					<para loc="89">
						<xsl:call-template name="createFormat" />
						<xsl:attribute name="loc">89</xsl:attribute>&gt;
						<xsl:call-template name="OpeningSectionTemplate">
							<xsl:with-param name="aToPrintLevelLocator">no</xsl:with-param>
							<xsl:with-param name="aLevelLocator" select="$levelLocator" />
						</xsl:call-template>
						<xsl:apply-templates select="./subsection/paragraph[@display-inline='yes-display-inline']/header" mode="FirstWord" />
					</para>
				</xsl:if>
				<xsl:if test="not(@display-inline) or @display-inline != 'yes-display-inline'">
					<xsl:if test="./enum or ./text">
						<xsl:value-of select="$levelLocator" />
						<xsl:call-template name="OpeningSectionTemplate">
							<xsl:with-param name="aToPrintLevelLocator">no</xsl:with-param>
							<xsl:with-param name="aLevelLocator" select="$levelLocator" />
						</xsl:call-template>
					</xsl:if>
				</xsl:if>
				<xsl:variable name="sectionOnePhrase" as="item()+">
					<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction><xsl:text>Section </xsl:text>
				</xsl:variable>
				<xsl:variable name="resolvedPhrase" as="item()+">
					<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction><xsl:text>Resolved, </xsl:text>&gt;
				</xsl:variable>
				<xsl:variable name="undesignatedPhrase" as="item()+">
					<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
				</xsl:variable>
				<xsl:variable name="defaultPhrase" as="item()+">
					<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:text>Sec. </xsl:text>
				</xsl:variable>
				<xsl:call-template name="printGeneratedSectionWord">
					<xsl:with-param name="aSectionOnePhrase" select="$sectionOnePhrase" /><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
					<xsl:with-param name="aResolvedPhrase" select="$resolvedPhrase" /><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
					<xsl:with-param name="aUndesignatedPhrase" select="$undesignatedPhrase" /><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
					<xsl:with-param name="aDefaultPhrase" select="$defaultPhrase" /><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
				</xsl:call-template>				    
				<xsl:if test="not(//legis-body[@style='OLC'])">
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
				</xsl:if>
				<xsl:if test="./enum">
					<xsl:apply-templates select="./enum" mode="goTrad" />
					<xsl:if test="(./header or ./text or ./subsection[1][@display-inline='yes-display-inline']) and not(string(./enum)='')">
						<xsl:text> </xsl:text>
					</xsl:if>
					<xsl:if test="./enum and  ./enum/following-sibling::text/@display-inline='yes-display-inline'">
						<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
					</xsl:if>					         
				</xsl:if>
				<xsl:apply-templates mode="process" />
			</xsl:when>					   
			<xsl:when test="$style='constitutional-amendment' or /resolution[@resolution-type]='constitutional-amendment'">
				<xsl:if test="not(@display-inline) or @display-inline != 'yes-display-inline' or ($firstUndesignatyedInBlock='yes' and @display-inline='yes-display-inline' )">
					<xsl:call-template name="OpeningSectionTemplate">
						<xsl:with-param name="aToPrintLevelLocator">yes</xsl:with-param>
						<xsl:with-param name="aLevelLocator" select="$levelLocator" />
					</xsl:call-template>
				</xsl:if>
				<xsl:variable name="sectionOnePhrase" as="item()+">
					<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:text>Section </xsl:text>
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				</xsl:variable>
				<xsl:variable name="resolvedPhrase" as="item()+">
					<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					<xsl:text>Resolved, </xsl:text>
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				</xsl:variable>
				<xsl:variable name="defaultPhrase" as="item()+">
					<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
					<xsl:text>Sec. </xsl:text>
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				</xsl:variable>
				<xsl:call-template name="printGeneratedSectionWord">
					<xsl:with-param name="aSectionOnePhrase" select="$sectionOnePhrase" />
					<xsl:with-param name="aResolvedPhrase" select="$resolvedPhrase" />
					<xsl:with-param name="aUndesignatedPhrase"><xsl:text /></xsl:with-param>
					<xsl:with-param name="aDefaultPhrase" select="$defaultPhrase" />
				</xsl:call-template>					     
				<xsl:if test="./enum">
					<xsl:apply-templates select="./enum" mode="goTrad" />
					<xsl:if test="(./header or ./text) and not(string(./enum)='')">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>
				<xsl:if test="./header">
					<xsl:apply-templates select="./header" mode="AllCaps">
						<xsl:with-param name="insertPeriod">Yes</xsl:with-param>
					</xsl:apply-templates>
					<xsl:if test="$countHeaderFollowingSiblings &gt; 0">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:when test="$style='nuclear'">
				<xsl:if test="not(@display-inline) or @display-inline != 'yes-display-inline' or ($firstUndesignatyedInBlock='yes' and @display-inline='yes-display-inline' )">
					<xsl:call-template name="OpeningSectionTemplate">
						<xsl:with-param name="aToPrintLevelLocator">yes</xsl:with-param>
						<xsl:with-param name="aLevelLocator" select="$levelLocator" />
					</xsl:call-template>
				</xsl:if>				
				<xsl:variable name="resolvedPhrase" as="item()+">
					<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
					<xsl:text>Resolved, </xsl:text>
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				</xsl:variable>
				<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
				<xsl:call-template name="printGeneratedSectionWord">
					<xsl:with-param name="aSectionOnePhrase"><xsl:text>Section </xsl:text></xsl:with-param>
					<xsl:with-param name="aResolvedPhrase" select="$resolvedPhrase" />
					<xsl:with-param name="aUndesignatedPhrase"><xsl:text /></xsl:with-param>
					<xsl:with-param name="aDefaultPhrase"><xsl:text>Sec. </xsl:text></xsl:with-param>
				</xsl:call-template>	
				
				<xsl:if test="./enum">
					<xsl:apply-templates select="./enum" mode="goTrad" />
					<xsl:if test="(./header or ./text) and not(string(./enum)='')">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>
				<xsl:if test="./header">
								
					<xsl:apply-templates select="./header" mode="InitialCaps">
						<xsl:with-param name="insertPeriod">Yes</xsl:with-param>
					</xsl:apply-templates>
					
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
					<xsl:if test="substring(normalize-space(./header/text),string-length(normalize-space(./header/text)) - 1) = '.'">
						<xsl:text>.</xsl:text>
					</xsl:if>
					<xsl:text>—</xsl:text>
					<xsl:if test="$countHeaderFollowingSiblings &gt; 0">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>					
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:when test="$style='OLC'">
				<xsl:call-template name="createGenericSection">
					<xsl:with-param name="firstUndesignatyedInBlock" select="$firstUndesignatyedInBlock" />
					<xsl:with-param name="levelLocator" select="$levelLocator" />
					<xsl:with-param name="countHeaderFollowingSiblings" select="$countHeaderFollowingSiblings" />
				</xsl:call-template>
			</xsl:when>
        	<xsl:otherwise>
				<xsl:if test="./@display-inline='yes-display-inline' and ./@changed and not(./@changed='not-changed') and ./@reported-display-style">
					<xsl:choose>
						<xsl:when test="@reported-display-style='strikethrough'">
							<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction><!--<xsl:text disable-output-escaping="yes">&lt;BEL&gt;G3</xsl:text>--><!-- 08/13/2015 XPP/XSLT 2.0 refactoring -->
						</xsl:when>
					</xsl:choose>
					
				</xsl:if>
				<xsl:if test="not(@display-inline) or @display-inline != 'yes-display-inline' or ($firstUndesignatyedInBlock='yes' and @display-inline='yes-display-inline' ) ">
					<xsl:call-template name="OpeningSectionTemplate">
						<xsl:with-param name="aToPrintLevelLocator">yes</xsl:with-param>
						<xsl:with-param name="aLevelLocator" select="$levelLocator" />
					</xsl:call-template>
				</xsl:if>					
				<xsl:variable name="resolvedPhrase" as="item()*">
					<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction><xsl:text>Resolved, </xsl:text><xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
				</xsl:variable>
				
				<xsl:call-template name="printGeneratedSectionWord">
					<xsl:with-param name="aSectionOnePhrase"><xsl:text>SECTION </xsl:text></xsl:with-param>
					<xsl:with-param name="aResolvedPhrase" select="$resolvedPhrase" />					
					<xsl:with-param name="aUndesignatedPhrase"><xsl:text /></xsl:with-param>
					<xsl:with-param name="aDefaultPhrase"><xsl:text>SEC. </xsl:text></xsl:with-param>
				</xsl:call-template>
				<xsl:if test="enum">
					<xsl:apply-templates select="enum" mode="goTrad" />
					<xsl:if test="(header or text) and not(string(./enum)='')">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>
				<xsl:if test="header">
					<xsl:apply-templates select="header" mode="AllCaps">
						<xsl:with-param name="insertPeriod">Yes</xsl:with-param>
					</xsl:apply-templates>					      	
					<xsl:if test="$countHeaderFollowingSiblings &gt; 0">
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>	
				<!-- TB Bug fixing #1308 -->
				<xsl:if test="@external-xref and @external-xref != '' and (ancestor::ramseyer or ancestor::cordon)">
					
					<para loc="71">
						<xsl:value-of select="@external-xref " />
					</para>
				</xsl:if>
				<xsl:apply-templates select="*" mode="process" />
			</xsl:otherwise>
		</xsl:choose>
		<xsl:value-of select="gpo:addClosingCharacter(.)" /> 	
		
    	<xsl:variable name="toInsertEmptyLine" as="xs:string?">
			<xsl:call-template name="ToInsertendingCorrectionLine">
				<xsl:with-param name="inputLevelLocator" select="$levelLocator/text()" />
			</xsl:call-template>
		</xsl:variable>	
		
		<xsl:if test="$toInsertEmptyLine = 'true'">
			<para format="6602" loc="39" />
		</xsl:if>
        </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createSectionLoc75">
		<xsl:variable name="style" select="@style" as="xs:string" />
		<xsl:variable name="section-type" select="@section-type" as="xs:string" />
		<xsl:variable name="levelLocator" as="item()*">
			<xsl:call-template name="locatorForSection">
				<xsl:with-param name="style" select="$style" />
				<xsl:with-param name="section-type" select="$section-type" />
			</xsl:call-template>
		</xsl:variable>
		
		<xsl:call-template name="KeepParentsFormatOrSelf" />
				<para loc="75">
					<xsl:call-template name="createFormat" />
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<!-- fixes issue #103. replace em space with thin space per Deb's instructions -->
					<xsl:text>§ </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:text> </xsl:text>
					<xsl:value-of select="header" />
					<!-- fixes issue #105 -->
					<!-- <xsl:text>.</xsl:text>-->
					<xsl:call-template name="createSubsectionInline" />
				</para>
				<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createGenericSection">	
		<xsl:param name="firstUndesignatyedInBlock" />
		<xsl:param name="countHeaderFollowingSiblings" />
		<xsl:param name="levelLocator" />
		
			<xsl:variable name="resolvedPhrase" as="item()*">
				<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction><xsl:text>Resolved, </xsl:text><xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:variable>
		<xsl:variable name="output">
			<xsl:choose>
				<xsl:when test="starts-with(@style , 'traditional') or starts-with(@style , 'archaic') or @style='nuclear'">
					<xsl:text>false</xsl:text>		
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>true</xsl:text>	
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="comment">createGenericSection</xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<!--Issue #528 - need to reset format-->
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<para>
			<!--<xsl:call-template name="createFormat"/>-->
		<!--Issue	#373 -->
			<xsl:attribute name="loc">
					<xsl:call-template name="calculateSectionLoc" />
			</xsl:attribute>
			<xsl:call-template name="createFormat" />	
				<xsl:choose>
				<xsl:when test="$billstage='Enrolled-Bill'">
					<!--Issue #314-->
					<xsl:attribute name="format">6501</xsl:attribute></xsl:when>
				<xsl:otherwise />
			</xsl:choose>
		<xsl:if test="./@display-inline='yes-display-inline' and ./@changed and not(./@changed='not-changed') and ./@reported-display-style">
			<xsl:choose>
				<xsl:when test="@reported-display-style='strikethrough'">
					<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
				</xsl:when>
			</xsl:choose>	
		</xsl:if>
			<xsl:if test="ancestor::quoted-block">
				<xsl:text>“</xsl:text>
			</xsl:if>
			<xsl:call-template name="printGeneratedSectionWord">
				<xsl:with-param name="aSectionOnePhrase"><xsl:text>SECTION </xsl:text></xsl:with-param>
				<xsl:with-param name="aResolvedPhrase" select="$resolvedPhrase" />				
				<xsl:with-param name="aUndesignatedPhrase"><xsl:text /></xsl:with-param>
				<xsl:with-param name="aDefaultPhrase"><xsl:text>SEC. </xsl:text></xsl:with-param>
			</xsl:call-template>
		     <xsl:value-of select="enum" />
			<!--Issue #113 - Added space between enum and the header-->
			<xsl:text> </xsl:text>
				<xsl:apply-templates select="header" mode="AllCaps">
					<xsl:with-param name="insertPeriod">Yes</xsl:with-param>
				</xsl:apply-templates>				      	
				<xsl:if test="$countHeaderFollowingSiblings &gt; 0">
					<xsl:text />
				</xsl:if>	
		    <xsl:choose>
		        <xsl:when test="text[@display-inline='yes-display-inline']">
		            <xsl:apply-templates select="text" mode="inline" />
		        </xsl:when>
		        <xsl:otherwise />
		    </xsl:choose>
		</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section/enum" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section/header" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section[@display-inline = 'no-display-inline' or not(@display-inline)][not(@section-type)][not(@style='traditional')]   [not(@style='appropriations')]   [not(child::subsection[@display-inline = 'yes-display-inline'])]" mode="process">
		<xsl:variable name="comment">section-5- <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		
		<!-- fixes issue #226; recursively get the style of current element and ancestors
			and use that (instead of ./@style) in dtermining whether to use word "Sec." or the Sect symbol -->
		<xsl:variable name="node" select="." as="node()" />
		<xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
		<xsl:variable name="style" as="xs:string">
			<xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
		</xsl:variable>
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<xsl:choose>
			<!--Issue #59 - Not enclosed in a <para> and missing <text> contents. -->
			<xsl:when test="not(@display-inline) and not(header)">
				<para loc="20">
					<xsl:call-template name="createFormat" />
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<xsl:processing-instruction name="xpp">fv:3</xsl:processing-instruction>
					<xsl:text>Sec. </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><xsl:text> </xsl:text>
					<xsl:apply-templates select="text" mode="inline" />
					<xsl:if test="ancestor::quoted-block">
						<xsl:call-template name="createClosingBlockPunctuation" />
					</xsl:if>
				</para>
				<xsl:apply-templates select="* except text" mode="process" />
			</xsl:when>
			<xsl:when test="$style='USC' and $billstage='Enrolled-Bill'">
				<para loc="64">	
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<!-- fixes issue #103. replace em space with thin space per Deb's instructions -->
					<xsl:text>§ </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:text> </xsl:text>
					<xsl:apply-templates select="header" mode="inline" />
					<!-- fixes issue #105 -->
					<!-- <xsl:text>.</xsl:text>-->
					<xsl:if test="ancestor::quoted-block">
						<xsl:call-template name="createClosingBlockPunctuation" />
					</xsl:if>
				</para>
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:when test="$style='USC'">
				<para loc="75">
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<!-- fixes issue #103. replace em space with thin space per Deb's instructions -->
					<xsl:text>§ </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:text> </xsl:text>
					<xsl:apply-templates select="header" mode="inline" />
					<!-- fixes issue #105 -->
					<!-- <xsl:text>.</xsl:text>-->
					<xsl:if test="ancestor::quoted-block">
						<xsl:call-template name="createClosingBlockPunctuation" />
					</xsl:if>
				</para>
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:when test="/bill/@bill-stage='Enrolled-Bill' and @style='OLC'">
				<para>
					<xsl:attribute name="loc">
						<xsl:call-template name="calculateSectionLoc" />
					</xsl:attribute>
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<xsl:text>SEC. </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:text> </xsl:text>
					<!--<xsl:value-of select="upper-case(header)"/>-->
					<!-- issue #489 -->
				     <xsl:apply-templates select="header" mode="AllCaps" />
				</para>
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:when test="/bill/@bill-stage='Enrolled-Bill'">
				<para loc="43">
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<xsl:text>SEC. </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:text> </xsl:text>
					<!--<xsl:value-of select="upper-case(header)"/>-->
					<xsl:apply-templates select="header" mode="AllCaps" />
					<xsl:text>.</xsl:text>
					<xsl:if test="ancestor::quoted-block">
						<xsl:call-template name="createClosingBlockPunctuation" />
					</xsl:if>
				</para>
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:when test="$style = 'OLC' or not(@style)">
				<para loc="72">
					<xsl:call-template name="createFormat" />
					<!--Issue #136:  Add beginning processing instruction logic.-->
					<xsl:call-template name="createProcessingInstructions" />
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<xsl:text>SEC. </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:text> </xsl:text>
				<!-- fixes issue #304 -->
					<!-- Use apply-templates instead of value-of since we need to do additional
						processing to the text instead of just getting the text -->
					<xsl:apply-templates select="header" mode="AllCaps">
						<xsl:with-param name="insertPeriod">Yes</xsl:with-param>
					</xsl:apply-templates>
					<!--Issue #529 - removed logic for quoted block end because it is being handled at header/text level.-->
				</para>     
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:otherwise>
				<para loc="72">
					<xsl:call-template name="createFormat" />
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<!-- fixes issue #103. replace em space with thin space per Deb's instructions -->
					<xsl:text>SEC. </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:text> </xsl:text>
					<xsl:value-of select="upper-case(header)" />
					<!-- fixes issue #105 -->
					<!-- fixes issue #234; this fix undoes fix #105. I am not sure
						which one should be applied -->
					<xsl:text>.</xsl:text>
					<xsl:if test="ancestor::quoted-block">
						<xsl:call-template name="createClosingBlockPunctuation" />
					</xsl:if>
				</para>
				<xsl:apply-templates mode="process" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createProcessingInstructions">	
					<xsl:choose>
						<xsl:when test="@reported-display-style='strikethrough' or @vbattChangedForReported='strikethrough' ">
							<xsl:if test="@section-type='undesignated-section'">
							<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
							<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
							</xsl:if>
						</xsl:when>
						<xsl:when test="(contains(./@reported-display-style, 'boldface-italic') or contains(@vbattChangedForReported, 'boldface-italic') )">
							<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
							<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="(contains(./@reported-display-style, 'boldface-roman') or contains(@vbattChangedForReported, 'boldface-roman'))">
							<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
						</xsl:when>	
						<!--Issue #543 - modified descendant to child-->
						<xsl:when test="preceding-sibling::section[1]/child::toc[not(following-sibling::*/enum)          and not(following-sibling::*/header) and not(ancestor::quoted-block) and not(following-sibling::*/text)]">
									<xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
						</xsl:when>
						
						<xsl:otherwise />
					</xsl:choose>	
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section[ancestor::quoted-block][@display-inline='no-display-inline'][@section-type='subsequent-section'][@style='USC'][@commented='no']">
		<xsl:variable name="comment">section-8 <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<para format="6201" loc="75">
			<xsl:text>“§</xsl:text>
			<xsl:value-of select="enum" />
			<xsl:text> </xsl:text>
			<xsl:value-of select="header" />
			<xsl:text>.</xsl:text>
		</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="xxxsection[@section-type = 'section-one']   [@display-inline='no-display-inline']" mode="process">
		<xsl:variable name="comment">section-9 <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<para>
			<xsl:call-template name="createFormat" />
			<xsl:attribute name="loc">
				<xsl:choose>
					<xsl:when test="$billstage='Enrolled-Bill'">46</xsl:when>
					<xsl:otherwise>72</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
			<xsl:if test="ancestor::quoted-block">
				<xsl:text>“</xsl:text>
			</xsl:if>
			SECTION <xsl:value-of select="enum" /><xsl:text> </xsl:text><xsl:value-of select="upper-case(header)" /><xsl:text>.</xsl:text></para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section[not(child::subsection/@display-inline = 'yes-display-inline') or not(child::subsection/text/@display-inline = 'yes-display-inline')][@section-type = 'subsequent-section']   [@display-inline='no-display-inline'][not(@style='appropriations')][@style != 'traditional']" mode="process">
		<xsl:variable name="comment">section-11 <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<xsl:variable name="resolvedPhrase" as="item()*">
			<xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>Resolved, <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
		</xsl:variable>
		
		<para>
			<xsl:call-template name="createFormat" />
			<xsl:attribute name="loc">
				<xsl:call-template name="calculateSectionLoc" />
			</xsl:attribute>
			<!--Issue #290-->
			<xsl:if test="parent::title and position() = last() and not(@style = 'OLC')">
				<xsl:if test="../following-sibling::title">
				<xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
				</xsl:if>
			</xsl:if>
			<xsl:if test="ancestor::quoted-block">
				<xsl:text>“</xsl:text>
			</xsl:if>
			<xsl:call-template name="createSectionWord" />
			<!-- issue #475; there should not be a space between the sect word
				and the enum in this case. There are other spaces where the space
				is needed and that space is added in createSectionWord -->
			<!--<xsl:text> </xsl:text>-->
			<xsl:if test="enum"><xsl:value-of select="enum" /><xsl:text> </xsl:text></xsl:if>
			<xsl:choose>
				<!--Issue #284-->
				<xsl:when test="@style='USC'">
					<xsl:value-of select="header" />
				</xsl:when>
				<xsl:otherwise>
					<!--<xsl:value-of select="upper-case(header)"/>-->
					<xsl:apply-templates select="./header" mode="AllCaps">
						<xsl:with-param name="insertPeriod">Yes</xsl:with-param>
					</xsl:apply-templates>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="text[@display-inline='yes-display-inline']">
				<xsl:apply-templates select="text" mode="inline" />
			</xsl:if>
			<!--Issue #351-->
			<xsl:if test="../after-quoted-block">
				<xsl:choose>
					<xsl:when test="@style='USC'">
						<xsl:call-template name="createClosingBlockPunctuation" />
					</xsl:when>
					<xsl:when test="not(../*/enum) and not(../*/header) and not(../*/text) and not(../*/continuation-text)">
						<xsl:value-of select="../after-quoted-block" />
						<xsl:text>“</xsl:text>
					</xsl:when>
					<xsl:otherwise />
				</xsl:choose>		
			</xsl:if>
		</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section/text[@display-inline='yes-display-inline']" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="calculateSectionLoc">
		<xsl:variable name="style" select="@style" as="xs:string?" />
		<xsl:variable name="output" as="xs:string">
			<xsl:choose>
				<xsl:when test="starts-with(@style , 'traditional') or starts-with(@style , 'archaic') or @style='nuclear'">
					<xsl:text>false</xsl:text>		
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>true</xsl:text>	
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="/bill/@bill-stage='Enrolled-Bill' and string-length(./enum)&gt;1 and $output='true' ">
				<xsl:variable name="enumLength">
					<xsl:sequence select="gpo:calcEnumLength(enum)" />
					<!--<xsl:call-template name="calcEnumLength">
						<xsl:with-param name="aEnumSourceString" select="./enum"></xsl:with-param>
					</xsl:call-template>-->
				</xsl:variable>							
				<xsl:choose>
					<xsl:when test="$style='OLC' or $style='tax' or $style='energy'">4<xsl:value-of select="number($enumLength)" />
					</xsl:when>	
					<xsl:when test="$style='USC'">6<xsl:value-of select="number($enumLength)" />
					</xsl:when>
					<xsl:otherwise>72</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<!--Issue #296-->
			<xsl:when test="upper-case(/bill/@bill-type)='OLC' and @style='USC'">75</xsl:when>
			<xsl:when test="/bill/@bill-stage='Enrolled-Bill' and ancestor::quoted-block  and $output='true'      and @style='OLC'">43</xsl:when>
			<!--Issue #338-->
			<xsl:when test="/bill/@bill-stage='Enrolled-Bill'  and $output='true'and ancestor::quoted-block  and $output='true'      and @style='USC' and $billstage='Enrolled-Bill'">41</xsl:when>
			<xsl:when test="/bill/@bill-stage='Enrolled-Bill' and @section-type='section-one' and @style='OLC'">46</xsl:when>
			<xsl:when test="/bill/@bill-stage='Enrolled-Bill'">46</xsl:when>
			<xsl:when test="/bill/@bill-stage='Enrolled-Bill'  and @section-type='section-one'">20</xsl:when>		
<xsl:otherwise>72</xsl:otherwise>			
		</xsl:choose>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createSectionWord">
		<xsl:choose>
			<xsl:when test="@style='USC'">
				<!--Issue #284-->
				<xsl:text>§ </xsl:text>
			</xsl:when>
			<xsl:when test="ancestor::title or      ancestor::subtitle     or ancestor::part     or ancestor::subpart      or ancestor::chapter     or ancestor::section     or ancestor::subchapter"><xsl:text>SEC. </xsl:text></xsl:when>
			<xsl:when test="@section-type='subsequent-section'">SEC. </xsl:when>
			<xsl:when test="not(preceding-sibling::section)"><xsl:text>SECTION </xsl:text></xsl:when>
			<xsl:otherwise><xsl:text>SEC. </xsl:text></xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="section-section-one">
		<xsl:variable name="comment">section-section-one <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<para>
			<xsl:attribute name="loc">
				<xsl:choose>
					<xsl:when test="$billstage='Enrolled-Bill'">46</xsl:when>
					<xsl:otherwise>72</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
			<xsl:if test="ancestor::amendment-doc">
				<xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
			</xsl:if>
			SECTION <xsl:value-of select="enum" /><xsl:text> </xsl:text><xsl:value-of select="upper-case(header)" /><xsl:text>.</xsl:text></para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section[not(@section-type)]   [not(@display-inline)]   [not(ancestor::quoted-block)]   [@style='OLC' or not(@style)]">
		<xsl:variable name="comment">section-10 <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<para loc="72">
			<xsl:call-template name="createFormat" />
			<xsl:text>SEC. </xsl:text>
			<xsl:value-of select="enum" />
			<xsl:text> </xsl:text>
			<xsl:value-of select="upper-case(header)" />
			<xsl:text>.</xsl:text>
		</para>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="sectionSubsectionDisplayInline">
        <!--<xsl:variable name="levelLocator"><xsl:call-template name="createLevelLocator"/></xsl:variable>
		<xsl:variable name="actualLevelLocator">
			<xsl:choose>
				<xsl:when test="@indent"> 
					<xsl:call-template name="findActualLocator">
						<xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator"/></xsl:with-param>
					</xsl:call-template></xsl:when>
				<xsl:otherwise><xsl:value-of select="$levelLocator"/></xsl:otherwise>
			</xsl:choose>          
		</xsl:variable>-->
        <xsl:variable name="style" select="@style" as="xs:string" />
    	<xsl:variable name="section-type" select="@section-type" as="xs:string" />
        <xsl:variable name="levelLocator" as="item()*">
            <xsl:call-template name="locatorForSection">
                <xsl:with-param name="style" select="$style" />
                <xsl:with-param name="section-type" select="$section-type" />
            </xsl:call-template>
        </xsl:variable>
    	<xsl:variable name="comment">section 6- <xsl:value-of select="@id" /></xsl:variable>
    	<xsl:sequence select="gpo:outputComment($comment)" />
        
        <xsl:call-template name="KeepParentsFormatOrSelf" />
    	<xsl:choose>
    		<xsl:when test="@style = 'OLC'">
    			<para>
    				<xsl:attribute name="loc"><xsl:value-of select="$levelLocator" /></xsl:attribute>
    				<xsl:if test="ancestor::quoted-block">
    					<xsl:text>“</xsl:text>
    				</xsl:if>
    				<!-- fixes issue #95 The space after Sec. should be a thin space according to Deb -->
    				<!-- according to Martin this should be a regular space. see issue #173 -->
    				<xsl:call-template name="printGeneratedSectionWord">
    					<xsl:with-param name="aSectionOnePhrase"><xsl:text>SECTION </xsl:text></xsl:with-param>				
    					<xsl:with-param name="aUndesignatedPhrase"><xsl:text /></xsl:with-param>
    					<xsl:with-param name="aDefaultPhrase"><xsl:text>SEC. </xsl:text></xsl:with-param>
    				</xsl:call-template>
    				<!--<xsl:choose>
    					<xsl:when test="not(preceding-sibling::section)"><xsl:text>SECTION </xsl:text></xsl:when>
    					<xsl:otherwise><xsl:text>SEC. </xsl:text></xsl:otherwise>
    				</xsl:choose>-->
    				<xsl:value-of select="enum" />
    				<xsl:text> </xsl:text>
    				<xsl:value-of select="upper-case(header)" />
    				<xsl:text>.</xsl:text>
    				<xsl:call-template name="createSubsectionInline" />
    			</para>     
    			<xsl:apply-templates mode="process" />
    		</xsl:when>
    		<xsl:otherwise>
    			<para loc="75">
    				<xsl:if test="ancestor::quoted-block">
    					<xsl:text>“</xsl:text>
    				</xsl:if>
    				<!-- fixes issue #103. replace em space with thin space per Deb's instructions -->
    				<xsl:text>§ </xsl:text>
    				<xsl:value-of select="enum" />
    				<xsl:text> </xsl:text>
    				<xsl:value-of select="header" />
    				<!-- fixes issue #105 -->
    				<!-- <xsl:text>.</xsl:text>-->
    				<xsl:call-template name="createSubsectionInline" />
    			</para>
    			<xsl:apply-templates mode="process" />
    		</xsl:otherwise>
    	</xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="sectionParagraphDisplayInline">
		<!--<xsl:variable name="levelLocator"><xsl:call-template name="createLevelLocator"/></xsl:variable>
		<xsl:variable name="actualLevelLocator">
			<xsl:choose>
				<xsl:when test="@indent"> 
					<xsl:call-template name="findActualLocator">
						<xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator"/></xsl:with-param>
					</xsl:call-template></xsl:when>
				<xsl:otherwise><xsl:value-of select="$levelLocator"/></xsl:otherwise>
			</xsl:choose>          
		</xsl:variable>-->
		<xsl:variable name="style" select="@style" as="xs:string" />
		<xsl:variable name="section-type" select="@section-type" as="xs:string" />
		<xsl:variable name="levelLocator" as="item()*">
			<xsl:call-template name="locatorForSection">
				<xsl:with-param name="style" select="$style" />
				<xsl:with-param name="section-type" select="$section-type" />
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="comment">section 4- <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<xsl:call-template name="KeepParentsFormatOrSelf" />
		<xsl:choose>
			<xsl:when test="@style = 'OLC'">
				<para>
					<xsl:attribute name="loc">
						<xsl:choose>
						<xsl:when test="$billstage = 'Enrolled-Bill'">43</xsl:when>
						<xsl:otherwise>72</xsl:otherwise>
						</xsl:choose>
					</xsl:attribute>
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<!-- the space after SEC. matches upConversion -->
					<xsl:text>SEC. </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:text> </xsl:text>
					<xsl:value-of select="upper-case(header)" />
					<xsl:text>.</xsl:text>
					<xsl:call-template name="createSubsectionInline" />
				</para>     
				<xsl:apply-templates mode="process" />
			</xsl:when>
			<xsl:otherwise>
				<para loc="75">
					<xsl:if test="ancestor::quoted-block">
						<xsl:text>“</xsl:text>
					</xsl:if>
					<!-- fixes issue #103. replace em space with thin space per Deb's instructions -->
					<xsl:text>§ </xsl:text>
					<xsl:value-of select="enum" />
					<xsl:text> </xsl:text>
					<xsl:value-of select="header" />
					<!-- fixes issue #105 -->
					<!-- <xsl:text>.</xsl:text>-->
					<xsl:call-template name="createSubsectionInline" />
				</para>
				<xsl:apply-templates mode="process" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section[child::subsection/@display-inline = 'yes-display-inline' or not(@display-inline) or child::subsection/text/@display-inline = 'yes-display-inline']         [@style = 'traditional']" mode="process">
        <xsl:variable name="levelLocator" as="xs:string"><xsl:call-template name="createLevelLocator" /></xsl:variable>
        <xsl:variable name="actualLevelLocator" as="xs:string">
            <xsl:choose>
                <xsl:when test="@indent"> 
                    <xsl:call-template name="findActualLocator">
                        <xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator" /></xsl:with-param>
                    </xsl:call-template></xsl:when>
                <xsl:otherwise><xsl:value-of select="$levelLocator" /></xsl:otherwise>
            </xsl:choose>          
        </xsl:variable>
        <xsl:variable name="comment">section[child::subsection/@display-inline = 'yes-display-inline'] style traditional2 - <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <xsl:call-template name="KeepParentsFormatOrSelf" />
    	<xsl:if test="subsection[@display-inline='yes-display-inline']">
    			<para loc="89">
    				<xsl:if test="ancestor::quoted-block">
    					<xsl:text>“</xsl:text>
    				</xsl:if> 
    				<xsl:apply-templates select="header" mode="AllLower" />
    				<xsl:text> </xsl:text>
    			</para>
    	</xsl:if>
    			<para loc="20">
    				
    				<xsl:text>  </xsl:text>
    				<xsl:if test="ancestor::quoted-block">
    					<xsl:text>“</xsl:text>
    				</xsl:if>
    				<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
    				<xsl:text>Sec. </xsl:text>
    				<xsl:call-template name="parseEnum">
    					<xsl:with-param name="enum" select="enum" />
    				</xsl:call-template>
    				<!--<xsl:value-of select="enum"/>-->
    				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><xsl:text> </xsl:text>
    				<xsl:apply-templates select="text" mode="inline" />
    				<xsl:if test="subsection[@display-inline='yes-display-inline']">
    				<xsl:call-template name="createSubsectionInline" />
    				</xsl:if>
    			</para>
    	
        <xsl:apply-templates select="* except text" mode="process" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="text[@style='traditional' and parent::section]" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="parseEnum">
		<xsl:param name="enum" />
		<xsl:analyze-string select="$enum" regex="([0-9]*)([A-Z])(.)">
			<xsl:matching-substring>
				<xsl:value-of select="regex-group(1)" />
				<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
				<xsl:value-of select="regex-group(2)" /><xsl:value-of select="regex-group(3)" /><xsl:text> </xsl:text>
			</xsl:matching-substring>
			<xsl:non-matching-substring>
				<xsl:value-of select="$enum" />
			</xsl:non-matching-substring>
		</xsl:analyze-string>
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section[@style='appropriations'][not(enum) and not(header)]" mode="process">
		<xsl:comment>Section no enum/header <xsl:value-of select="@id" /></xsl:comment>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="section[@style='appropriations'][child::enum]" mode="process">
		<xsl:variable name="comment">Appropriations section <xsl:value-of select="@id" /></xsl:variable>
		<xsl:sequence select="gpo:outputComment($comment)" />
		<para loc="20">
			<xsl:text>  </xsl:text>
			<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>Sec. <xsl:value-of select="enum" />
			<xsl:if test="not(subsection[@display-inline='yes-display-inline'])">
			<xsl:text> </xsl:text>
			</xsl:if>
			<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			<xsl:if test="not(subsection[@inline-display = 'yes-display-inline'])">
			<xsl:text> </xsl:text>
			</xsl:if>
			<xsl:if test="header">
				<xsl:apply-templates select="header" mode="process" />
			</xsl:if>
			<xsl:choose>
			<xsl:when test="subsection[@display-inline='yes-display-inline']">
				<xsl:call-template name="createSubsectionInline" />
			</xsl:when>
			<xsl:otherwise><xsl:apply-templates select="text" mode="inline" /></xsl:otherwise>
			</xsl:choose>
		</para>
		<xsl:apply-templates select="* except (enum | header | text)" mode="process" />
	</xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph/text" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph/enum" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph/header" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph" mode="process">
        <xsl:variable name="levelLocator">
            <xsl:call-template name="findActualLocator">
                <xsl:with-param name="levelLocator">24</xsl:with-param>						
            </xsl:call-template>
        </xsl:variable>
      <!--  <xsl:variable name="actualLevelLocator" as="item()*">
            <xsl:choose>
                <xsl:when test="@indent"> 
                  <xsl:call-template name="findActualLocator">
                    <xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator"/></xsl:with-param>
                  </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$levelLocator"/>
                </xsl:otherwise>
            </xsl:choose>          
        </xsl:variable>-->
        <xsl:variable name="comment">subparagraph 1 <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <xsl:choose>
            <xsl:when test="@display-inline = 'yes-display-inline'" />
            <xsl:when test="@display-inline= 'no-display-inline' and text/@display-inline= 'no-display-inline'">
                <xsl:call-template name="KeepParentsFormatOrSelf" />
                <para>
                    <xsl:call-template name="createFormat" />
                    <xsl:attribute name="loc" select="$levelLocator" />
                    <xsl:call-template name="createQPIforSubparagraph" />
                    <xsl:text>  </xsl:text>
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                    <xsl:call-template name="createSubparagraphEnum" />
                  <xsl:call-template name="createSubparagraphHeader" />
                    <!-- not needed; ending block quote will be generated from child text element -->
                    <!--
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:call-template name="calculateQuotedBlockEnd"/>
                    </xsl:if>-->
                </para>
                <xsl:apply-templates select="text" mode="process" />
            </xsl:when>
            <xsl:when test="@display-inline= 'no-display-inline' and text/@display-inline= 'yes-display-inline'">
                <xsl:call-template name="KeepParentsFormatOrSelf" />
                <para>
                    <xsl:call-template name="createFormat" />
                    <xsl:attribute name="loc" select="$levelLocator" />
                    <xsl:call-template name="createQPIforSubparagraph" />
                    <xsl:text>  </xsl:text>
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                    <xsl:call-template name="createSubparagraphEnum" />
                    <xsl:text> </xsl:text>
                    <xsl:call-template name="createSubparagraphHeader" />
                    <xsl:apply-templates select="text" mode="inline" />
                    <xsl:if test="clause[@display-inline = 'yes-display-inline']">
                        <xsl:call-template name="createClauseInline" />
                    </xsl:if>
                   <!-- not needed; ending block quote will be generated from child text element -->
                    <!--
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:call-template name="calculateQuotedBlockEnd"/>
                    </xsl:if>-->
                </para> 
            </xsl:when>  
            <xsl:otherwise>
                <xsl:call-template name="KeepParentsFormatOrSelf" />
                <para>
                    <xsl:call-template name="createFormat" />
                    <xsl:attribute name="loc" select="$levelLocator" />
                    <xsl:call-template name="createQPIforSubparagraph" />
                    <xsl:text>  </xsl:text>
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                   <xsl:call-template name="createSubparagraphEnum" />
                    <xsl:text> </xsl:text>
                    <xsl:call-template name="createSubparagraphHeader" />
                    <xsl:apply-templates select="text" mode="inline" />
                    <xsl:if test="clause[@display-inline = 'yes-display-inline']">
                        <xsl:call-template name="createClauseInline" />
                    </xsl:if>
                    <!-- not needed; ending block quote will be generated from child text element -->
                    <!--
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:call-template name="calculateQuotedBlockEnd"/>
                    </xsl:if>-->
                </para>
            </xsl:otherwise>
        </xsl:choose>
    <!--    <xsl:apply-templates select="clause[@display-inline='yes-display-inline']/descendant::*[@display-inline='no-display-inline' or not(@display-inline)]" mode="process"/>
  -->      <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createSubparagraphEnum">
        <xsl:choose>
            <xsl:when test="enum/child::added-phrase">
                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                <xsl:value-of select="enum" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:when>
            <xsl:otherwise><xsl:value-of select="enum" />
               <!-- <xsl:text> </xsl:text>--></xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createSubparagraphHeader">
        <xsl:if test="header">
            <xsl:choose>
                <xsl:when test="header/enum-in-header">
                    <xsl:apply-templates select="header" mode="enum-in-header" />
                </xsl:when>
                <xsl:otherwise><xsl:call-template name="createHeader" /></xsl:otherwise>
            </xsl:choose>
<!--            <xsl:text> </xsl:text>-->
        </xsl:if>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="header" mode="enum-in-header">
        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
        <xsl:apply-templates mode="process" />
        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
        <xsl:if test="following-sibling::text">
        <xsl:text>.—</xsl:text>
        </xsl:if>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph/header/text()[1]">
        <xsl:variable name="string-length" select="string-length(.)" as="xs:integer" />
        <xsl:value-of select="substring(., 1, 1)" /><xsl:value-of select="substring(., 2, $string-length)" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createQPIforSubparagraph">
        <xsl:choose>
            <!--Issue #540-->
            <xsl:when test="preceding-sibling::subparagraph[1]/descendant::toc[not(following-sibling::*/enum)                 and not(following-sibling::*/header) and not(ancestor::quoted-block) and not(following-sibling::*/text)]">
                <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
            </xsl:when>
           <!-- <xsl:when test="@indent='up1' and @changed='added'">
                <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
            </xsl:when>-->
            <xsl:otherwise />
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph[@display-inline='yes-display-inline']" mode="process">
        <xsl:apply-templates select="clause[not(@display-inline) or @display-inline='no-display-inline'] " mode="process" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph[@display-inline='yes-display-inline']/enum" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph[@display-inline='yes-display-inline']/header" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph[@display-inline='yes-display-inline']/text" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph[not(@display-inline) or @display-inline='no-display-inline']" mode="inline">
        <xsl:variable name="levelLocator" as="xs:string">24</xsl:variable>
        <xsl:variable name="actualLevelLocator" as="xs:string"> 
            <xsl:choose>
                <xsl:when test="@indent"> 
                    <xsl:call-template name="findActualLocator">
                        <xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator" /></xsl:with-param>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$levelLocator" />
                </xsl:otherwise>
            </xsl:choose>          
        </xsl:variable>
        <xsl:variable name="comment">subparagraph 2 <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <xsl:choose>
            <xsl:when test="ancestor::quoted-block">
                <xsl:variable name="qb-id" as="xs:string"><xsl:value-of select="ancestor::quoted-block/@id" /></xsl:variable>
                <xsl:variable name="textCount" as="xs:integer"><xsl:value-of select="count(ancestor::quoted-block/descendant::text)" /></xsl:variable>
                <xsl:variable name="currentCount" as="xs:double"><xsl:value-of select="count(preceding::text[ancestor::quoted-block/@id = $qb-id]) + 1" /></xsl:variable>
                <xsl:call-template name="createQuotedBlock">
                    <xsl:with-param name="qb-id"><xsl:value-of select="$qb-id" /></xsl:with-param>
                    <xsl:with-param name="textCount"><xsl:value-of select="$textCount" /></xsl:with-param>
                    <xsl:with-param name="currentCount"><xsl:value-of select="$currentCount" /></xsl:with-param>
                    <xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator" /></xsl:with-param>
                    <xsl:with-param name="actualLevelLocator"><xsl:value-of select="$actualLevelLocator" /></xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
      
                <xsl:choose>
                    <xsl:when test="@display-inline= 'no-display-inline' and text/@display-inline= 'no-display-inline'">
                        <para>
                            <xsl:call-template name="createFormat" />
                            <xsl:attribute name="loc" select="$actualLevelLocator" />
                            <xsl:call-template name="createQPIforSubparagraph" />
                            <xsl:text>  </xsl:text>
                            <xsl:call-template name="createSubparagraphEnum" />
                            <xsl:text> </xsl:text>
                            <xsl:if test="header">
                                <xsl:call-template name="createHeader" />
                                <xsl:text> </xsl:text>
                            </xsl:if>
                            <xsl:apply-templates select="text" mode="inline" />
                        </para>
                    </xsl:when>
                    <xsl:when test="@display-inline= 'no-display-inline' and text/@display-inline= 'yes-display-inline'">
                        <para>
                            <xsl:call-template name="createFormat" />
                            <xsl:attribute name="loc" select="$actualLevelLocator" />
                            <xsl:call-template name="createQPIforSubparagraph" />
                            <xsl:text>  </xsl:text>
                            <xsl:call-template name="createSubparagraphEnum" />
                            <xsl:text> </xsl:text>
                            <xsl:if test="header">
                                <xsl:call-template name="createHeader" />
                                <xsl:text> </xsl:text>
                            </xsl:if>
                            <xsl:apply-templates select="text" mode="inline" />
                        </para>
                        <xsl:apply-templates mode="process" />     
                    </xsl:when>
                    <xsl:otherwise>
                        <para>
                            <xsl:call-template name="createFormat" />
                            <xsl:attribute name="loc" select="$actualLevelLocator" />
                            <xsl:call-template name="createQPIforSubparagraph" />
                            <xsl:text>  </xsl:text>
                            <xsl:call-template name="createSubparagraphEnum" />
                            <xsl:text> </xsl:text>
                            <xsl:if test="header">
                                <xsl:call-template name="createHeader" />
                                <xsl:text> </xsl:text>
                            </xsl:if>
                            <xsl:apply-templates select="text" mode="inline" />
                        </para>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subparagraph[not(@display-inline='yes-display-inline')][not(@style='other')][child::clause/@display-inline = 'yes-display-inline']" mode="process">
        <xsl:variable name="levelLocator" as="xs:string"><xsl:call-template name="createLevelLocator" /></xsl:variable>
        <xsl:variable name="actualLevelLocator" as="xs:string">
            <xsl:choose>
                <xsl:when test="@indent"> 
                    <xsl:call-template name="findActualLocator">
                        <xsl:with-param name="levelLocator"><xsl:value-of select="$levelLocator" /></xsl:with-param>
                    </xsl:call-template></xsl:when>
                <xsl:otherwise><xsl:value-of select="$levelLocator" /></xsl:otherwise>
            </xsl:choose>          
        </xsl:variable>
        <xsl:variable name="comment">subparagraph 3 <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <para loc="{$actualLevelLocator}">
            <xsl:call-template name="createFormat" />
            <xsl:call-template name="createQPIforSubparagraph" />
            <xsl:text>  </xsl:text>
            <xsl:if test="ancestor::quoted-block">
                <xsl:text>“</xsl:text>
            </xsl:if>
            <xsl:call-template name="createSubparagraphEnum" />
            <!-- partial fix for issue #225; add the space ONLY if there is a header;
                Otherwise, we end up with an extra space between the <enum> of the <subparagraph>
                and the <enum> of a child <clause> -->
            <xsl:if test="header">
                <xsl:text> </xsl:text>
                <xsl:call-template name="createHeader" />
            </xsl:if>
            <xsl:call-template name="createClauseInline" />
            <xsl:value-of select="gpo:addClosingCharacter(.)" /> 
        </para>
        <!--We need to take care of clauses in the Subparagraph-->
        <!--Issue #347 - standalone items were not being taken care of the clause/subclause ore both inline.-->
         <xsl:apply-templates select="clause[@display-inline='yes-display-inline']/subclause[@display-inline='yes-display-inline']/item[@display-inline='no-display-inline' or not(@display-inline)]" mode="process" />
        <!--Issue #545 - take care of clause/subclause/item-->
        <xsl:apply-templates select="clause[@display-inline='yes-display-inline']/child::*[@display-inline='no-display-inline' or not(@display-inline)]" mode="process" />
        <xsl:apply-templates select="clause[not(@display-inline) or @display-inline='no-display-inline']" mode="process" />
        
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subsection/text" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subsection/enum" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subsection/header" mode="process" /><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subsection[@display-inline='no-display-inline' or not(@display-inline)][not(@other-style = 'archaic')]" mode="process">  
        <xsl:variable name="levelLocator">
            <xsl:call-template name="calculateLocator">
                <xsl:with-param name="level" select="local-name(.)" />
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="actualLevelLocator">
            <xsl:choose>
                <xsl:when test="@indent"> 
                    <!--BH:  I limited the levelLocator variable to 2 characters because it was returning 20?? from the 'calculateLocator' function.-->
                    <xsl:call-template name="findActualLocator">
                        <xsl:with-param name="levelLocator"><xsl:value-of select="substring($levelLocator, 1, 2)" /></xsl:with-param>
                    </xsl:call-template></xsl:when>
                <xsl:otherwise><xsl:value-of select="$levelLocator" /></xsl:otherwise>
            </xsl:choose>          
        </xsl:variable>
        <xsl:variable name="comment">subsection1 - <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:choose>
            <xsl:when test="child::paragraph/@display-inline = 'yes-display-inline' and child::paragraph/text/@display-inline = 'yes-display-inline'">
                <para loc="{$actualLevelLocator}">
                    <xsl:text>  </xsl:text>
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                    <xsl:value-of select="enum" />
                    <!-- fixes issue #384 -->
                    <xsl:text />
                    <xsl:if test="header">
                        <xsl:text> </xsl:text>
                        <xsl:call-template name="createHeader" />
                    </xsl:if>
                    <xsl:call-template name="createParagraphInline" />
                </para>
                <!--Issue #388-->
                <xsl:apply-templates mode="process" /> 
            </xsl:when>
            <xsl:when test="child::text[@display-inline = 'yes-display-inline'] and child::quoted-block[@display-inline = 'yes-display-inline']">
                <para loc="{$actualLevelLocator}">
                    <xsl:text>  </xsl:text>
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                    <xsl:value-of select="enum" />
                    <!-- fixes issue #384 -->
                    <xsl:text />
                    <xsl:if test="header">
                        <xsl:text> </xsl:text>
                        <xsl:call-template name="createHeader" />
                    </xsl:if>
                    <xsl:apply-templates select="text" mode="inline" />
                    <xsl:call-template name="createSubsectionInlineQuotedBlock" />
                </para>
                <!--Issue #388-->
                <xsl:apply-templates mode="process" /> 
            </xsl:when>
            <xsl:when test="child::paragraph/@display-inline = 'no-display-inline'                  and child::paragraph/text/@display-inline = 'no-display-inline'">
                <xsl:call-template name="KeepParentsFormatOrSelf" />
                <para loc="{$actualLevelLocator}">
                    <xsl:text>  </xsl:text>
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:text>“</xsl:text></xsl:if><xsl:value-of select="enum" />
                    <xsl:text> </xsl:text>
                    <xsl:if test="header">
                        <xsl:call-template name="createHeader" />
                        <xsl:text> </xsl:text>
                    </xsl:if>
                    <xsl:apply-templates select="text" mode="inline" />
                </para>
                <xsl:apply-templates mode="process" />
            </xsl:when>
            <xsl:when test="@display-inline='no-display-inline' or not(@display-inline)">
                <xsl:call-template name="createSubsection-no-display-inline">
                    <xsl:with-param name="actualLevelLocator"><xsl:value-of select="$actualLevelLocator" /></xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <para loc="{$actualLevelLocator}">
                    <xsl:text>  </xsl:text>
                    <xsl:if test="ancestor::quoted-block">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                    <xsl:value-of select="enum" />
                    <xsl:text> </xsl:text>
                    <xsl:if test="header">
                        <xsl:call-template name="createHeader" />
                        <xsl:text> </xsl:text>
                    </xsl:if>
                    <xsl:apply-templates select="text" mode="inline" />
                </para>
                <xsl:apply-templates mode="process" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createSubsectionInlineQuotedBlock">
        <xsl:text>“</xsl:text>
        <xsl:choose>
            <xsl:when test="quoted-block/child::subsection">
                <xsl:value-of select="quoted-block/*/enum" />
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                <xsl:apply-templates select="quoted-block/subsection/header" mode="InitialCaps" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:text>.—</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="quoted-block/*/enum" />
                <xsl:apply-templates select="quoted-block/*/header" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="createSubsection-no-display-inline">
        <xsl:param name="actualLevelLocator" />
        <xsl:variable name="header">
            <xsl:call-template name="FirstWordCapitalize">
                <xsl:with-param name="header">
                    <xsl:value-of select="header" />
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="levelLocator">
            <xsl:call-template name="calculateLocator">
                <xsl:with-param name="level" select="local-name(.)" />
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="comment">createSubsection-no-display-inline <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <para loc="{translate($levelLocator, '  ', '')}">
            
            <!--Issue #374-->
            <xsl:choose>
                <xsl:when test="preceding-sibling::subsection[1]/descendant::toc[not(following-sibling::*/enum)                     and not(following-sibling::*/header) and not(ancestor::quoted-block) and not(following-sibling::*/text)]">
                    <xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="$billstage='Reported-in-House'" />
                <xsl:when test="$billstage='Referred-in-Senate'" />
                <xsl:when test="$billstage = 'Reference-Change-Senate'" />
                <xsl:when test="$billstage = 'Received-in-Senate'" />
                <xsl:when test="$billstage = 'Received-in-Senate'" />
                <xsl:when test="$billstage = 'Introduced-in-House'" />
                <xsl:when test="$billstage = 'Engrossed-in-Senate'" />
                <xsl:when test="$billstage = 'Engrossed-in-House'" />
                <xsl:when test="$billstage = 'Placed-on-Calendar-Senate'" />
                <xsl:when test="$billstage = 'Enrolled-Bill'" />
                <xsl:when test="$billstage = 'Introduced-in-Senate'" />
                <xsl:when test="$billstage = 'Reported-in-Senate'" />
                <xsl:when test="$billstage = 'Placed-on-Calendar-Senate'" />
                <xsl:when test="position() = last() and child::paragraph and @style='OLC'">
                    <xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
                </xsl:when>
                
                <xsl:otherwise />
            </xsl:choose>
            <xsl:text>  </xsl:text>
            <xsl:if test="ancestor::quoted-block">
                <xsl:text>“</xsl:text>
            </xsl:if>
            
            <xsl:value-of select="enum" />
            
            <!-- fixes issue #334 -->
            <!-- add a space after enum if there is a header or text element and the enum id not empty -->
            <xsl:if test="(header or text) and not(string(enum)='')">
                <xsl:text> </xsl:text>
            </xsl:if>
            
            <xsl:if test="header">
                <xsl:variable name="fullHeader"><xsl:apply-templates select="header" mode="InitialCaps" /></xsl:variable>
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                <xsl:if test="starts-with(header, ' ')">
                    <xsl:text> </xsl:text>
                </xsl:if>
                <xsl:for-each select="$fullHeader/node()">
                    <xsl:choose>
                        <xsl:when test="self::text()">
                            <xsl:variable name="string">
                                <xsl:choose>
                                    <xsl:when test="preceding-sibling::processing-instruction()[1] = 'fv;1'"><xsl:value-of select="." /></xsl:when>
                                    <xsl:otherwise><xsl:sequence select="gpo:capitalize(.)" /></xsl:otherwise>
                                </xsl:choose>
                            </xsl:variable>
                            <xsl:analyze-string select="$string" regex="(’|')">
                                <xsl:matching-substring>
                                    <xsl:value-of select="regex-group(1)" />
                                    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                                    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                </xsl:matching-substring>
                                <xsl:non-matching-substring>
                                    <xsl:value-of select="normalize-space(.)" />
                                </xsl:non-matching-substring>
                            </xsl:analyze-string>
                        </xsl:when>
                        <!--<xsl:when test="self::text() and contains(., '&#x2019;')">
                            <xsl:value-of select="substring-before(., '&#x2019;')"/>
                            <xsl:text>&#x2019;</xsl:text>
                            <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                            <xsl:value-of select="substring-after(., '&#x2019;')"/>
                        </xsl:when>
                        <xsl:when test="self::text()">
                            <xsl:value-of select="normalize-space(.)"/>
                        </xsl:when>-->
                        <xsl:otherwise>
                            <xsl:copy-of select="." />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:text>.—</xsl:text>
            </xsl:if>
            <xsl:if test="text">
                <xsl:apply-templates select="text" mode="inline" /> 
            </xsl:if>
            
            <!--Issue #182:  Inline paragraphs weren't being processed.-->
            <xsl:if test="paragraph[1][@display-inline='yes-display-inline']">
                <xsl:apply-templates select="paragraph[1]" mode="inline" />
            </xsl:if>
            <xsl:if test="ancestor::quoted-block">
                <xsl:call-template name="createClosingBlockPunctuation" />
            </xsl:if>
        </para>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" name="xxxcreateSubsection-no-display-inline">
        <xsl:param name="actualLevelLocator" />
        <xsl:variable name="header">
            <xsl:call-template name="FirstWordCapitalize">
                <xsl:with-param name="header">
                    <xsl:value-of select="header" />
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="levelLocator">
            <xsl:call-template name="calculateLocator">
                <xsl:with-param name="level" select="local-name(.)" />
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="comment">createSubsection-no-display-inline <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <para loc="{translate($levelLocator, '  ', '')}">
            
            <!--Issue #374-->
            <xsl:choose>
                <xsl:when test="preceding-sibling::subsection[1]/descendant::toc[not(following-sibling::*/enum)                     and not(following-sibling::*/header) and not(following-sibling::*/text)]">
                    <xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="$billstage='Reported-in-House'" />
                <xsl:when test="$billstage='Referred-in-Senate'" />
                <xsl:when test="$billstage = 'Reference-Change-Senate'" />
                <xsl:when test="$billstage = 'Received-in-Senate'" />
                <xsl:when test="$billstage = 'Received-in-Senate'" />
                <xsl:when test="$billstage = 'Introduced-in-House'" />
                <xsl:when test="$billstage = 'Engrossed-in-Senate'" />
                <xsl:when test="$billstage = 'Engrossed-in-House'" />
                <xsl:when test="$billstage = 'Placed-on-Calendar-Senate'" />
                <xsl:when test="$billstage = 'Enrolled-Bill'" />
                <xsl:when test="$billstage = 'Introduced-in-Senate'" />
                <xsl:when test="$billstage = 'Reported-in-Senate'" />
                <xsl:when test="$billstage = 'Placed-on-Calendar-Senate'" />
                <xsl:when test="position() = last() and child::paragraph and @style='OLC'">
                    <xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
                </xsl:when>
                
                <xsl:otherwise />
            </xsl:choose>
            <xsl:text>  </xsl:text>
            <xsl:if test="ancestor::quoted-block">
                <xsl:text>“</xsl:text>
            </xsl:if>
            
            <xsl:value-of select="enum" />
            
            <!-- fixes issue #334 -->
            <!-- add a space after enum if there is a header or text element and the enum id not empty -->
            <xsl:if test="(header or text) and not(string(enum)='')">
                <xsl:text> </xsl:text>
            </xsl:if>
            
            <xsl:if test="header">
                <xsl:variable name="fullHeader"><xsl:apply-templates select="header" mode="InitialCaps" /></xsl:variable>
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                <xsl:if test="starts-with(header, ' ')">
                    <xsl:text> </xsl:text>
                </xsl:if>
                <xsl:for-each select="$fullHeader/node()">
                    <xsl:choose>
                        <xsl:when test="self::text()">
                            <xsl:variable name="string">
                                <xsl:choose>
                                    <xsl:when test="preceding-sibling::processing-instruction()[1] = 'fv;1'"><xsl:value-of select="." /></xsl:when>
                                    <xsl:otherwise>
                                        <xsl:sequence select="gpo:capitalize(.)" />
                                      <!--  <xsl:for-each select="tokenize(., '\s+')">
                                            <xsl:choose>
            
                                                <xsl:when test=".='and' or .='for' or .='on' or .='a' or .='an' or .='as' or .='at' or .='but' or .='by' 
                                                    or .='in' or .='nor' or .='of' or .='or' or .='to' or .='the' or .='etc'">
                                                    <xsl:value-of select="."/><xsl:text> </xsl:text>
                                                </xsl:when> 
                                                <xsl:when test=".='and' or .='for,' or .='on,' or .='a,' or .='an,' or .='as,' or .='at,' or .='but,' or .='by,' 
                                                    or .='in,' or .='nor,' or .='of,' or .='or,' or .='to,' or .='the,' or .='etc.' or .='etc,'">
                                                    <xsl:value-of select="."/><xsl:text> </xsl:text>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                    <xsl:sequence select="gpo:capitalize(.)"/>
                                                    <xsl:if test="not(position() = last())"><xsl:text> </xsl:text></xsl:if>
                                                </xsl:otherwise>
                                            </xsl:choose>
                                       
                                        </xsl:for-each>--></xsl:otherwise>
               
                                </xsl:choose>
                            </xsl:variable>
                            <xsl:analyze-string select="$string" regex="(’|')">
                                <xsl:matching-substring>
                                    <xsl:value-of select="regex-group(1)" />
                                    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                                    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                </xsl:matching-substring>
                                <xsl:non-matching-substring>
                                    <xsl:value-of select="normalize-space(.)" />
                                </xsl:non-matching-substring>
                            </xsl:analyze-string>
                        </xsl:when>
                        <!--<xsl:when test="self::text() and contains(., '&#x2019;')">
                            <xsl:value-of select="substring-before(., '&#x2019;')"/>
                            <xsl:text>&#x2019;</xsl:text>
                            <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                            <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                            <xsl:value-of select="substring-after(., '&#x2019;')"/>
                        </xsl:when>
                        <xsl:when test="self::text()">
                            <xsl:value-of select="normalize-space(.)"/>
                        </xsl:when>-->
                        <xsl:otherwise>
                            <xsl:copy-of select="." />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:text>.—</xsl:text>
            </xsl:if>
            <xsl:if test="text">
                <xsl:apply-templates select="text" mode="inline" /> 
            </xsl:if>
            
            <!--Issue #182:  Inline paragraphs weren't being processed.-->
            <xsl:if test="paragraph[1][@display-inline='yes-display-inline']">
                <xsl:apply-templates select="paragraph[1]" mode="inline" />
            </xsl:if>
            <xsl:if test="ancestor::quoted-block">
                <xsl:call-template name="createClosingBlockPunctuation" />
            </xsl:if>
        </para>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl" match="subsection[@other-style='archaic']" mode="process">
        <xsl:variable name="header">
            <xsl:call-template name="FirstWordCapitalize">
                <xsl:with-param name="header">
                    <xsl:value-of select="header" />
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="KeepParentsFormatOrSelf" />
        <xsl:variable name="comment">Subsection archaic - <xsl:value-of select="@id" /></xsl:variable>
        <xsl:sequence select="gpo:outputComment($comment)" />
        <para loc="74">
            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            <xsl:if test="ancestor::quoted-block">
                <xsl:text>“</xsl:text>
            </xsl:if>
            <xsl:if test="header"> 
                <xsl:value-of select="$header" />
            </xsl:if>
            <xsl:apply-templates select="text" mode="inline" />
        </para>
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:str="http://xsltsl.org/string" name="ResDecorationText" as="node()*">
		<xsl:param name="resbody-style" as="xs:string?" />
		<xsl:choose>
			<xsl:when test="$resbody-style = 'constitutional-amendment'">
				<para loc="20"><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Resolved by the Senate and House of Representatives of the United States of America in Congress assembled ; (two-thirds of each House concurring therein),<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></para>
			</xsl:when>
			<xsl:when test="$restype='house-order' or $restype='senate-order'">
				<para loc="20"><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction> ; Ordered,<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></para>
			</xsl:when>
			<xsl:when test="$restype = 'senate-concurrent'">
				<para loc="20"><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Resolved by the Senate (the House of Representatives concurring),<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></para>
			</xsl:when>
			<xsl:when test="$restype = 'house-concurrent'">
				<para loc="20"><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Resolved by the House of Representatives (the Senate concurring),<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></para>
			</xsl:when>
			<xsl:when test="$restype = 'house-joint' or  $restype='senate-joint'">		
				<!--Issue #139 removed '7E' character-->
				<para loc="20"><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Resolved    by   the   Senate   and   House   of   Representatives   of   the   United   States   of   America   in   Congress   assembled,<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></para> 
			</xsl:when>
			<xsl:when test="$restype = 'constitutional-amendment'">			
				<para loc="20"><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Resolved by the Senate and House of Representatives of the United States of America in Congress assembled (two-thirds of each House concurring therein),<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></para>
			</xsl:when>
			<xsl:when test="$restype = 'senate-resolution'">			
				<para loc="20"><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Resolved,<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></para> 
			</xsl:when>
			<xsl:when test="$restype = 'house-resolution'">
				<para loc="20"><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Resolved,<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></para>
			</xsl:when>
			<xsl:when test="$restype = 'senate-ratification'">				
				<para loc="20"><xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>  Resolved  (two-thirds of the Senators present concurring therein),<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction></para>
			</xsl:when>
			<xsl:otherwise />
		</xsl:choose>
	</xsl:template><xsl:template xmlns:str="http://xsltsl.org/string" match="resolution-body" mode="process">
		<xsl:choose>
			<xsl:when test="count(preceding-sibling::resolution-body) = 0">
				<xsl:call-template name="handleFirstResolutionBody" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="handleSubsequentResolutionBody" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:str="http://xsltsl.org/string" name="handleSubsequentResolutionBody">
		<xsl:variable name="reported-display-style" as="xs:string?">
		<xsl:choose>
			<xsl:when test="./@reported-display-style">
				<xsl:sequence select="./@reported-display-style" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="child::section[1]/@reported-display-style" />
			</xsl:otherwise>
		</xsl:choose>
		</xsl:variable>
		
		<xsl:choose>
			<xsl:when test="$reported-display-style='italic'">
				<para format="6203" />
			</xsl:when>
			<xsl:when test="$reported-display-style='strikethrough'">
				<para format="6401" />
			</xsl:when>
			<xsl:when test="$resstage='Enrolled-Bill' or $resstage='Enrolled-in-Senate'">
				<para format="6501" />
			</xsl:when>
			<xsl:when test="$resstage='Engrossed-House' or $resstage='Engrossed-in-House'">
				<para format="6300" />
			</xsl:when>
			<xsl:when test=" contains($reported-display-style, 'boldface-roman') or contains(@vbattChangedForReported, 'boldface-roman')">
				<para format="6202" />
			</xsl:when>			
			<xsl:when test="contains($reported-display-style, 'boldface-italic') or contains(@vbattChangedForReported, 'boldface-italic')">
				<para format="6204" />
			</xsl:when>
			<xsl:otherwise>
				<para format="6201" />
				<xsl:if test="//insert">
					<para format="6201" />
					<para loc="80" />
					<command>FILENAME</command>
					<xsl:if test="not(//running-header[display='no'])">
						<para loc="81" />
						<xsl:value-of select="//running-header" />
					</xsl:if>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="not(./@display-resolving-clause='no-display-resolving-clause')"> 		
			<xsl:call-template name="ResDecorationText">
				<xsl:with-param name="resbody-style" as="xs:string?" select="@style" />
			</xsl:call-template>
		</xsl:if>
		<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:str="http://xsltsl.org/string" name="handleFirstResolutionBody">
	
		<xsl:choose>
			<xsl:when test="./@reported-display-style='italic'">
				<para format="6203" />
			</xsl:when>
			<xsl:when test="$docstage='Enrolled-Bill' or $resstage='Enrolled-House' or $resstage='Enrolled-in-Senate'">
				<para format="6501" />
			</xsl:when>
			<xsl:when test="contains($resstage, 'Engrossed')          and ($restype='senate-resolution' or $restype='house-resolution' or $restype='house-order' or $restype='senate-order')     and ((/resolution/whereas) or (/resolution/resolution-body))">	
				<para format="6300" />			
			</xsl:when>	
			<xsl:otherwise>
				<para format="6201" />
			</xsl:otherwise>
		</xsl:choose>			
			
	  	<xsl:if test="not(./@display-resolving-clause='no-display-resolving-clause')"> 
	  		<xsl:call-template name="ResDecorationText">
	  			<xsl:with-param name="resbody-style" as="xs:string?" select="@style" />
	  		</xsl:call-template>
		</xsl:if>
	  	
		<xsl:choose>
			<xsl:when test="(@reported-display-style='strikethrough' or @vbattChangedForReported='strikethrough') ">
				<xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
			</xsl:when>			
			<xsl:when test="(@reported-display-style='boldface-italic' or @vbattChangedForReported='boldface-italic') and not(count(//resolution-body) &gt; 1)">
				<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
			</xsl:when>			
			<xsl:otherwise>
				<xsl:text />
			</xsl:otherwise>
		</xsl:choose>		
	  	<xsl:apply-templates mode="process" />
	</xsl:template><xsl:template xmlns:str="http://xsltsl.org/string" match="resolution" mode="process">
	  <LOCDocument doctype="resolution">
	  	<xsl:copy-of select="@*" />
		<xsl:choose>
			<xsl:when test="$billstage='Enrolled-Bill' or $resstage='Enrolled-House' or $resstage='Enrolled-in-Senate' or $resstage='Enrolled-Bill'">
				<para format="6655" />
			</xsl:when>
			<xsl:otherwise>
				<para format="6652" />		
				<xsl:if test="(lower-case($docstage)='engrossed-in-senate' or lower-case($docstage)='engrossed-amendment-senate') and $res-public-print='yes'">
					<xsl:if test="//form/action[position()=last()]/action-date">
						<para loc="51" />		
						<xsl:value-of select="//form/action[position()=last()]/action-date" />
					</xsl:if>
					<xsl:if test="//form/action[position()=last()]/action-desc">
						<xsl:processing-instruction name="xpp">lp;&amp;12q</xsl:processing-instruction>
						<para loc="51" />
						<xsl:value-of select="//form/action[position()=last()]/action-desc" />
					</xsl:if>
					<xsl:processing-instruction name="xpp">lp;&amp;12q</xsl:processing-instruction>
				</xsl:if>
			
				<xsl:if test="contains($resstage, 'Engrossed') and not ($resstage='Engrossed-in-Senate' or $restype='house-resolution' or $restype='house-order' or $restype='senate-order') ">
					<xsl:choose>
						<xsl:when test="contains($resstage, 'House' ) and /resolution/preamble">
							<xsl:call-template name="officialTitleSpace">
								<xsl:with-param name="officalTitle" select="string(/resolution/form/official-title)" />
								<xsl:with-param name="EclauseType" select="'preamble'" />
								<xsl:with-param name="DocType" select="$restype" />
							</xsl:call-template>
						</xsl:when>
						<xsl:when test="contains($resstage, 'House' )">
							<xsl:call-template name="officialTitleSpace">
								<xsl:with-param name="officalTitle" select="string(/resolution/form/official-title)" />
								<xsl:with-param name="EclauseType" select="'no'" />
								<xsl:with-param name="DocType" select="$restype" />
							</xsl:call-template>
						</xsl:when>
						<xsl:when test="contains($resstage, 'Senate' )">
							<xsl:call-template name="officialTitleSpace">
								<xsl:with-param name="officalTitle" select="string(/resolution/form/official-title)" />
								<xsl:with-param name="EclauseType" select="string(//short-title)" />
								<xsl:with-param name="DocType" select="'S'" />
							</xsl:call-template>
						</xsl:when>
						<xsl:otherwise>
							<xsl:call-template name="officialTitleSpace">
								<xsl:with-param name="officalTitle" select="string(/resolution/form/official-title)" />
								<xsl:with-param name="EclauseType" select="''" />
								<xsl:with-param name="DocType" select="''" />
							</xsl:call-template>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:if>
				<xsl:if test="not($resstage='Engrossed-in-Senate' or $resstage='Pre-Introduction')">
					<para loc="59" />
				</xsl:if>
					
				<xsl:call-template name="displayI90ForAll" />
				
				<xsl:if test="not(starts-with($resstage, 'Enrolled'))">
					<xsl:variable name="toOutput91" as="xs:string">
						<xsl:call-template name="toOutputI90Line" />
					</xsl:variable>
					<xsl:if test="$toOutput91='true' and ($res-star-print and not($res-star-print='no-star-print'))">
						<xsl:variable name="starCount" as="xs:string" select="gpo:starPrint('no-star-print')" />
						<xsl:value-of select="$starCount" />
						<xsl:variable name="starString" select="gpo:getStarString(xs:integer($starCount))" />
						<xsl:text>S</xsl:text>
						<para loc="91" />
						<xsl:processing-instruction name="xpp">ff;6</xsl:processing-instruction>
						<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						<xsl:value-of select="$starString" />
						<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
						<xsl:if test="contains($resstage, 'Senate')">
							<xsl:text>(Star Print) </xsl:text>
						</xsl:if>
						<xsl:text> </xsl:text>
					</xsl:if>
				</xsl:if>
				<xsl:if test="not($resstage='Engrossed-in-Senate'           or $resstage='Engrossed-in-House'           or $resstage='Engrossed-House'           or $resstage='Received-in-Senate'           or $resstage='Referred-in-Senate'           or $resstage='Pre-Introduction'           or $resstage='Reported-in-Senate')">
					<para loc="39" />
					<para loc="346" />
					<xsl:if test="not(/resolution/form/calendar)">
						<para loc="40" />
					</xsl:if>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:apply-templates mode="process" />
	  </LOCDocument>
	</xsl:template><xsl:output xmlns:dc="http://purl.org/dc/elements/1.1" method="xml" indent="yes" /><xsl:preserve-space xmlns:dc="http://purl.org/dc/elements/1.1" elements="*" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="action-desc[ancestor::amendment-doc]" mode="process">
            <xsl:if test="not ($amendtype='house-amendment')"> 
                    <!--BH:  I am removing this because all the @blank-lines-after attributes are set to 0 in our test
                            data.  the 'pnode' paramater in 'getblank-lines-after' template is set to 'xs:integer' and
                            this is sending a string.  I am keeping code just in case we need to revisit this.-->
                  <xsl:if test="(@blank-lines-after)">                    
                            <xsl:call-template name="getblank-lines-after">
                                    <xsl:with-param name="pnode" select="4" />
                                    <!--<xsl:with-param name="pnode" select="'action-desc'"/>-->
                                    <xsl:with-param name="pvalue" select="@blank-lines-after" />
                            </xsl:call-template>  
                  </xsl:if>
           </xsl:if>
            <xsl:if test="not(@display='no')">
                <xsl:variable name="contents" as="item()*">
                	<xsl:apply-templates />
                </xsl:variable>
                <xsl:choose>
                        <xsl:when test="$amendtype='house-amendment'">
     
                                <xsl:if test="not($contents='')">
                               <para format="6301" loc="74" />
                                        <xsl:processing-instruction name="xpp">ff:2</xsl:processing-instruction>
                                        <xsl:processing-instruction name="xpp">fv:1</xsl:processing-instruction>
                                        <!--BH:  Not sure why they set and reset the same bell codes with no content?-->
                                        <xsl:analyze-string select="$contents" regex="((\d+)(\[(.*)\])*)">
                                                <xsl:matching-substring>
                                                        <xsl:processing-instruction name="xpp">ff:1</xsl:processing-instruction>
                                                        <xsl:processing-instruction name="xpp">fv:2</xsl:processing-instruction>
                                                        <xsl:processing-instruction name="xpp">ff:2</xsl:processing-instruction>
                                                        <xsl:processing-instruction name="xpp">fv:1</xsl:processing-instruction>
                                                </xsl:matching-substring>
                                                <xsl:non-matching-substring />
                                        </xsl:analyze-string>
                                        
                              <!--   <xsl:value-of select="lexa:rawRegexReplace(string($contents), '((\d+)(\[(.*)\])*)',
                                      '&lt;BEL&gt;G1&lt;BEL&gt;T2$1&lt;BEL&gt;G2&lt;BEL&gt;T1')"/>
                          -->      </xsl:if>
                            
                                <xsl:if test="not(following-sibling::action-instruction)">
                                        <xsl:choose>
                                                <xsl:when test="not(@blank-lines-after)" />
                                                <xsl:when test="@blank-lines-after">
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <xsl:with-param name="pvalue"><xsl:value-of select="@blank-lines-after" /></xsl:with-param>
                                                        </xsl:call-template>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                        <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>      
                                                </xsl:otherwise>
                                        </xsl:choose>
                                </xsl:if>
                        </xsl:when>
                        <xsl:otherwise>
                                <para loc="77">
                                <xsl:choose>
                                        <xsl:when test="contains(.,'In the Nature of a Substitute')">
                                                <xsl:processing-instruction name="xpp">fv:4</xsl:processing-instruction>
                                                <xsl:value-of select="replace(normalize-space($contents), 'In the Nature of a Substitute', 'Amendment In the Nature of a Substitute')" />
                                                <xsl:processing-instruction name="xpp">fv:1</xsl:processing-instruction>
                                               <!-- <xsl:value-of select="lexa:rawRegexReplace(string($contents), '^Amendment In the Nature of a Substitute', 
                                                        '&lt;BEL&gt;T4Amendment In the Nature of a Substitute&lt;BEL&gt;T1')" />-->
                                        </xsl:when>
                                        <xsl:otherwise>
                                                <xsl:processing-instruction name="xpp">fv:4</xsl:processing-instruction>
                                                <xsl:value-of select="$contents" />
                                                <xsl:processing-instruction name="xpp">fv:1</xsl:processing-instruction>
                                        </xsl:otherwise>
                                 </xsl:choose>
                                </para>
                        </xsl:otherwise>
                </xsl:choose>
                
        </xsl:if>
            
      </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="action-instruction[ancestor::amendment-doc]" mode="process">
           <!-- <xsl:if  test="(@blank-lines-after)">                    
                    <xsl:call-template name="getblank-lines-after">
                            <xsl:with-param name="pnode" select="'action-instruction'"/>
                            <xsl:with-param name="pvalue" select="@blank-lines-after"/>
                    </xsl:call-template>  
            </xsl:if> -->
            <xsl:choose>
                    <xsl:when test="$amendtype='house-amendment'">
                            <xsl:text>
</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>    
                            <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                    </xsl:otherwise>
            </xsl:choose>
            <xsl:variable name="contents" select="." as="item()*" />   
            <para>
            <xsl:if test="not($contents='')">
                    <xsl:attribute name="format">6211</xsl:attribute>
                    <xsl:attribute name="loc">74</xsl:attribute>
                    <xsl:processing-instruction name="xpp">fv:2</xsl:processing-instruction>
                    <xsl:value-of select="." />
            </xsl:if>            
                <xsl:if test="$amendtype='house-amendment'">
                        <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>

                </xsl:if>
            </para>
      </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="purpose[ancestor::amendment-doc]" mode="process">  
                <!--BH:  Not 100% sure what they wanted to do but believe this will work better -->
                    <!--<xsl:for-each select="node()">                       
                            <xsl:apply-templates select='.' />                                               
                    </xsl:for-each>  -->
                <xsl:copy><xsl:apply-templates select="node() | @*" /></xsl:copy>
      </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form[ancestor::amendment-doc]" mode="process">        
            <xsl:variable name="officialTitle" as="xs:string">
        	<xsl:apply-templates select="official-title" />
            </xsl:variable>
            <xsl:if test="//amendment-doc/@dms-id='G'">
                    <xsl:call-template name="displayI90ForAll" />
            </xsl:if>                
            <xsl:if test="//distribution-code and not(//distribution-code/@display='no')">                   
                     <xsl:apply-templates select="//distribution-code" />
            </xsl:if>
            <xsl:if test="//amendment-doc/@dms-id='G'">
                    <xsl:if test="calendar and not( calendar[@display='no'])">
                            <para loc="36" />
                            <xsl:variable name="calendarValue" select="calendar" as="xs:string" />
                            <xsl:variable name="calendarValueToPrint" as="item()*">
                                    <xsl:call-template name="makeNumberBold">
                                            <xsl:with-param name="theValue">
                                                    <xsl:value-of select="$calendarValue" />
                                            </xsl:with-param>
                                    </xsl:call-template>
                            </xsl:variable>
                            <xsl:value-of select="$calendarValueToPrint" />
                    </xsl:if>
        </xsl:if>
        <xsl:if test="amend-num and not(amend-num[@display='no'])">
                <para loc="38" />
                <xsl:variable name="amendValue" select="amend-num" as="xs:string" />
                <xsl:variable name="amendValueToPrint" as="item()*                         ">
                        <xsl:call-template name="makeNumberBold">
                                <xsl:with-param name="theValue">
                                        <xsl:value-of select="$amendValue" />
                                </xsl:with-param>
                        </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$amendValueToPrint" />
        </xsl:if>       
            <xsl:if test="not(//amendment-doc/@dms-id='G')">
                    <xsl:if test="calendar and not( calendar[@display='no'])">
                            <para loc="36" />
                            <xsl:variable name="calendarValue" select="calendar" as="xs:string" />
                            <xsl:variable name="calendarValueToPrint" as="item()">
                                    <xsl:call-template name="makeNumberBold">
                                            <xsl:with-param name="theValue">
                                                    <xsl:value-of select="$calendarValue" />
                                            </xsl:with-param>
                                    </xsl:call-template>
                            </xsl:variable>
                            <xsl:value-of select="$calendarValueToPrint" />
                    </xsl:if>
            </xsl:if>
         <xsl:if test="//running-header and not(//running-header[@display='no'])">  
                 <para loc="81" />
                    <xsl:value-of select="//running-header" />		       		
		</xsl:if>         
         <xsl:if test="../pre-form/legis-counsel">
        	<xsl:apply-templates select="../pre-form/legis-counsel" />
         </xsl:if>
            <xsl:choose>
                    <xsl:when test="purpose and not(purpose[@display='no'])  and not(../pre-form/meta-house)">
                            <para loc="39" />
                            <xsl:variable name="setPurpose" as="item()">
                                    <xsl:apply-templates select="purpose" mode="Amendment" />
                            </xsl:variable>
                            <xsl:value-of select="$setPurpose" />
                    </xsl:when>
                    <xsl:otherwise>
                            <xsl:if test="$amendtype='house-amendment' or  $amendtype='insert' ">
                                    <xsl:apply-templates select="//first-page-header" />
                                    <xsl:apply-templates select="//first-page-date" />                                    
                                    <xsl:apply-templates select="//first-page-desc" />                                                           
                                    <xsl:apply-templates select="//legis-number" />
                            </xsl:if>
                    </xsl:otherwise>
             </xsl:choose>
       
        
<!-- NB 5/30/2006
            Honestly, I think this should not be output whenever there current-chamber is missing, 
            but I am only checking when it is house-amendment as per instruction
            
            If added for the I45 code and current chamber stuff
        <xsl:if test="not($amendtype='house-amendment') or (current-chamber and not (current-chamber[@display='no']))">
        
        SM 12/27/06 Based on new instruction from Kathlean I45 does output if  there is congress or  session
-->
            <xsl:if test="(current-chamber and not (current-chamber[@display='no']))          or (congress and not(congress[@display='no']))          or (session and not(session[@display='no']))">                    
          <para loc="45" />
                 <xsl:if test="current-chamber and not(current-chamber[@display='no'])">
			
                            <xsl:value-of select="current-chamber" />
	<xsl:if test="congress and not(congress[@display='no'])">
                                    <xsl:text>[underscore]</xsl:text>
                             </xsl:if>
                    </xsl:if>
                     <xsl:if test="congress and not(congress[@display='no'])">
                                <xsl:value-of select="congress" />
                                <xsl:text>, </xsl:text>
                      </xsl:if>
                        <xsl:if test="session and not(session[@display='no'])">
	        <xsl:if test="not(congress) or congress[@display='no']">_
<!--                                                <xsl:text disable-output-escaping="yes">[underscore]</xsl:text>-->
                                    </xsl:if>
                                  <xsl:value-of select="session" />
                        </xsl:if>
            </xsl:if>
            
                <xsl:choose>                    
                 <xsl:when test=" contains(legis-num,'(no.)') and contains(official-title,'(title)')">        
	<xsl:if test="legis-num and not(legis-num[@display='no'])">
	        <para format="6652" loc="46">
	                <xsl:processing-instruction name="xpp">fv:1</xsl:processing-instruction>
                                        <xsl:value-of select="legis-num" />
	        </para>
                             </xsl:if>
                                <xsl:if test="official-title and not(official-title[@display='no'])">
                                        <para loc="87" />
                                        <para loc="88" />
                                        <xsl:processing-instruction name="xpp">L</xsl:processing-instruction>
                                        <para loc="87" />
                                        <xsl:processing-instruction name="xpp">L</xsl:processing-instruction>
                                        <para loc="87" />
                                        <xsl:processing-instruction name="xpp">L</xsl:processing-instruction>
 <!--<xsl:value-of select="lexa:rawRegexReplace(string($officialTitle), '_+', '&lt;BEL&gt;I88[y0D]&lt;BEL&gt;L[y0D]&lt;BEL&gt;I87[y0D]&lt;BEL&gt;L[y0D]&lt;BEL&gt;I87[y0D]&lt;BEL&gt;L[y0D]')" />
  -->                                      
                                </xsl:if>
                 </xsl:when>
                 <xsl:when test=" (contains(legis-num,'S.') or contains(legis-num,'H.')) and contains(official-title,'(title)')">
	<xsl:if test="legis-num and not(legis-num[@display='no']) and string-length(legis-num) &gt; 0">
	        <para format="6654" loc="43">
                                      
                                          <xsl:value-of select="legis-num" />
	        </para>
	</xsl:if>
	<xsl:if test="official-title and not(official-title[@display='no'])">
	        <para format="6654" loc="87" />
                <para loc="88" />  
	        <para loc="87">
	        <xsl:processing-instruction name="xpp">L</xsl:processing-instruction>  
	        </para>
	        <xsl:processing-instruction name="xpp">L</xsl:processing-instruction>  
	        <!--<xsl:value-of select="lexa:rawRegexReplace(official-title, '_+', 
                                                '&lt;BEL&gt;I88[y0D]&lt;BEL&gt;L[y0D]&lt;BEL&gt;I87[y0D]&lt;BEL&gt;L[y0D]&lt;BEL&gt;I87[y0D]&lt;BEL&gt;L[y0D]')"/>
                -->
	</xsl:if>
                    </xsl:when>      
                     <xsl:otherwise>
	<xsl:if test="legis-num and not(legis-num[@display='no']) and string-length(legis-num) &gt; 0">
                                        <xsl:choose>
                                                <xsl:when test="$amendtype='house-amendment'">
                                                        <xsl:if test="not($amendtype='house-amendment'                                                                  and //amendment-form and                                                                  not(purpose and not(purpose[@display='no'])                                                                   and not(../pre-form/meta-house)) )">
                                                                <xsl:apply-templates select="//first-page-header" />
                                                        </xsl:if> 
                                                        <xsl:apply-templates select="legis-num" />
                                                </xsl:when>
                                                <xsl:otherwise>
                                                        <para format="6654" loc="43">
                                                                <xsl:value-of select="legis-num" />
                                                        </para>
                                                </xsl:otherwise>
                                            </xsl:choose>
                                </xsl:if>
                                <xsl:if test="not(official-title[@display='no']) and official-title">
                        
                         <para loc="88">
                                 <xsl:processing-instruction name="xpp">L</xsl:processing-instruction>
                         </para>
                         <para loc="87">
                                 <xsl:processing-instruction name="xpp">L</xsl:processing-instruction>   
                         </para>    
                         <para loc="87">
                                  <xsl:processing-instruction name="xpp">L</xsl:processing-instruction>   
                         </para>    
    <!--                                   
<xsl:value-of select="lexa:rawRegexReplace(string($officialTitle), '_+', '&lt;BEL&gt;I88[y0D]&lt;BEL&gt;L[y0D]&lt;BEL&gt;I87[y0D]&lt;BEL&gt;L[y0D]&lt;BEL&gt;I87[y0D]&lt;BEL&gt;L[y0D]')" />
                                -->  
                                </xsl:if>                            
                        </xsl:otherwise>                        
                </xsl:choose>
            <xsl:if test="not($amendtype='house-amendment') and (action and not (action[@display='no']))">
                    <xsl:if test="action and not(action[@display='no'])">
                            <para format="6654">
                            <xsl:if test="action/action-date and not(action/action-date[@display='no']) and not (action/action-date/text='')">   
                                    <xsl:attribute name="loc">46</xsl:attribute>
                               </xsl:if>
                                     <xsl:apply-templates mode="Amendment" select="action" />
                            </para>
                       </xsl:if>
            </xsl:if>
            <xsl:if test="$amendtype='house-amendment' and (action and not (action[@display='no']))">
                    <xsl:apply-templates mode="Amendment" select="action" />
            </xsl:if>           
            <xsl:if test="(congress and session and not (congress[@display='no']) and not(session[@display='no']))  and //amendment-doc/@amend-type='senate-amendment'">
            <para loc="55">Viz:</para>
                </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="makeNumberBold">
                <xsl:param name="theValue" as="item()*" />
                <xsl:variable name="theValueToPrint" as="item()+">
                        <xsl:if test="contains($theValue ,'.')">
                                <xsl:variable name="firstPart" select="concat(substring-before($theValue, '.'), '. ')" as="xs:string" />
                                <xsl:variable name="lastPart" select="substring-after($theValue, '.')" as="xs:string" />
                                <xsl:choose>
                                        <xsl:when test="contains($lastPart, '___')">
                                                        <xsl:value-of select="$theValue" />
                                        </xsl:when>
                                        <xsl:otherwise>
                                                <xsl:value-of select="normalize-space($firstPart)" />
                                                <xsl:processing-instruction name="xpp">fv:2</xsl:processing-instruction>
                                                <xsl:value-of select="normalize-space($lastPart)" />
                                        </xsl:otherwise>
                                </xsl:choose>                              
                        </xsl:if>                              
                        <xsl:if test="not(contains($theValue ,'.'))">
                                <xsl:value-of select="$theValue" />
                        </xsl:if>       
                </xsl:variable>
                <xsl:value-of select="$theValueToPrint" />
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-doc" mode="process">
                <xsl:variable name="amendtype" select="@amend-type" as="xs:string?" />
                <amendment-doc>
                        <xsl:copy-of select="@*" />
                        <para>
                                <xsl:choose>
                                <xsl:when test="$amendtype='house-amendment'">
                                        <xsl:attribute name="format">6652</xsl:attribute>
                                        <xsl:attribute name="loc">59</xsl:attribute>
                                </xsl:when>
                                <xsl:when test="($amendtype='senate-amendment'  or $amendtype='insert'                                         or  $amendtype='Amendment' ) and  /amendment-doc/pre-form/first-page-header ">
                                        <xsl:attribute name="format">6652</xsl:attribute>
                                </xsl:when>
                                <xsl:when test="$amendtype='senate-amendment'">
                                        <xsl:attribute name="format">6654</xsl:attribute>
                                </xsl:when>   
                                <xsl:when test="$amendtype='engrossed-amendment'">
                                        <xsl:attribute name="format">6652</xsl:attribute>
                                </xsl:when>
                                <xsl:otherwise>
                                        <xsl:attribute name="format">6654</xsl:attribute>
                                </xsl:otherwise>
                                </xsl:choose>
                        </para>
                        <xsl:apply-templates mode="process" />
                </amendment-doc>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-doc" mode="abc">
           <amendment-doc>
                    <para>
             <xsl:choose>
                    <xsl:when test="$amendtype='house-amendment'">
                            <xsl:attribute name="format">6652</xsl:attribute>
                            <xsl:attribute name="loc">59</xsl:attribute>
                    </xsl:when>
                   <xsl:when test="($amendtype='senate-amendment'  or $amendtype='insert'                            or  $amendtype='Amendment' ) and  /amendment-doc/pre-form/first-page-header ">
                           <xsl:attribute name="format">6652</xsl:attribute>
                   </xsl:when>
                    <xsl:when test="$amendtype='senate-amendment'">
                            <xsl:attribute name="format">6654</xsl:attribute>
                    </xsl:when>   
                     <xsl:when test="$amendtype='engrossed-amendment'">
                             <xsl:attribute name="format">6652</xsl:attribute> 
                     </xsl:when>
                    <xsl:otherwise>
                            <xsl:attribute name="format">6654</xsl:attribute>
                    </xsl:otherwise>
           </xsl:choose>
            <xsl:if test="(//meta-house and not(//meta-house/@display='no')) or (//meta-senate and not(//meta-senate/@display='no')) ">
                    <xsl:call-template name="initialMetaHouse" />
            </xsl:if>
            <xsl:if test="/amendment-doc/pre-form/first-page-header                      and ($amendtype='senate-amendment'                      or  $amendtype='Amendment' )">
                    <xsl:if test="not(//first-page-header[@display='no']) and   not( (//meta-house or //meta-senate)  and  ( not(//amendment-form) or //amendment-form/@display='no' ))">
                            <xsl:apply-templates select="//first-page-header" />
                            <xsl:apply-templates select="//first-page-date" />
                            <xsl:apply-templates select="//first-page-desc" />
                            <!--BH:  This needs to be refactored when we have data because the para below will be inside a para.-->
                            <para format="6654" />   
                    </xsl:if>
</xsl:if>
        <xsl:if test="//amendment-form">              
            <xsl:if test="not(//amendment-form[@display='no'])">
                    <xsl:apply-templates mode="Amendment" select="//amendment-form" />
            </xsl:if>
        </xsl:if>  
                    </para>
            <xsl:apply-templates mode="process" />
            </amendment-doc>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="createLegisNum"> 
                        <!--<xsl:variable name="text"><xsl:value-of select="substring-before(/amendment-doc/engrossed-amendment-body/section[1]/text[1]/text()[1], ')')"/></xsl:variable>-->
                
                <!-- fixes issue #365 -->
                <xsl:variable name="text"><xsl:value-of select="substring-before(//engrossed-amendment-body/section[1]/text, ')')" /></xsl:variable>
                <xsl:variable name="legis-num"><xsl:value-of select="substring-after($text, '(')" /></xsl:variable>
                        <xsl:variable name="number">
                                <xsl:value-of select="substring-after($legis-num, '(')" />       
                        </xsl:variable>
                        <xsl:choose>
                                <xsl:when test="contains($legis-num, 'S')">S</xsl:when>
                                <xsl:when test="contains($legis-num, 'HR')">HR</xsl:when>
                                <xsl:when test="contains(//current-chamber, 'House')">HR</xsl:when>
                                <xsl:when test="contains(//current-chamber, 'Senate')">S</xsl:when>
                                <xsl:otherwise />
                        </xsl:choose>
                        <xsl:value-of select="substring-after($legis-num, ' ')" />
                        <xsl:choose>
                                <xsl:when test="contains(//current-chamber, 'House')">EAH</xsl:when>
                                <xsl:when test="contains(//current-chamber, 'Senate')">EAS</xsl:when>
                                <xsl:otherwise />
                        </xsl:choose>               
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="xxxengrossed-amendment-form" mode="process">
                <!--xsl:call-template name="displayI90ForAll"/-->
                <xsl:call-template name="PrintStarAndI90LineForEngrAmend" />    
                <xsl:apply-templates select="distribution-code" />
                
                <para loc="02"><xsl:value-of select="//current-chamber" /></para>
                <para loc="03"><xsl:value-of select="//action-date" />
                        <xsl:choose>
                                <xsl:when test="ends-with(//action-date, '.')" />
                                <xsl:otherwise><xsl:text>.</xsl:text></xsl:otherwise>
                        </xsl:choose>.</para>
                <!--BH:  Not sure what this should be doing.  It is causing errors because there are 2 'action-date' elements in the
                        amenment.  We will need to revisit.-->
              <!--  <xsl:if test="not(contains(//action-date[1],'.'))">
                        <xsl:value-of select="'.'"/>
                </xsl:if>-->
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-doc" mode="AmendmentFinal">
                <xsl:if test="//meta-house">
                        <xsl:call-template name="finalMetaHouse" />
                </xsl:if>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="initialMetaHouse">
                <xsl:variable name="string"><xsl:value-of select="//holc-filename" /></xsl:variable>
                <xsl:variable name="search-for">/</xsl:variable>
                <xsl:variable name="replace-with">∖</xsl:variable>
                <xsl:if test="//holc-filename or //holc-last-saved or //holc-last-author">
                        <command>
                       
                        <xsl:if test="//holc-filename">
                                <xsl:text>Archive of:</xsl:text>
                                <xsl:value-of select="gpo:search-and-replace($string, $search-for, $search-for)" />
                                <!--<xsl:call-template name="search-and-replace">
                                        <xsl:with-param name="string"><xsl:value-of select="//holc-filename"/></xsl:with-param>
                                        <xsl:with-param name="search-for">\</xsl:with-param>
                                        <xsl:with-param name="replace-with">&#x2216;</xsl:with-param>
                                </xsl:call-template>-->
                        </xsl:if>
                        <xsl:if test="//holc-last-saved">
                                <xsl:text>created </xsl:text>
                                <xsl:value-of select="//holc-last-saved" />
                                <xsl:text> </xsl:text>
                        </xsl:if>
                        <xsl:if test="//holc-last-author">
                                <xsl:text>by </xsl:text>
                                <xsl:value-of select="//holc-last-author" />
                                <xsl:text> </xsl:text>
                        </xsl:if>
                        </command>
                </xsl:if>
                <xsl:if test="//holc-attorney or //holc-last-saved">
                       <command>
                               <xsl:if test="//holc-attorney">
                                <xsl:text>ATTORNEY: </xsl:text>
                                <xsl:value-of select="//holc-attorney" />
                                <xsl:text> </xsl:text>
                        </xsl:if>
                        <xsl:if test="//holc-last-saved">
                                <xsl:text> (Created: </xsl:text>
                                <xsl:value-of select="//holc-last-saved" />
                                <xsl:text>)</xsl:text>
                        </xsl:if>
                       </command>                       
                </xsl:if>
                <xsl:if test="$amendtype='house-amendment'">
                        <xsl:if test="//author-note">
                                <xsl:apply-templates select="//author-note" />
                        </xsl:if>
                </xsl:if>
       <xsl:if test="not(//amendment-form) or //amendment-form/@display='no'">
                       <xsl:apply-templates select="//running-header" />
                       <xsl:apply-templates select="//legis-counsel" />
                        <xsl:apply-templates select="//first-page-header" />
                        <xsl:apply-templates select="//first-page-date" />
                        <xsl:apply-templates select="//legis-number" />
                 </xsl:if>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="finalMetaHouse">
                <xsl:if test="//holc-filename or //holc-last-saved or //holc-last-author">
                       <command>
                        <xsl:apply-templates select="//version[last()]" />
                       </command>  
                </xsl:if>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="version">
                <xsl:apply-templates select="version-date" />
                <xsl:apply-templates select="version-filename" />
                <xsl:apply-templates select="version-creator" />
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="version-date">
                <xsl:value-of select="." />
                <xsl:text> </xsl:text>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="version-filename">
                <xsl:if test="../version-date"><xsl:text>- </xsl:text></xsl:if>
                <xsl:variable name="filename1" as="item()*">
                        <xsl:variable name="string" select="." />
                        <xsl:variable name="search-for">\\</xsl:variable>
                        <xsl:variable name="replace-with">ࢨ</xsl:variable>
                        <xsl:value-of select="gpo:search-and-replace($string, $search-for, $replace-with)" />
                </xsl:variable>
                <xsl:variable name="filename2" as="item()*">
                        <xsl:variable name="string" select="$filename1" />
                        <xsl:variable name="search-for">\.xml</xsl:variable>
                        <xsl:variable name="replace-with" />
                        <xsl:value-of select="gpo:search-and-replace($string, $search-for, $replace-with)" />
                </xsl:variable>
                <xsl:variable name="filename3" as="item()*">
                        <xsl:variable name="string" select="$filename2" />
                        <xsl:variable name="search-for">\.XML</xsl:variable>
                        <xsl:variable name="replace-with" />
                        <xsl:value-of select="gpo:search-and-replace($string, $search-for, $replace-with)" />
                </xsl:variable>
                <xsl:value-of select="$filename3" />
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="version-creator">
                <xsl:text>Created by: </xsl:text>
                <xsl:value-of select="substring(., 1, 8)" />
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-block" mode="process">
                
                <xsl:if test="@display-inline='yes-display-inline'">
                        <xsl:if test="@reported-display-style='italic' and . /text">
                                <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
                        </xsl:if>
                        <xsl:value-of select="text" />
                </xsl:if>          
                <xsl:variable name="conferenceReportStyle" as="item()*">
                        <xsl:value-of select="gpo:GetConferenceReportStyle(.)" />
                </xsl:variable>       
                <xsl:variable name="toStartBillFromTheNEwPage" as="item()*">
                        <xsl:call-template name="newPageOnConfReportDraft" />
                </xsl:variable>	           
                <xsl:choose>
                        <xsl:when test="$amendtype='conference-report'">
                                <xsl:choose>
                                        <xsl:when test="$toStartBillFromTheNEwPage = 'true'">
                                                <para format="62012">
                                                        <xsl:if test="//pre-form/legis-counsel">
                                                                <xsl:attribute name="loc">82</xsl:attribute>
                                                                <xsl:value-of select="//pre-form/legis-counsel" />
                                                        </xsl:if>	
                                                </para>
                                        </xsl:when>
                                        <xsl:when test="($conferenceReportStyle='draft' or $conferenceReportStyle='bill') and @line-numbers='off' ">
                                                <para format="6303" />
                                        </xsl:when>
                                        <xsl:when test="$conferenceReportStyle='bill' or $conferenceReportStyle='draft' ">
                                                <para format="6203" />
                                        </xsl:when>
                                        <xsl:otherwise>
                                                <para format="6603" />
                                        </xsl:otherwise>
                                </xsl:choose>
                        </xsl:when>
                        <xsl:otherwise>
                                <xsl:call-template name="KeepParentsFormatOrSelf" />				
                        </xsl:otherwise>
                </xsl:choose>
                <para>
                        <xsl:if test="@line-numbers='off'                                  and not ($amendtype='conference-report')                                  and not ($m_isCommitteeReport='Yes')                                  and not ($toStartBillFromTheNEwPage ='true') ">
                                <xsl:attribute name="format">6301</xsl:attribute>
                        </xsl:if>
                      
                </para>
                <xsl:apply-templates mode="process" />
                <xsl:if test="not(string-length(local-name(following::*[1]))=0)">
                        
                        <!--BH:  Need to revisit the 'pnode' attribute in the template 
                named getblank-lines-after.  The 'pnode' is defined as a 
                integer but in this template it sends but template and element 
                name.--> 
                        <xsl:choose>
                                <xsl:when test="/amendment-doc/@amend-type='conference-report'">
                                        <xsl:choose>
                                                <xsl:when test="@blank-lines-after">
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <xsl:with-param name="pvalue" select="@blank-lines-after" />
                                                        </xsl:call-template>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <xsl:with-param name="pvalue" select="1" />
                                                        </xsl:call-template>
                                                </xsl:otherwise>
                                        </xsl:choose>
                                </xsl:when>                
                                <xsl:when test="following-sibling::amendment-instruction or following-sibling::amendment-block or ../following-sibling::amendment ">
                                        <xsl:choose>
                                                <xsl:when test="@blank-lines-after">
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <!-- <xsl:with-param name="pnode" select="'action-desc'"/>-->
                                                                <xsl:with-param name="pvalue" select="@blank-lines-after" />
                                                        </xsl:call-template>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <!-- <xsl:with-param name="pnode" select="'action-desc'"/>-->
                                                                <xsl:with-param name="pvalue" select="1" />
                                                        </xsl:call-template>
                                                </xsl:otherwise>
                                        </xsl:choose>
                                </xsl:when>
                                <xsl:otherwise>
                                        
                                        <!-- SM 12/12/06 add this since there is dtd at work  -->
                                        <xsl:choose>
                                                <xsl:when test="@blank-lines-after">
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <!-- <xsl:with-param name="pnode" select="'action-desc'"/>-->
                                                                <xsl:with-param name="pvalue" select="@blank-lines-after" />
                                                        </xsl:call-template>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <!--<xsl:with-param name="pnode" select="'action-desc'"/>-->
                                                                <xsl:with-param name="pvalue" select="1" />
                                                        </xsl:call-template>
                                                </xsl:otherwise>
                                        </xsl:choose>
                                        
                                </xsl:otherwise>
                        </xsl:choose>
                </xsl:if>
                <xsl:if test="ancestor-or-self::amendment-block/ancestor::committee-report-segment or ancestor-or-self::amendment-block/ancestor::committee-report-part">
                        <para format="6602" />
                </xsl:if>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-body" mode="process">
                <xsl:choose>
                        <xsl:when test="$amendtype = 'conference-report'">
                                <xsl:apply-templates mode="conference-report" select="." />
                                <xsl:apply-templates mode="process" />
                        </xsl:when>
                        <xsl:when test="resolution-body">
                                <xsl:apply-templates select="resolution-body" mode="process" />
                        </xsl:when>
                        <xsl:otherwise>
                                <xsl:apply-templates mode="process" />
                        </xsl:otherwise>
                </xsl:choose>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form" mode="process">
                <!--BH:  In order to perform a unit test a wrapper element is required.  Need to 
            revisit this. -->
                <wrapper>
                        <xsl:if test="calendar">         
                                <para format="6654" />
                        </xsl:if>
                        <xsl:if test="not(calendar)">
                                <para format="6201" />
                        </xsl:if>
                        <para loc="80"><command>FILENAME</command></para>
                        <xsl:if test="not(//running-header[display='no'])">
                                <para loc="81">
                                        <xsl:value-of select="//running-header" /></para>
                        </xsl:if>
                        <xsl:if test="../pre-form/legis-counsel">
                                <xsl:apply-templates select="../pre-form/legis-counsel" mode="process" />
                        </xsl:if>
                        <command><para loc="81">DISCUSSION DRAFT</para></command>
                        <command><para loc="81">CONFIDENTIAL DRAFT</para></command>
                        <xsl:apply-templates mode="process" />
                </wrapper>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form/action" mode="process">
                <xsl:if test="not(preceding-sibling::*)">
                        <para format="6301" loc="74">
                                <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>     
                                <xsl:value-of select="substring-before(., 'by')" />
                                <xsl:text>by</xsl:text>
                                <!--BH:  Placed the Qcode in the para.-->
                                <!--<xsl:text disable-output-escaping="yes">
&lt;BEL&gt;Q10</xsl:text>-->
                        </para>
                        <xsl:choose>
                                <xsl:when test="contains(.,'by ')">
                                        <!--BH:  I don't think this is a valid test.  I modified this to use valid tests.-->
                                        <para loc="74">
                                                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                                                <xsl:value-of select="substring-after(., 'by')" />
                                        </para>
                                </xsl:when>
                                <xsl:when test="contains(action-desc,'by ')">
                                        <!--BH:  I don't think this is a valid test.  There isn't 'text' in the 'action' element.-->
                                        <para loc="74">
                                                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                                                <xsl:value-of select="substring-after(., 'by')" />
                                        </para>
                                </xsl:when>
                                <xsl:otherwise><para>not found!</para></xsl:otherwise>
                        </xsl:choose>
                        <xsl:if test="contains(.,'by ')">
                                <!--BH:  I don't think this is a valid test.  There isn't 'text' in the 'action' element.-->
                                <para loc="74">
                                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                                        <xsl:value-of select="substring-after(//., 'by')" />
                                </para>
                        </xsl:if>
                        <xsl:if test="contains(action,'by ')">
                                <!--BH:  I don't think this is a valid test.  There isn't 'text' in the 'action' element.-->
                                <para loc="74">
                                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                                        <xsl:value-of select="substring-after(., 'by')" />
                                </para>
                        </xsl:if>
                        <xsl:if test="contains(.,'BY ')">
                                <para loc="74">
                                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                                        <xsl:value-of select="." />
                                </para>
                        </xsl:if>
                        <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
                </xsl:if>		
                <xsl:if test="preceding-sibling::*">
                        <para format="6654" loc="46"><command>DATELINE</command></para>
                        <xsl:for-each select="action-desc">
                                <para loc="77">
                                        <xsl:variable name="actionText">
                                                <xsl:apply-templates mode="process" />
                                        </xsl:variable>
                                        <xsl:if test="(starts-with($actionText,'Amendment'))">
                                                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>     
                                                <xsl:value-of select="substring-before($actionText,' ')" />
                                                <xsl:if test="starts-with(substring-after($actionText,' '),'In the Nature of a Substitute')">
                                                        <xsl:text> In the Nature of a Substitute</xsl:text>
                                                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                                                        <xsl:value-of select="substring-after($actionText,'Substitute ')" />
                                                </xsl:if>
                                                <xsl:if test="not(starts-with(substring-after($actionText,' '),'In the Nature of a Substitute '))">
                                                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                                                        <xsl:value-of select="substring-after($actionText,' ')" />
                                                </xsl:if>
                                        </xsl:if>
                                        <xsl:if test="not(starts-with($actionText,'Amendment'))">
                                                <xsl:value-of select="$actionText" />
                                        </xsl:if>
                                </para>
                        </xsl:for-each>
                        <xsl:if test=" ancestor::amendment-doc/@amend-type='senate-amendment'">
                                <para loc="55">Viz:</para>
                                <!--BH:  Keeping this in the file to verify this is the right encoding.-->
                                <!--<xsl:text disable-output-escaping="yes">
&lt;BEL&gt;I55Viz:</xsl:text>-\->-->
                        </xsl:if>
                </xsl:if>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form/amend-num" mode="process">
                <para loc="38"><xsl:value-of select="." /></para>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form/calendar" mode="process">
                <para loc="36"><xsl:apply-templates mode="process" /></para>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form/current-chamber" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form/session" mode="process" /><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form/purpose" mode="process">
                <para loc="39">Purpose: <xsl:apply-templates mode="process" /></para>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form/legis-num" priority="1" mode="process">
                <xsl:choose>
                        <xsl:when test="starts-with(.,'(no.)')">
                                <para format="6652" loc="46"><!-- 09/02/2015 mharcourt XSLT 2.0 refactoring --><!--<xsl:text disable-output-escaping="yes">
&lt;BEL&gt;S6652</xsl:text>
					<xsl:text disable-output-escaping="yes">
&lt;BEL&gt;I46&lt;BEL&gt;T1(no.)&lt;BEL&gt;K</xsl:text>-->
                                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                                        <xsl:text>(no.)</xsl:text>
                                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                                        <xsl:value-of select="substring(.,6)" />
                                </para>
                        </xsl:when>
                        <xsl:otherwise>
                                <!-- NB 5/30/2006
	Wrapped the origial otherwise in a test to see if we are in a house-amendment
	then put in appropriate code for house-amendments 
				-->
                                <xsl:choose>
                                        <xsl:when test="/amendment-doc/@amend-type='house-amendment'">
                                                <!-- NB 6/16/2006 - added S6301 before the I74 -->
                                                <para format="6301" loc="74"><!-- 09/02/2015 mharcourt XSLT 2.0 refactoring --><!--<xsl:text disable-output-escaping="yes">
&lt;BEL&gt;S6301
&lt;BEL&gt;I74&lt;BEL&gt;G2&lt;BEL&gt;T1</xsl:text>-->
                                                        <xsl:variable name="contents" as="node()"><!-- 09/28/2015 mharcourt elminate "trivial documents" by defining type -->
                                                                <xsl:value-of select="." />
                                                        </xsl:variable>
                                                        <!-- 09/02/2015 mharcourt XSLT 2.0 refactoring. Removed BEL coding from upcoming call to  
								gpo:rawRegexReplace and output it prior and subsequent to xls:value-of command. -->
                                                        <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                                                        <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                                                        <xsl:value-of select="gpo:rawRegexReplace(string($contents), '((\d+)(\[(.*)\])*)', '$1')" /><!--<xsl:value-of select="gpo:rawRegexReplace(string($contents), '((\d+)(\[(.*)\])*)', '&lt;BEL&gt;G1&lt;BEL&gt;T2$1&lt;BEL&gt;G2&lt;BEL&gt;T1')"/>-->
                                                        <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                                                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                                                </para>
                                                <!-- NB 6/16/2006 - If there is an action-dec, the Q20 should go after it, not this -->
                                                <xsl:if test="not(following-sibling::action/action-desc)">
                                                        <xsl:processing-instruction name="xpp">lp;&amp;20q</xsl:processing-instruction>
                                                </xsl:if>
                                        </xsl:when>
                                        <xsl:otherwise>
                                                <para format="S6654" loc="43"><!-- 09/02/2015 mharcourt XSLT 2.0 refactoring --><!--<xsl:text disable-output-escaping="yes">
&lt;BEL&gt;S6654</xsl:text>
							<xsl:text disable-output-escaping="yes">
&lt;BEL&gt;I43</xsl:text>-->
                                                        <xsl:value-of select="." />
                                                </para>
                                        </xsl:otherwise>
                                </xsl:choose>
                        </xsl:otherwise>
                </xsl:choose>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-form/official-title" priority="1" mode="process">
                <xsl:choose>
                        <xsl:when test="starts-with(.,'(title)')">
                                <para format="6652" loc="87">
                                        <xsl:apply-templates mode="process" />
                                </para>
                        </xsl:when>
                        <xsl:otherwise>
                                <para format="6654" loc="77">
                                        <xsl:apply-templates mode="process" />
                                </para>
                        </xsl:otherwise>
                </xsl:choose>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-instruction" mode="process">
                <xsl:if test=" text/pagebreak/following-sibling::text()">
                        <!--Need definition for Bell A -->
                        <para bellcode="A" />
                        <!--   <xsl:text disable-output-escaping="yes">
&lt;BEL&gt;A </xsl:text>-->
                </xsl:if>       
                <xsl:if test="(string-length(.) &gt; 0) or descendant-or-self::pagebreak">
                        <xsl:variable name="processedBlock" as="item()*">
                                <xsl:call-template name="hasPreviousAmendmentBlock">
                                        <xsl:with-param name="currentNode" select="." />
                                </xsl:call-template>
                        </xsl:variable>
                        <xsl:variable name="conferenceReportStyle" as="item()*">
                                <xsl:value-of select="gpo:GetConferenceReportStyle(.)" />
                        </xsl:variable>            
                        <xsl:variable name="toCallOutTheBillFormatOnDraftConfReport" as="item()*">
                                <xsl:call-template name="callOutAfternewPageOnConfReportDraft" />
                        </xsl:variable>
                        <xsl:choose>
                                <xsl:when test="$toCallOutTheBillFormatOnDraftConfReport = 'true' and not(//pre-form/legis-counsel )">
                                        <para format="6602" />
                                </xsl:when>
                                <xsl:when test="$toCallOutTheBillFormatOnDraftConfReport = 'true' ">
                                        <para bellcode="A" format="6602" />
                                        <!--  <xsl:text disable-output-escaping="yes">
&lt;BEL&gt;A</xsl:text>-->
                                </xsl:when>
                                <xsl:when test="$m_isCommitteeReport='Yes'">
                                </xsl:when>
                                <xsl:when test="$conferenceReportStyle='bill' ">
                                        <xsl:if test="@line-numbers='off' ">
                                             <xsl:attribute name="format">6301</xsl:attribute>
                                        </xsl:if>
                                        <xsl:if test="@line-numbers='on'  or not (@line-numbers)">
                                                <xsl:attribute name="format">6201</xsl:attribute>
                                        </xsl:if>
                                </xsl:when>				
                                <xsl:otherwise>
                                        <para format="6601" />
                                </xsl:otherwise>
                        </xsl:choose>
                        <para>
                        <xsl:choose>
                                <xsl:when test="$m_isCommitteeReport='Yes'">
                                        
                                </xsl:when>
                                <xsl:when test="$amendtype='engrossed-amendment' and not(enum) ">
                                        <xsl:attribute name="format">6201</xsl:attribute>               
                                </xsl:when>
                                <xsl:when test="@line-numbers='off' and  not($conferenceReportStyle='draft' or $conferenceReportStyle='committee')">
                                        <xsl:attribute name="format">6301</xsl:attribute>   
                                </xsl:when>                
                                <xsl:when test="not($amendtype='conference-report')">
                                        <xsl:value-of select="gpo:OutputForTOC()" />
                                </xsl:when>
                                <xsl:otherwise>
                                        <xsl:apply-templates mode="conference-report" select="." />
                                </xsl:otherwise>
                        </xsl:choose>
                        <xsl:choose>
                                <xsl:when test="$amendtype='conference-report' and ($conferenceReportStyle='draft' or $conferenceReportStyle='bill')">
                                        <xsl:attribute name="loc">21</xsl:attribute>
                                </xsl:when>            
                                <xsl:when test="$amendtype='engrossed-amendment' and not(enum) and not (@line-numbers='on') ">
                                        <xsl:attribute name="loc">13</xsl:attribute>
                                </xsl:when>
                                
                                <xsl:when test="$amendtype='engrossed-amendment' and not(enum) and  @line-numbers='on' ">
                                        <xsl:attribute name="loc">20</xsl:attribute>  
                                </xsl:when>              
                                <xsl:when test="$amendtype='engrossed-amendment' and enum">
                                        <xsl:attribute name="loc">20</xsl:attribute>
                                </xsl:when>
                                <xsl:when test="$m_isCommitteeReport='Yes' and (following-sibling::amendment-instruction or preceding-sibling::amendment-instruction) ">
                                        <xsl:attribute name="loc">20</xsl:attribute>  				
                                </xsl:when>				
                                <xsl:otherwise>
                                        <xsl:if test="not(text/@display-inline='no-display-inline')">	
                                                <xsl:attribute name="loc">20</xsl:attribute>  
                                        </xsl:if>
                                </xsl:otherwise>
                        </xsl:choose>         
                        <xsl:if test="enum">
                                <xsl:apply-templates select="amendment-instruction/enum" mode="process" />
                        </xsl:if>
                        <xsl:apply-templates mode="process" />
                        <xsl:choose>
                                <xsl:when test="/amendment-doc/@amend-type='conference-report'">
                                        <xsl:choose>
                                                <xsl:when test="@blank-lines-after">
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <xsl:with-param name="pvalue" select="@blank-lines-after" />
                                                        </xsl:call-template>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <xsl:with-param name="pvalue" select="1" />
                                                        </xsl:call-template>
                                                </xsl:otherwise>
                                        </xsl:choose>
                                </xsl:when>
                                <xsl:when test="not(/amendment-doc/@amend-type='house-amendment')">
                                        <xsl:choose>
                                                <xsl:when test="@blank-lines-after">
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <!-- <xsl:with-param name="pnode" select="'action-desc'"/>-->
                                                                <xsl:with-param name="pvalue" select="@blank-lines-after" />
                                                        </xsl:call-template>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                        <xsl:call-template name="getblank-lines-after">
                                                                <xsl:with-param name="pnode" select="4" />
                                                                <!-- <xsl:with-param name="pnode" select="'action-desc'"/>-->
                                                                <xsl:with-param name="pvalue" select="1" />
                                                        </xsl:call-template>
                                                </xsl:otherwise>
                                        </xsl:choose>
                                </xsl:when>
                                <xsl:otherwise>
                                        <xsl:if test="following-sibling::amendment-instruction or following-sibling::amendment-block or ../following-sibling::amendment ">
                                                <xsl:choose>
                                                        <xsl:when test="@blank-lines-after">
                                                                <xsl:call-template name="getblank-lines-after">
                                                                        <xsl:with-param name="pnode" select="4" />
                                                                        <!--<xsl:with-param name="pnode" select="'action-desc'"/>-->
                                                                        <xsl:with-param name="pvalue" select="@blank-lines-after" />
                                                                </xsl:call-template>
                                                        </xsl:when>
                                                        <xsl:otherwise>
                                                                <xsl:call-template name="getblank-lines-after">
                                                                        <xsl:with-param name="pnode" select="4" />
                                                                        <!--<xsl:with-param name="pnode" select="'action-desc'"/>-->
                                                                        <xsl:with-param name="pvalue" select="1" />
                                                                </xsl:call-template>
                                                        </xsl:otherwise>
                                                </xsl:choose>
                                                
                                        </xsl:if>
                                </xsl:otherwise>
                        </xsl:choose> 
                        </para>
                </xsl:if>        
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-instruction/text" mode="process">
                <xsl:apply-templates mode="process" />
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-instruction/enum" mode="process">
                <xsl:if test="parent::node()/@display-inline='yes-display-inline'  and local-name(../preceding-sibling::*[1])='text'   ">
                        <xsl:text> </xsl:text>
                </xsl:if>
                <xsl:variable name="Strlen" as="xs:integer">
                        <xsl:value-of select="string-length(.)-2" />
                </xsl:variable>
                
                <xsl:choose>
                        <xsl:when test="starts-with(.,'(')">
                                <xsl:text>【</xsl:text>
                                <xsl:value-of select="substring(.,2,$Strlen)" />
                                <xsl:text>】</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                                <xsl:apply-templates mode="process" />
                        </xsl:otherwise>
                </xsl:choose>
                
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="amendment-instruction/instruction-paragraph" mode="process">
                <xsl:variable name="noDot" as="xs:string?" />
                <xsl:variable name="node" select="." as="item()*" />
                <!-- BH:  The attribute 'sectionStyleOverlapped' was not called in the template so I set it to 'no'. -->
                <xsl:variable name="sectionStyleOverlapped" as="xs:boolean">false</xsl:variable>
                <xsl:variable name="style" as="item()*">
                        <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
                        <!--<xsl:call-template name="GetNearestAncestorStyleRecursive"/>-->
                </xsl:variable>
                <xsl:variable name="levelLocator" as="xs:string">
                        <xsl:call-template name="calculateLocator">
                                <xsl:with-param name="level">
                                        <xsl:text>paragraph</xsl:text>
                                </xsl:with-param>               
                        </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$levelLocator" />
                <xsl:if test="enum">
                        <xsl:if test="parent::section and parent::section/child::text[position()=1] and ../subsection[1] = . ">
                                <xsl:text> </xsl:text>
                        </xsl:if>
                        <xsl:apply-templates select="enum" mode="go" />
                        <xsl:if test="(header or text) and not(string(enum)='')">
                                <xsl:text> </xsl:text>
                        </xsl:if>
                </xsl:if>
                <xsl:if test="header">
                        <xsl:choose>
                                <xsl:when test="contains($levelLocator,'I20')  or contains(substring-before(.,' '),'&amp;') ">
                                        <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                </xsl:when>
                                <xsl:otherwise>
                                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                                </xsl:otherwise>
                        </xsl:choose>
                        <xsl:apply-templates select="header" mode="Special">
                                <xsl:with-param name="level" select="$levelLocator" />
                        </xsl:apply-templates>
                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                        <!--The getmdash function requires the $noDot variable.  In don't know what to send so I am sending a blank-->
                        <xsl:value-of select="gpo:getmdash($style, $noDot)" />
                        <!--<xsl:call-template name="getmdash">
                <xsl:with-param name="style" select="$style"/>
            </xsl:call-template>-->
                </xsl:if>
                <xsl:apply-templates mode="process" />
                <xsl:if test="boolean(/resolution and ancestor::preamble//whereas and not(following-sibling::paragraph))">
                        <xsl:processing-instruction name="xpp">lp;&amp;06q</xsl:processing-instruction>
                </xsl:if>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="attestation[ancestor::amendment-doc[not(@amend-type='engrossed-amendment')]]" mode="process">
               
                <para format="6201" loc="13">Attest:</para>
                <para format="6201" loc="14"><xsl:value-of select="descendant::attestation-group/role" /></para>
                <xsl:processing-instruction name="xpp">lp;&amp;60q</xsl:processing-instruction>  
                <para format="66514" loc="41">
                        <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction><xsl:value-of select="//congress" /></para>
                <para format="66514" loc="42">
                        <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction><xsl:value-of select="//session" /></para>
                <para format="66514" loc="43"><xsl:value-of select="$amend-num" /></para>
        </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="endorsement[ancestor::amendment-doc[not(@amend-type='engrossed-amendment')]]" mode="process">
                <para format="66514" loc="45">
                        <xsl:processing-instruction name="xpp">ff;3</xsl:processing-instruction>
                        <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                        <xsl:choose>
                                <xsl:when test="contains(//current-chamber, 'House')">HOUSE AMENDMENT TO SENATE AMENDMENT</xsl:when>
                                <xsl:when test="contains(//current-chamber, 'Senate')">SENATE AMENDMENT TO HOUSE AMENDMENT</xsl:when>
                                <xsl:otherwise />
                        </xsl:choose>
                        </para>
        </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" name="createHeader">
        <xsl:variable name="header" select="header" as="xs:string?" />
        <xsl:variable name="textCount" select="string-length(header)" as="xs:double" />
        <xsl:choose>
            <xsl:when test="name() = 'subsection'"><xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction></xsl:when>
            <xsl:when test="name() = 'paragraph'"><xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction></xsl:when>
            <xsl:when test="name() = 'subparagraph'"><xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction></xsl:when>
            <!--Issue #319 and #423 added space-->
            <xsl:when test="name() = 'clause'"><xsl:text> </xsl:text><xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction></xsl:when>
            <xsl:otherwise><xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction></xsl:otherwise>
        </xsl:choose>
        <xsl:choose>
            <xsl:when test="name() = 'subparagraph'">
                <!-- process the header text in Special mode to capture any necessary PIs and store the result
                    in a temporary tree (IMPORTANT: do not assign a data type to the variable below using the as attribute)
                    which is process in capFWHeader mode to preserve PIs and capitalize text appropriately -->
                <xsl:apply-templates select="header" mode="Special" />              
                <!--<xsl:apply-templates select="$headerInSpecial" mode="capFWHeader"/>-->
                <!--<xsl:sequence select="gpo:capFWHeader($headerInSpecial)"/>-->
                <!--<xsl:value-of select="upper-case(substring($header, 1, 1))"/>
                <xsl:value-of select="lower-case(substring($header, 2, $textCount))"/>-->
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                <xsl:text>.—</xsl:text>
            </xsl:when>
            <xsl:when test="name() = 'paragraph'">
                <!--Issue #104:  Missing mdash after header.-->
                <xsl:value-of select="upper-case(substring($header, 1, 1))" /><xsl:value-of select="lower-case(substring($header, 2, $textCount))" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><xsl:text>.—</xsl:text></xsl:when>
            <xsl:when test="name() = 'clause'">
                <!--Issue #104:  Missing mdash after header.-->
                <xsl:value-of select="upper-case(substring($header, 1, 1))" /><xsl:value-of select="lower-case(substring($header, 2, $textCount))" />
                <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><xsl:text>.—</xsl:text></xsl:when>
            <xsl:when test="name() = 'subsection'">
                <xsl:variable name="header">
                    <xsl:call-template name="FirstWordCapitalize">
                        <xsl:with-param name="header"><xsl:value-of select="header" /></xsl:with-param>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$header" /><xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><xsl:text>.—</xsl:text>
            </xsl:when>
            <!--Issue #319-->
            <xsl:when test="name() = 'clause'">
                <xsl:variable name="header">
                    <xsl:call-template name="FirstWordCapitalize">
                        <xsl:with-param name="header"><xsl:value-of select="header" /></xsl:with-param>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$header" /><xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction><xsl:text>.—</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="header" as="item()">
                    <xsl:call-template name="FirstWordCapitalize">
                        <xsl:with-param name="header"><xsl:value-of select="header" /></xsl:with-param>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:sequence select="$header" />
                <xsl:text>.</xsl:text><xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" name="createHyphenInHeader">
        <xsl:param name="string" />
        <xsl:variable name="first-word">
            <xsl:choose>
                <xsl:when test="contains($string, ' ')">
                    <xsl:value-of select="substring-before($string, ' ')" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$string" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="first-word-count" select="string-length($first-word)" as="xs:integer" />
        <xsl:variable name="modified-word" select="translate($first-word, '1234567890', '')" />
        <xsl:choose>
            <xsl:when test="string-length($modified-word) != $first-word-count and contains($first-word, '-')">
                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                <xsl:value-of select="substring-before($string, ' ')" />
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction><xsl:text> </xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="contains($string, ' ')">
                        <xsl:value-of select="substring-before($string, ' ')" /><xsl:text> </xsl:text>
                    </xsl:when>
                    <xsl:otherwise><!--(<xsl:value-of select="$modified-word"/>-<xsl:value-of select="$first-word"/>-
                            <xsl:value-of select="$first-word-count"/>)-->
                        <xsl:value-of select="$first-word" />
                    </xsl:otherwise>
                </xsl:choose>     
            </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="contains($string, ' ')">
            <xsl:call-template name="createHyphenInHeader">
                <xsl:with-param name="string" select="substring-after($string, ' ')" />
            </xsl:call-template>
        </xsl:if>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" name="FirstWordCapitalize">
        <xsl:param name="header" as="xs:string" />
        <xsl:variable name="length" select="string-length(.)" as="xs:double" />
        <xsl:variable name="CapitalizedHeader" as="text()*">
            <xsl:for-each select="tokenize($header, '\s+')">
                <xsl:variable name="text" select="." as="xs:string" />
                <xsl:choose>
                    <xsl:when test="$text='and' or $text='for' or $text='on' or $text='a' or $text='an' or $text='as' or $text='at' or $text='but' or $text='by'                          or $text='in' or $text='nor' or $text='of' or $text='or' or $text='to' or $text='the' or $text='etc'">
                        <xsl:value-of select="$text" />
                    </xsl:when>
                    <xsl:when test="string-length(translate(., 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', '')) = 0">
                        <xsl:value-of select="." />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="upper-case(substring(., 1, 1))" />
                        <xsl:value-of select="lower-case(substring(., 2, $length))" />
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:if test="position() != last()">
                    <xsl:text>  </xsl:text>
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>
        <!-- <xsl:if test="@display-inline='no-display-inline'">
            <xsl:call-template name="inlinehearedlocator"/>
        </xsl:if>-->
        <xsl:value-of select="$CapitalizedHeader" />  
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="header" mode="AllLower">
        <xsl:param name="insertPeriod" as="xs:string">No</xsl:param>
        
        <xsl:if test="@display-inline='no-display-inline' and (not(contains(local-name(parent::*), 'appropriations')             and $billtype='appropriations'))">
            <xsl:call-template name="inlinehearedlocator" />
        </xsl:if>
        <xsl:variable name="AligOrEth" as="xs:string?">
            <xsl:if test="contains(.,'Æ') or contains(.,'Ð')">
                <xsl:text>yes</xsl:text>
            </xsl:if>
        </xsl:variable>
        <xsl:variable name="fullHeader" as="xs:string">
            <xsl:for-each select="node()">
                <xsl:variable name="isLastNode" as="xs:string">
                    <xsl:choose>
                        <xsl:when test="last()">
                            <xsl:text>Yes</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>No</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:if test="not(local-name(.)='enum-in-header') and not (local-name(.) = 'superscript')">
                    <xsl:variable name="headerText" as="xs:string?">
                        <xsl:apply-templates select="." mode="process" />
                    </xsl:variable>
                    <xsl:value-of select="lower-case($headerText)" />
                    <xsl:if test="$isLastNode='No'">
                        <xsl:text> </xsl:text>
                    </xsl:if>
                </xsl:if>
                <xsl:if test="local-name(.)='enum-in-header' ">
                    <xsl:variable name="headerText" as="node()">
                        
                        <xsl:apply-templates select="." mode="process" />
                    </xsl:variable>
                    <xsl:value-of select="$headerText" />
                    <xsl:if test="$isLastNode='No'">
                        <xsl:text> </xsl:text>
                    </xsl:if>
                </xsl:if>
                <xsl:if test="local-name(.) = 'superscript'">
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    <xsl:variable name="headerText" as="node()">
                        
                        <xsl:apply-templates select="self::*" mode="process" />
                    </xsl:variable>
                    <xsl:value-of select="$headerText" />
                    <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$AligOrEth='yes' and contains(.,'Æ') ">
                <xsl:value-of select="$fullHeader" />
            </xsl:when>
            <xsl:when test="$AligOrEth='yes' and contains(.,'Ð') ">
                <xsl:value-of select="$fullHeader" />
            </xsl:when>
            <xsl:when test="contains($fullHeader,'&lt;bel&gt;g721') or contains($fullHeader,'&lt;bel&gt;g730')">
                <xsl:variable name="tempHeaderText" select="$fullHeader, '&lt;bel&gt;g721','&lt;?-- LXL code inserted Bel-g721 here. --&gt;'" as="xs:string" />
                
                <xsl:sequence select="replace($tempHeaderText, '&lt;bel&gt;g730', '&lt;?-- LXL code inserted Bel-g730 here. --&gt;')" />
                
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="string($fullHeader)" />
            </xsl:otherwise>
        </xsl:choose>
        <xsl:variable name="isLastCharPeriod" as="xs:string">
            <xsl:call-template name="lastCharPeriod" />
        </xsl:variable>
        
        <xsl:if test="$insertPeriod='Yes' and $isLastCharPeriod='no'">		
            <xsl:text>.</xsl:text>
        </xsl:if>
        <xsl:if test="not(following-sibling::text)">
            <xsl:call-template name="addClosingCharacterForChildElements" />
        </xsl:if>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="header" mode="subpart">
        <xsl:if test="@display-inline='no-display-inline'">
            <xsl:call-template name="inlinehearedlocator" />
        </xsl:if>
        <xsl:variable name="fullHeader" as="xs:string">
            <xsl:for-each select="node()">
                <xsl:variable name="isLastNode" as="xs:string">
                    <xsl:choose>
                        <xsl:when test="last()">
                            <xsl:text>Yes</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>No</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:if test="not(local-name(.)='enum-in-header')">
                    <xsl:variable name="headerText" as="node()">
                        <xsl:apply-templates select="." mode="process" />
                    </xsl:variable>
                    <xsl:value-of select="gpo:capICHeader(string($headerText))" />
                    <xsl:if test="$isLastNode='No'">
                        <xsl:text> </xsl:text>
                    </xsl:if>
                </xsl:if>
                <xsl:if test="local-name(.)='enum-in-header'">
                    <xsl:variable name="headerText" as="node()">
                        <xsl:apply-templates mode="process" />
                    </xsl:variable>
                    <xsl:variable name="surround" as="item()">
                        <xsl:call-template name="getEnumInHeaderEscape">
                            <xsl:with-param name="node" select=".." />
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:choose>
                        <xsl:when test="contains($surround,'-')">
                          <xsl:analyze-string select="$surround" regex="(K|T)(\d?)-(K|T)(\d?)">
                                <xsl:matching-substring>
                                    <xsl:choose>
                                        <xsl:when test="regex-group(1)='K'">
                                            <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:processing-instruction name="xpp">fv;<xsl:value-of select="normalize-space(regex-group(2))" /></xsl:processing-instruction>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                    <xsl:value-of select="string($headerText)" />
                                    <xsl:choose>
                                        <xsl:when test="regex-group(3)='K'">
                                            <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:processing-instruction name="xpp">fv;<xsl:value-of select="normalize-space(regex-group(4))" /></xsl:processing-instruction>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:matching-substring>
                            </xsl:analyze-string>
                        </xsl:when>
                        <xsl:otherwise>
                                  <xsl:value-of select="string($headerText)" />
                        </xsl:otherwise>
                    </xsl:choose>
                    <xsl:if test="$isLastNode='No'">
                        <xsl:text> </xsl:text>
                    </xsl:if>
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="string($fullHeader)" />
        <xsl:if test="not(following-sibling::text)">
            <xsl:call-template name="addClosingCharacterForChildElements" />
        </xsl:if>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="header" mode="InitialCaps">
        <xsl:param name="insertPeriod">No</xsl:param>
        <xsl:if test="(@display-inline='no-display-inline' or parent::rule) and (not (contains(local-name(parent::*), 'appropriations')             or $billtype='appropriations'))">
            <xsl:call-template name="inlinehearedlocator" />
        </xsl:if>
        <xsl:variable name="fullHeader" as="item()+">
            <xsl:for-each select="node()">
                <xsl:if test="local-name()='inline-comment'  and enum-in-header">
                    <xsl:text>❨</xsl:text>
                </xsl:if>
                <xsl:choose>
                    <xsl:when test="child::* and local-name()='inline-comment'  and enum-in-header">
                        <xsl:for-each select="node()">
                            <xsl:call-template name="collectFullHeaderInitCapDataByNode" />								
                        </xsl:for-each>						
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="collectFullHeaderInitCapDataByNode" />
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:if test="local-name()='inline-comment' and enum-in-header">
                    <xsl:text>❩</xsl:text>
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>
        <xsl:variable name="isLastCharPeriod" as="xs:string">
            <xsl:call-template name="lastCharPeriod" />
        </xsl:variable>
        <xsl:sequence select="$fullHeader" />
        <xsl:if test="$insertPeriod='Yes' and $isLastCharPeriod='no'">
            <xsl:text>.</xsl:text>
        </xsl:if>
        <!--TB 17Oct2007  #741-->
        <xsl:variable name="style" as="xs:string" select="gpo:GetNearestAncestorStyleRecursive(., true())" />
        <xsl:sequence select="gpo:getmdash($style, 'true')" />
        <xsl:if test="not(following-sibling::text)">
            <xsl:call-template name="addClosingCharacterForChildElements" />
        </xsl:if>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="header" mode="Sentence">
        <xsl:if test="@display-inline='no-display-inline' or  parent::rules-clause or parent::rules-paragraph ">
            <xsl:call-template name="inlinehearedlocator" />
        </xsl:if>
        <xsl:apply-templates mode="process" />
        <xsl:if test="not(following-sibling::text)">
            <xsl:call-template name="addClosingCharacterForChildElements" />
        </xsl:if>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="rules-clause-header" mode="AllLower">
        <xsl:if test="@display-inline='no-display-inline' or  parent::rules-clause ">
            <xsl:call-template name="inlinehearedlocator" />
        </xsl:if>
        
        <!--<xsl:apply-templates mode="process"/>-->
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="header" mode="process" /><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="subheader" mode="process" /><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="subheader" mode="AllLower">
        <xsl:variable name="inQuotedBlock" as="xs:string">
            <xsl:choose>
                <xsl:when test="ancestor::quoted-block">yes</xsl:when>
                <xsl:otherwise>no</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <para loc="74">
            <xsl:text>{{appropriation}}</xsl:text>
            <xsl:if test="parent::appropriations-small">
                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
            </xsl:if>
            
            <xsl:variable name="isCommented" as="xs:string">
                <xsl:choose>
                    <xsl:when test="./@commented='yes'">yes</xsl:when>
                    <xsl:otherwise>no</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="gpo:printOpeningAppropElementSymbol(., $isCommented, $inQuotedBlock, '')" />
            <xsl:apply-templates mode="AllLower" />
        </para>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="header" mode="Special" as="item()*">
        <xsl:param name="level" />
        <xsl:param name="insertPeriod">No</xsl:param>       
        <xsl:if test="@display-inline='no-display-inline'">
            <xsl:call-template name="inlinehearedlocator" />
        </xsl:if>
        <!--There is a special case that we need to keep certain text in there original case.  Those are the special characters [Alig and [Eth]-->
        <xsl:variable name="AligOrEth" as="xs:string">
            <xsl:choose>
                <xsl:when test="contains(.,'[Alig]') or contains(.,'[Eth]')">
                    <xsl:text>yes</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>no</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="inlin" as="xs:string" select="local-name(child::*[1])" />
        <xsl:variable name="inlintext" as="item()*" select="child::*" />
        <xsl:variable name="fullHeader">
            <xsl:for-each select="node()">
                <xsl:variable name="isLastNode" as="xs:string">
                    <xsl:choose>
                        <xsl:when test="last()">
                            <xsl:text>Yes</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>No</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:variable name="isFirstNode" as="xs:string">
                    <xsl:choose>
                        <xsl:when test="position() = 1">
                            <xsl:text>Yes</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>No</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:if test="not(local-name(.)='enum-in-header') and not (local-name(.)='superscript')">  
                    <xsl:variable name="headerText" as="item()*">
                        <xsl:choose>
                            <xsl:when test="self::text() and $isFirstNode='Yes' and starts-with(., ' ')">
                                <xsl:variable name="string">
                                    <xsl:value-of select="normalize-space(.)" />
                                </xsl:variable>
                                <xsl:value-of select="$string" />
                                <xsl:choose>
                                    <xsl:when test="following-sibling::*[1]/name() = 'enum-in-header'">
                                        <xsl:text> </xsl:text>
                                    </xsl:when>
                                    <xsl:otherwise />
                                </xsl:choose>
                            </xsl:when>
                            <xsl:when test="self::text()">
                                     <xsl:choose>
                                         <!--Issue #490 -->
                                    <xsl:when test="contains(., &quot;'&quot;)">
                                        <xsl:variable name="string-length" select="string-length(substring-before(., &quot;'&quot;))" as="xs:integer" />
                                        <xsl:variable name="begin-string" select="substring-before(., &quot;'&quot;)" as="xs:string" />
                                        <xsl:variable name="first-char" select="substring($begin-string, 1, 1)" as="xs:string" />
                                       <!-- <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>-->
                                        <xsl:value-of select="upper-case($first-char)" />
                                        <xsl:value-of select="substring($begin-string, 2, $string-length)" /><xsl:text>'</xsl:text>
                                        <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                                        <xsl:value-of select="substring-after(., &quot;'&quot;)" />
                                    </xsl:when>
                                    <xsl:otherwise>
                                    <xsl:value-of select="." />
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:when>
                            <xsl:otherwise>
                              <xsl:apply-templates select="." mode="process" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:choose>
                        <xsl:when test="$inlin='inline-comment'  and  starts-with($inlintext, translate($inlintext,'?@_%#!^*','?@_%#!^*')) ">
                            <xsl:value-of select="$headerText" />
                        </xsl:when>
                        <!--BH:  Not sure what this regex is supposed to do or is looking for so I am keeping the original code-->
                        <xsl:when test="local-name(../..)='subsection'">
                            <xsl:copy-of select="$headerText" />
                        </xsl:when>
                        <xsl:when test="../../paragraph/@indent='up1' ">
                            <xsl:copy-of select="$headerText" />
                        </xsl:when>
                        <xsl:when test="../../subparagraph/@indent='up2'">
                            <xsl:copy-of select="$headerText" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:copy-of select="$headerText" />
                        </xsl:otherwise>
                    </xsl:choose>
                    <xsl:if test="$isLastNode='No'">
                        <xsl:text> </xsl:text>
                    </xsl:if>
                </xsl:if>
                <xsl:if test="local-name(.)='enum-in-header' ">
                    <xsl:variable name="headerText" as="xs:string">
                        <xsl:apply-templates mode="process" />
                    </xsl:variable>
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    <xsl:value-of select="string($headerText)" />
                    <xsl:if test="$isLastNode='No'">
                        <xsl:text> </xsl:text>
                    </xsl:if>
                    <xsl:choose>
                        <xsl:when test="local-name(..)='subsection'">
                            <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise>
                           <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>		              
                <xsl:if test="local-name(.)='superscript'">
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    <xsl:variable name="headerText" as="item()*">
                        <xsl:apply-templates select="self::*" mode="process" />
                    </xsl:variable>
                    <xsl:sequence select="$headerText" />
                    <xsl:if test="$isLastNode='No'">
                        <xsl:text> </xsl:text>
                    </xsl:if>
                    <xsl:choose>
                        <xsl:when test="local-name(..)='subsection'">
                            <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:otherwise>
                           <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>
        <xsl:choose>
            <!--this handles the case when parent is subsection and the we are dealing with the word that contains an ampersand.  We will have to blow in a T5 after word with the ampersand...CD...4-4-05-->
            <xsl:when test="$fullHeader = ''">
                <!-- TB 24June2009 empty lines fixinf -->
                <!-- nothing -->
            </xsl:when>
            <xsl:when test="parent::subsection                      or (parent::paragraph and parent::paragraph/@indent='up1')                                or (parent::subparagraph and parent::subparagraph/@indent='up2')                                or (parent::clause and parent::clause/@indent='up3')                                or (parent::subclause and parent::subclause/@indent='up4')                                or (parent::item and parent::item/@indent='up5')                                or (parent::subitem and parent::subitem/@indent='up6')">
                <xsl:choose>
                    <xsl:when test="$amendtype='conference-report'">
                        <xsl:value-of select="gpo:capICHeader($fullHeader)" />
                    </xsl:when>					
                    <xsl:otherwise>
                        <!-- TA: commented out because it's outputting twice -->
                        <!--<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>-->
                        <!--<xsl:value-of select="gpo:capitalize(.)"/>-->
                        <!--<xsl:value-of select="gpo:capICHeader($fullHeader)"/>-->
                        <xsl:variable name="transformedHeader" as="xs:string?" select="gpo:capICHeader($fullHeader)" />
                        <xsl:for-each select="tokenize($transformedHeader, '\s+')">
                            <xsl:choose>
                                <xsl:when test="matches(., &quot;(’|')&quot;) and position()=1">
                                    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                    <xsl:value-of select="." />
                                   <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                                </xsl:when>
                                <xsl:when test="matches(., &quot;(’|')&quot;)">
                                    <xsl:analyze-string select="." regex="(’|')">
                                        <xsl:matching-substring>
                                            <xsl:text>’</xsl:text>
                                            <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                                            <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                        </xsl:matching-substring>
                                        <xsl:non-matching-substring>
                                            <xsl:value-of select="." />
                                        </xsl:non-matching-substring>
                                    </xsl:analyze-string>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="." />
                                </xsl:otherwise>
                            </xsl:choose>
                            <xsl:if test="position() != last()"><xsl:text> </xsl:text></xsl:if>
                        </xsl:for-each>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
             <xsl:when test="$amendtype='conference-report'">
                 <xsl:value-of select="gpo:capitalize(.)" />
             </xsl:when>
            <xsl:when test="../../paragraph/@indent='up1' or ../../subparagraph/@indent='up2'">
              <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                <xsl:for-each select="$fullHeader/node()">
                    <xsl:choose>
                        <xsl:when test="self::text() and matches(., &quot;(’|')&quot;)">
                            <xsl:for-each select="tokenize(., '\s+')">
                                <xsl:choose>
                                    <xsl:when test="matches(., &quot;(’|')&quot;) and position()=1">
                                        <xsl:processing-instruction name="xpp" select="'fv;5'" />
                                        <xsl:value-of select="." />
                                     <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                                    </xsl:when>
                                    <xsl:when test="matches(., &quot;(’|')&quot;)">
                                        <xsl:analyze-string select="." regex="(’|')">
                                            <xsl:matching-substring>
                                                <xsl:text>’</xsl:text>
                                                <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                                                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                            </xsl:matching-substring>
                                            <xsl:non-matching-substring>
                                                <xsl:value-of select="." />
                                            </xsl:non-matching-substring>
                                        </xsl:analyze-string>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="." />
                                    </xsl:otherwise>
                                </xsl:choose>
                                <xsl:if test="position() != last()"><xsl:text> </xsl:text></xsl:if>
                            </xsl:for-each>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:sequence select="." />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:when>
            <!-- TB 15Oct2007 the commented logic removed. For review see revision #425 of version control -->
            <xsl:when test="$inlin='inline-comment'  and  starts-with($inlintext, translate($inlintext,'?@_%#!^*','?@_%#!^*')) ">
                <xsl:sequence select="$fullHeader" />
            </xsl:when>
            <xsl:otherwise>
                <!-- do not use an as attribute on this variable. The variable contains
                   a mixture of PIs and text so we need to create a temporary tree that 
                   we can process in capFWHeader mode -->
                <xsl:variable name="transformedHeader">
                    <xsl:copy-of select="gpo:capFWHeader($fullHeader)" />
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="$AligOrEth='yes' and contains($transformedHeader,'[alig]') ">
                        <xsl:sequence select="$transformedHeader" />
                    </xsl:when>
                    <xsl:when test="$AligOrEth='yes' and contains($transformedHeader,'[eth]') ">
                        <xsl:sequence select="$transformedHeader" />
                    </xsl:when>
                    <xsl:otherwise>
                  <!--  BH: Removing this because it was outputting 2x
                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>-->
                        <xsl:if test="starts-with(., ' ')">
                            <xsl:text> </xsl:text>
                        </xsl:if>
                        <xsl:for-each select="$transformedHeader/node()">
                            <xsl:choose>
                                <xsl:when test="self::text() and contains(., 'U.S.')">
                                    <xsl:call-template name="addPIforUSinHeader" />
                                </xsl:when>
                                <!-- fixes issue #547; added self::text() so that the rs-font PI is not processed here -->
                                <xsl:when test="self::text() and contains(., '-')">
                                    <xsl:call-template name="addPIforHypheninHeader" />
                                </xsl:when>
                                <xsl:when test="self::text()">
                                    <xsl:for-each select="tokenize(., '\s+')">
                                        <xsl:choose>
                                            <xsl:when test="position() = 1 and matches(., '^[A-Z]+$')">
                                                <xsl:value-of select="." />
                                            </xsl:when>
                                            <xsl:when test="position() = 1 and matches(., '^([0-9]+)(%?)$')">
                                                <xsl:analyze-string select="." regex="^([0-9]+)(%?)$">
                                                    <xsl:matching-substring>
                                                        <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                                        <xsl:value-of select="regex-group(1)" />
                                                        <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                                                      <xsl:value-of select="regex-group(2)" />
                                                    </xsl:matching-substring>
                                                    <xsl:non-matching-substring>
                                                        <xsl:value-of select="." />
                                                    </xsl:non-matching-substring>
                                                </xsl:analyze-string>
                                            </xsl:when>
                                            <!--BH:  Issue #504. This was causing duplicate PI's.  I cannot find a reason for 'gpo:isNumeric' and can't find it in the
                                                legacy code. We can revisit if we find something is being processed correctly.-->
                                           <!-- <xsl:when test="position() = 1 and (upper-case(.) = . and (not(contains(., '-') and gpo:isNumeric(.))))">
                                                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                                <xsl:value-of select="."/>
                                                <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                                            </xsl:when>-->
                                            <xsl:when test="matches(., &quot;(’|')&quot;) and position()=1">
                                                <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                                                <xsl:value-of select="." />
                                                <xsl:if test="not(contains(., &quot;'&quot;))">
                                              <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                                                </xsl:if>
                                            </xsl:when>
                                            <xsl:when test="matches(., &quot;(’|')&quot;)">
                                                <xsl:analyze-string select="." regex="(’|')">
                                                    <xsl:matching-substring>
                                                        <xsl:text>’</xsl:text>
                                                        <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                                                       <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
                                                    </xsl:matching-substring>
                                                    <xsl:non-matching-substring>
                                                        <xsl:value-of select="." />
                                                    </xsl:non-matching-substring>
                                                </xsl:analyze-string>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:value-of select="." />
                                            </xsl:otherwise>
                                        </xsl:choose>
                                        <xsl:if test="position() != last()"><xsl:text> </xsl:text></xsl:if>
                                    </xsl:for-each>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:copy-of select="." />
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:for-each>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:variable name="isLastCharPeriod" as="xs:string">
            <xsl:call-template name="lastCharPeriod" />
        </xsl:variable>	
        <xsl:if test="$insertPeriod='Yes' and $isLastCharPeriod='no'">		
            <xsl:text>.</xsl:text>
        </xsl:if>
        <xsl:if test="not(following-sibling::text)">
            <xsl:call-template name="addClosingCharacterForChildElements" />
        </xsl:if>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" name="addPIforUSinHeader">
            <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
            <xsl:value-of select="substring-before(., 'U.S.')" />
            <xsl:text>U.S.</xsl:text>
            <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
        <xsl:value-of select="substring-after(., &quot;U.S.&quot;)" />  
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" name="addPIforHypheninHeader">
                <xsl:for-each select="tokenize(., ' ')">
                    <xsl:choose>
                        <xsl:when test="contains(., '-') and (contains(., '1') or contains(., '2') or contains(., '3') or contains(., '4')                             or contains(., '5') or contains(., '6') or contains(., '7') or contains(., '8')                             or contains(., '9') or contains(., '0'))">
                            <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                            <xsl:value-of select="." />
                            <xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction><xsl:text> </xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                        <xsl:value-of select="." />
                            <xsl:if test="not(position() = last())">
                                <xsl:text> </xsl:text>
                            </xsl:if>
                                </xsl:otherwise>
                    </xsl:choose>           
                </xsl:for-each>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="header" mode="FirstWord">
        <xsl:if test="@display-inline='no-display-inline'">
            <xsl:call-template name="inlinehearedlocator" />
        </xsl:if>
        <xsl:variable name="fullHeader" as="xs:string">
            <xsl:for-each select="node()">
                <xsl:variable name="isLastNode" as="xs:string">
                    <xsl:choose>
                        <xsl:when test="last()">
                            <xsl:text>Yes</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>No</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:if test="not(local-name(.)='enum-in-header')">
                    <xsl:variable name="headerText" as="xs:string">
                        <xsl:apply-templates select="." mode="process" />
                    </xsl:variable>
                    <xsl:value-of select="$headerText" />
                    <xsl:if test="$isLastNode='No'">
                        <xsl:text> </xsl:text>
                    </xsl:if>
                </xsl:if>
                <xsl:if test="local-name(.)='enum-in-header'">
                    <xsl:variable name="headerText" as="xs:string">
                        <xsl:apply-templates mode="process" />
                    </xsl:variable>
                    <xsl:value-of select="gpo:capitalize(.)" />
                   <!-- <xsl:value-of disable-output-escaping="yes"
                        select="lexa:escapeWithBelKandBelT4(string($headerText),'([0-9]*\([a-zA-Z0-9]+\)*)')"/>-->
                    <xsl:if test="$isLastNode='No'">
                        <xsl:text> </xsl:text>
                    </xsl:if>
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>
        <xsl:value-of select="gpo:capitalize(.)" />
       <!-- <xsl:value-of disable-output-escaping="yes"
            select="lexa:escapeWithBelKandBelT4(lexa:capFWHeader(string($fullHeader)),'^([0-9]+)')"/>-->
        <xsl:if test="not(following-sibling::text)">
            <xsl:call-template name="addClosingCharacterForChildElements" />
        </xsl:if>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="header" mode="AllCaps">
        <xsl:param name="insertPeriod">No</xsl:param>
        
        <xsl:if test="@display-inline='no-display-inline' and (not (contains(local-name(parent::*), 'appropriations') and $billtype='appropriations'))">
            <xsl:call-template name="inlinehearedlocator" />
        </xsl:if>
        
        <xsl:variable name="AligOrEth">
            <xsl:if test="contains(.,'[Alig]') or contains(.,'[Eth]')">
                <xsl:text>yes</xsl:text>
            </xsl:if>
        </xsl:variable>
        <!--BH:  This is not typed because there are problems later in the template.  I have tried string, item() 
            and node() - all cause issues. Need to cast the variable as a string. --> 
        <xsl:variable name="fullHeader">
            <xsl:for-each select="node()">	
                <xsl:if test="local-name()='inline-comment' and enum-in-header">
                    <xsl:text>❨</xsl:text>
                </xsl:if>
                <xsl:choose>					
                    <xsl:when test="child::*  and local-name()='inline-comment'  and enum-in-header">
                        <xsl:for-each select="node()">
                            <xsl:call-template name="collectFullHeaderDataByNode" />								
                        </xsl:for-each>						
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="collectFullHeaderDataByNode" />
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:if test="local-name()='inline-comment'  and enum-in-header">
                    <xsl:text>❩</xsl:text>
                </xsl:if>
            </xsl:for-each>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$AligOrEth='yes' and contains(.,'[Alig]')">
                <xsl:value-of select="concat(substring-before($fullHeader,'['),'[Alig]',substring-after($fullHeader,']'))" />
            </xsl:when>
            <xsl:when test="$AligOrEth='yes' and contains(.,'[Eth]')">
                <xsl:value-of select="concat(substring-before($fullHeader,'['),'[Eth]',substring-after($fullHeader,']'))" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <!--if we have an enum-in-header, this needs to be lowercase-->
                    <xsl:when test="(parent::title or parent::section) and child::enum-in-header and contains($fullHeader,'(') and contains($fullHeader,')')">
                        <xsl:value-of select="$fullHeader" />
                        <xsl:if test="../parent::section and  @vbattChangedForReported='strikethrough'">
                            <xsl:apply-templates mode="process" />
                            <para format="6401" />
                        </xsl:if>
                    </xsl:when>
                    <xsl:otherwise>
                        <!-- fixes issue #102 -->
                        <xsl:value-of select="string(normalize-space($fullHeader))" />			
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:variable name="isLastCharPeriod" as="xs:string">
            <xsl:call-template name="lastCharPeriod" />
        </xsl:variable>	
        <xsl:choose>
            <!--Issue #493-->
            <xsl:when test="parent::section"><xsl:text>.</xsl:text></xsl:when>
            <xsl:when test="$insertPeriod='Yes' and $isLastCharPeriod='no'">
                <xsl:text>.</xsl:text>
            </xsl:when>
        </xsl:choose>
       
        <xsl:if test="not(following-sibling::text)">
            <xsl:call-template name="addClosingCharacterForChildElements" />
        </xsl:if>
        <!-- fixes issue #199 -->
        <xsl:if test="local-name(following::*[1]) = 'after-quoted-block'">
            <xsl:if test="not(following::after-quoted-block/@display = 'no') and not(*/enum) and not(*/header)                 and not(*/text) and not(ancestor::quoted-block/descendant::continued-test)">
                <xsl:call-template name="QuotedBlockNestingEnd" />
                
                <xsl:value-of select="following::*[1]" />
                
                <xsl:call-template name="addClosingCharacterForChildElements">
                    <xsl:with-param name="source">
                        <xsl:text>afterQuotedBlock</xsl:text>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:if>
        </xsl:if>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="header" mode="inline">
        <xsl:apply-templates mode="process" />
        <!--Issue #415-->
        <xsl:choose>
            <xsl:when test="ancestor::quoted-block and not(following-sibling::text) and                  (not(../*/enum) or not(../*/text) and not(../*/header) and                 not(following-sibling::text) and not(ancestor::quoted-block/continuation-text))">
                <xsl:text>”</xsl:text><xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
            </xsl:when>
            <xsl:otherwise />
        </xsl:choose>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" name="XXXgetInlineHeaderStyle">
        <!-- <xsl:param name="node" as="element()"/>
        <xsl:param name="returnval" as="xs:string"/>-->
        <xsl:param name="returnval" />
        <!--BH:  need a fall-thru for @vattGrid-->	
        <xsl:variable name="attGrid">
            <xsl:choose>
                <xsl:when test="@vbattGrid">
                    <xsl:value-of select="@vbattGrid" />
                </xsl:when>
                <xsl:otherwise>G2</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="attType" as="xs:string">
            <!--BH:  Added a choose because the input file did not have any @vbattTypeface attributes-->
            <xsl:choose>
                <xsl:when test="@vbattTypeface">
                    <xsl:value-of select="@vbattTypeface" />
                </xsl:when>
                <xsl:otherwise>
                    No attribute vbattTypeface
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable> 
        <xsl:variable name="attMode" as="xs:string">
            <!--BH:  Added a choose because the input file did not have any @vbattMode attributes-->
            <xsl:choose>
                <xsl:when test="@vbattMode">
                    <xsl:value-of select="@vbattMode" />
                </xsl:when>
                <xsl:otherwise>
                    No attribute vbattMode
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:variable name="typefaceAndMode" as="xs:string">
            <!--BH Not sure what goes here-->
            <xsl:choose>
                <xsl:when test="not($attGrid='' or $attGrid=' ')">
                    <!--<xsl:text>&lt;BEL&gt;</xsl:text>-->
                    <para>
                        <xsl:attribute name="format">
                            <xsl:value-of select="$attGrid" />
                        </xsl:attribute>
                        <xsl:text>|</xsl:text>
                    </para>
                </xsl:when>
                <xsl:when test="not($attType='' or $attType=' ')">
                    <!--<xsl:text>&lt;BEL&gt;</xsl:text>-->
                    <para>
                        <xsl:attribute name="format">
                            <xsl:value-of select="$attType" />
                        </xsl:attribute>
                        <xsl:text>|</xsl:text>
                    </para>
                </xsl:when>
                <xsl:when test="not($attMode='' or $attMode=' ')">
                    <para>
                        <xsl:attribute name="format">
                            <xsl:value-of select="$attMode" />
                        </xsl:attribute>
                    </para>
                </xsl:when>
                <xsl:otherwise><xsl:comment>'typefaceAndMode' not set.</xsl:comment></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:sequence select="if ($returnval='typeface') then substring-before($typefaceAndMode, '|')             else if ($returnval='mode') then substring-after($typefaceAndMode,'|')             else 'UnknownTypefaceOrMode'" />
        
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" name="collectFullHeaderDataByNode">		
        <xsl:variable name="isLastNode">
            <xsl:choose>
                <xsl:when test="last()">
                    <xsl:text>Yes</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>No</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>		
        <xsl:if test="not(local-name(.)='enum-in-header') and not (local-name(.) = 'superscript')">	
            <xsl:variable name="headerTextApplied">
                <!--<xsl:value-of select="upper-case(.)"/>-->
                <xsl:apply-templates select="." mode="process" />
            </xsl:variable>
            <xsl:variable name="headerText">
                <xsl:value-of select="upper-case($headerTextApplied)" />
            </xsl:variable>
            <!-- TASSOS: we use a nbspace as a separator; Deb uses space. per Joel use space to match Deb's -->
            <!-- <xsl:text>&#160;</xsl:text> -->
            <xsl:text> </xsl:text>
            <xsl:value-of select="$headerText" />
            <xsl:if test="$isLastNode='No'">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:if>					
        <xsl:if test="local-name(.)='enum-in-header'  or local-name(.) = 'superscript' ">
            <xsl:variable name="headerText">
                <xsl:call-template name="runSpecialCharsExcEnumInHeader" />
            </xsl:variable>
            <xsl:value-of select="$headerText" />
            <xsl:if test="$isLastNode='No'">
                <xsl:text> </xsl:text>
            </xsl:if>					
        </xsl:if>					
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" name="collectFullHeaderInitCapDataByNode">
        <xsl:variable name="isLastNode" as="xs:string">
            <xsl:choose>
                <xsl:when test="last()">
                    <xsl:text>Yes</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>No</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:if test="not(local-name(.)='enum-in-header') and not(local-name(.)='superscript')">
            <!--Issue #307.  The datatype was causing issues.  I couldn't resolve the issues so 
        have removed the datatype until we can solve this type of problem.-->
            <xsl:variable name="headerText">
                <xsl:apply-templates select="." mode="process" />
            </xsl:variable>
            <xsl:choose>
                <xsl:when test="substring($headerText/text(), 1, 1) != ' ' and preceding-sibling::enum-in-header">
                    <xsl:value-of select="$headerText" />
                </xsl:when>
                <xsl:otherwise>
                    <!-- <xsl:value-of select="gpo:capitalize($headerText)"/>-->
                    <xsl:sequence select="gpo:capICHeader($headerText)" />
                </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="$isLastNode='No'">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:if>
        <xsl:if test="local-name(.)='enum-in-header' or local-name(.)='superscript'">
            <xsl:variable name="headerText" as="item()+">
                <xsl:call-template name="runSpecialCharsExcEnumInHeader" />
            </xsl:variable>
            <xsl:variable name="surround" as="xs:string">
                <xsl:call-template name="getEnumInHeaderEscape">
                    <xsl:with-param name="node" select=".." />
                </xsl:call-template>
            </xsl:variable>
            <xsl:choose>
                <!--Issue #300 PI for enum-in-header for subsection-->  
                <xsl:when test="parent::header[parent::subsection]">
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    <xsl:apply-templates mode="process" />
                    <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="contains($surround,'-')">
                    <!--BH:  Need to refactor this once we understand what it is doing-->
                    <!-- <xsl:text disable-output-escaping="yes">&lt;BEL&gt;</xsl:text>-->
                    <para> 
                        <xsl:value-of select="substring-before($surround,'-')" />
                    </para>
                    <xsl:sequence select="$headerText" />
                    <!--<xsl:text disable-output-escaping="yes">&lt;BEL&gt;</xsl:text>-->
                    <para>
                        <xsl:value-of select="substring-after($surround,'-')" />
                    </para>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="string($headerText)" />
                </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="$isLastNode='No'">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:if>
    </xsl:template><xsl:output xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" method="xml" indent="yes" /><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" match="engrossed-amendment-body/section[@section-type='resolved']" mode="process">
        <para loc="04">
            <!--Issue #67-->
             <xsl:text>  </xsl:text>
             <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>
            <xsl:text>Resolved,</xsl:text>
            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
           <xsl:apply-templates select="text" mode="inline" />
           </para>
        <xsl:if test="//engrossed-amendment-body/section[@section-type='resolved'][last()] = self::*">     
            <para format="6652" loc="29">
        <xsl:choose>           
                <xsl:when test="string-length(//legis-type) &gt;23" />
                <xsl:otherwise>
                        <xsl:processing-instruction name="xpp">fv;3</xsl:processing-instruction>            
                </xsl:otherwise>
            </xsl:choose>    
            <xsl:value-of select="upper-case(//engrossed-amendment-form/legis-type)" />
                <xsl:if test="not(//engrossed-amendment-body/section[@section-type='resolved'][last()] = self::*)">
                    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
        </xsl:if>
            </para>
        </xsl:if>
        
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" match="attestation[ancestor::amendment-doc[@amend-type='engrossed-amendment']]" mode="process"> 
        <xsl:choose>
            <xsl:when test="//preamble">
                <para format="6300">
                </para>               
            </xsl:when>
            <xsl:otherwise>
                <para format="6201">
                </para>  
            </xsl:otherwise>
        </xsl:choose>  
        <para loc="13">
            <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
            <xsl:text>Attest:</xsl:text>
            
         </para>
        <para loc="14">
        
            <xsl:processing-instruction name="xpp">lp;&amp;60q</xsl:processing-instruction>  
        <xsl:value-of select="attestation-group/role" />
          
        
        <xsl:if test="not(contains(./attestation-group/role,'.'))">
            <xsl:text>.</xsl:text>
        </xsl:if>
              </para>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" match="endorsement[ancestor::amendment-doc[@amend-type='engrossed-amendment']]" mode="process">
        <para format="66514" loc="41">
            <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
            <xsl:value-of select="ancestor::amendment-doc/engrossed-amendment-form/congress" />
        </para>
        <para format="66514" loc="42">
            <xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
          <xsl:value-of select="ancestor::amendment-doc/engrossed-amendment-form/session" />
        </para>
        <para format="66514" loc="43"><xsl:value-of select="upper-case(substring-before(substring-after(normalize-space(//engrossed-amendment-body/section[1]/text),'('),')'))" /></para>
            <para format="66514" loc="44" />
            <para format="66514" loc="45">AMENDMENT</para>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" match="engrossed-amendment-form" mode="process">
        <!--xsl:call-template name="displayI90ForAll"/-->
        <xsl:call-template name="PrintStarAndI90LineForEngrAmend" />
            <xsl:apply-templates select="distribution-code" mode="process" />
        <para loc="02"><xsl:value-of select="//current-chamber" /></para>
       
        <para loc="03">
            <xsl:choose>
                <!--Issue #62 - Error was occurring when there are 2 or more action-date elements.-->
                <xsl:when test="count(descendant::action-date) &gt; 1">
                    <xsl:variable name="contents"> <xsl:value-of select="normalize-space(action[@display='yes'][1]/action-date)" /></xsl:variable>
                    <xsl:choose>
                        <xsl:when test="ends-with($contents, '.')"><xsl:value-of select="$contents" /></xsl:when>
                        <xsl:otherwise><xsl:value-of select="$contents" /><xsl:text>.</xsl:text></xsl:otherwise>
                    </xsl:choose>
                </xsl:when> 
                <!--Issue #51 - fixed extra period in action-date-->
                <xsl:when test="ends-with(descendant::action-date, '.')"><xsl:value-of select="normalize-space(//action-date)" /></xsl:when>
            <xsl:otherwise><xsl:value-of select="descendant::action-date" />.</xsl:otherwise></xsl:choose>
        </para>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="PrintStarAndI90LineForEngrAmend">
        <xsl:call-template name="displayI90ForAll" />
      
        <xsl:choose>
            <xsl:when test="not(/amendment-doc/@star-print)">
                <!-- Nothing -->
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print and not(/amendment-doc/@star-print='no-star-print')">
                <!-- Bug #471 - NB 1/16/2007 - The number of stars is now needed for 
                    more than just printing. So rather than simply outputting the 
                    number, we will store it in a variable, output it, and then use 
                    that number to get the Star string --> 
                <xsl:variable name="starCount">
                    <xsl:call-template name="starPrintForEngrAmedment" />
                </xsl:variable>
                <xsl:value-of select="$starCount" />
                <xsl:variable name="starString">
                    <xsl:value-of select="gpo:getStarString($starCount)" />
                   <!-- <xsl:call-template name="getStarString">
                        <xsl:with-param name="count">
                            <xsl:value-of select="$starCount"/>
                        </xsl:with-param>
                    </xsl:call-template>-->
                </xsl:variable>
                <xsl:text>S</xsl:text>
               <xsl:variable name="currCham">
                   <xsl:value-of select="//current-chamber" />
               </xsl:variable>
                <xsl:choose>
                    <xsl:when test="contains($currCham, 'Senate')">
                        <para loc="91">
                            <xsl:processing-instruction name="xpp">ff;6; fv;1</xsl:processing-instruction>
                        </para>
                        <xsl:value-of select="$starString" />
                       
                            <xsl:processing-instruction name="xpp">K(Star Print); </xsl:processing-instruction>
                      <!--  K(Star Print) what is the character replacement for start print?? SY 1/26/2016-->
                       <!-- <xsl:text disable-output-escaping="yes">&lt;BEL&gt;K(Star Print)&lt;ASC24&gt;</xsl:text>-->
                    </xsl:when>
                    <xsl:otherwise>
                        <para loc="91">
                            <xsl:processing-instruction name="xpp">ff;6; fv;1</xsl:processing-instruction>
                        </para>
                        
                        <xsl:value-of select="$starString" />
                        <xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
                        <!--Issue #67-->
                        <xsl:text> </xsl:text>
                        <!--<xsl:processing-instruction name="xpp">&#x2003;</xsl:processing-instruction>-->
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <!--Issue #67-->
                <xsl:text> </xsl:text>
               <!-- <xsl:processing-instruction name="xpp">&#x2003;</xsl:processing-instruction>-->
                </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="starPrintForEngrAmedment">
        <xsl:choose>
            <!-- NB MODIFICATION 5/9/2006 - added resolution to all tests -->
            <xsl:when test="/amendment-doc/@star-print='first-star-print' ">
                <xsl:text>1</xsl:text>
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print='second-star-print' ">
                <xsl:text>2</xsl:text>
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print='third-star-print' ">
                <xsl:text>3</xsl:text>
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print='fourth-star-print' ">
                <xsl:text>4</xsl:text>
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print='fifth-star-print' ">
                <xsl:text>5</xsl:text>
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print='sixth-star-print' ">
                <xsl:text>6</xsl:text>
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print='seventh-star-print'">
                <xsl:text>7</xsl:text>
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print='eigthth-star-print' ">
                <xsl:text>8</xsl:text>
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print='ninth-star-print' ">
                <xsl:text>9</xsl:text>
            </xsl:when>
            <xsl:when test="/amendment-doc/@star-print='tenth-star-print' ">
                <xsl:text>10</xsl:text>
            </xsl:when>
          
        </xsl:choose>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" match="amendment-doc[@amend-type='engrossed-amendment']" mode="process">    
      <amendment-doc>
        <xsl:copy-of select="@*" />
          <para format="6652" />
        <xsl:if test="contains(//current-chamber,'Senate')">                
        
        <xsl:variable name="engSec">
            <xsl:value-of select="string-length(//engrossed-amendment-body/section) div 57" />
        </xsl:variable>
        <xsl:variable name="engform">
            <xsl:value-of select=" count(//engrossed-amendment-form/current-chamber) +                   count(//engrossed-amendment-form/action/action-date) +  count(//engrossed-amendment-form/legis-type)" />           
                </xsl:variable>
            
        <xsl:variable name="amdins">
            <xsl:value-of select="string-length(//amendment/amendment-instruction/text[1]) div 55" />
        </xsl:variable>
            
                
                <xsl:choose>

                    <xsl:when test="/amendment-doc/@amend-type='engrossed-amendment'">
                      
                        <xsl:if test="(/amendment-doc/@public-print='yes' and contains(//current-chamber,'Senate')) or $amendstage='printed-as-passed'">
                            
                                <xsl:if test="//engrossed-amendment-form/action[position()=last()]/action-date">
                                    <para loc="51">
   
                                    <xsl:value-of select="//engrossed-amendment-form/action[position()=last()]/action-date" />
                                    </para>
                                </xsl:if>
                                <xsl:if test="//engrossed-amendment-form/action[position()=last()]/action-desc">
                                    <para loc="51">
                                        <xsl:processing-instruction name="xpp">lp;&amp;51q</xsl:processing-instruction>
                                    
                                    <xsl:value-of select="//engrossed-amendment-form/action[position()=last()]/action-desc" />
                                    </para>
                                </xsl:if>
                     
                        </xsl:if>
                        
                       <!-- <xsl:value-of select="gpo:officialTitleSpace('10')"/>-->
                    </xsl:when>

                    <xsl:when test="/amendment-doc/@amend-type='engrossed-amendment'">
                       <!-- <xsl:value-of select="gpo:officialTitleSpace('10')"/>-->
                        
                    </xsl:when>
                    <xsl:when test="$m_isShortTitle='Yes'">     
                <xsl:if test="//title">                                               
                              <!--<xsl:value-of select="gpo:officialTitleSpace(string($engSec+$amdins+$engform+
                                (((string-length(//title/enum)+ string-length(//title/header)+1))div 20) +
                                  ((string-length(//title/section/enum)+string-length(//title/section/header)+string-length(//title/section/text)) div 50)))"/>-->     
                            </xsl:if>
                    </xsl:when>
                    <xsl:when test="$m_isShortTitle='No' and //engrossed-amendment-body">                        
                  <xsl:if test="//title">                                   
                            <!--<xsl:value-of select="gpo:officialTitleSpace(string($engSec+$amdins+$engform+
                                (((string-length(//title/enum)+ string-length(//title/header)+1))div 20) +
                                ((string-length(//title/section/enum)+string-length(//title/section/header)+string-length(//title/section/subsection/enum)+string-length(//title/section/subsection/header)+string-length(//title/section/subsection/text)) div 50)))"/>    --> 
                            </xsl:if>            
                    </xsl:when>
                    <xsl:otherwise>
                        
                         
                        
                        </xsl:otherwise>
                  
                </xsl:choose>               
            
       
        </xsl:if>
                    
       
        <!-- TB 15Oct2007 the commented logic removed. For review see revision #432 of version control -->
        
       <!-- <xsl:apply-templates mode="engrossed-amendment" select="//engrossed-amendment-form" />-->        
        <xsl:apply-templates mode="process" />
      </amendment-doc>
    </xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" name="engrossed-amendment-footer">
            <!--empty template-->
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc[ancestor::quoted-block]" mode="process">
        <para format="6211" />
        <xsl:apply-templates mode="process" />
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry" mode="process">
        <xsl:variable name="node" select="." />
        <xsl:variable name="sectionStyleOverlapped">false</xsl:variable>
        <xsl:variable name="style">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>
        <xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
            <xsl:call-template name="GetChangedForToc" />
        </xsl:if>
        <xsl:variable name="contents">
            <xsl:apply-templates mode="process" />
        </xsl:variable>
        <xsl:choose>
            <!-- the case @level='section' is handled in a different template toc-entry[@level='section'] -->
            <xsl:when test="@level='subparagraph' or  @level='clause' or @level='subclause' or @level='item' or @level='subitem'">
                <xsl:choose>
                    <xsl:when test="$style='tax'">
                        <para loc="44">
                            <xsl:call-template name="createTOC-Entry-Q10" />
                            <xsl:if test="@bold='on'">
                                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction> 
                            </xsl:if>
                            
                            <xsl:sequence select="gpo:QuotedBlockNestingStart($node)" />
                            
                            <xsl:if test="parent::toc-quoted-entry">
                                <xsl:text>“</xsl:text>
                            </xsl:if>
                            <xsl:value-of select="$contents" />
                            <xsl:call-template name="toc-entry-end" />
                        </para>
                    </xsl:when>
                    <xsl:otherwise>
                        <para loc="43">
                            <xsl:call-template name="createTOC-Entry-Q10" />
                            <xsl:if test="@bold='on'">
                                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction> 
                            </xsl:if>
                            
                            <xsl:sequence select="gpo:QuotedBlockNestingStart($node)" />
                            
                            <xsl:if test="parent::toc-quoted-entry">
                                <xsl:text>“</xsl:text>
                            </xsl:if>
                            <xsl:value-of select="$contents" />
                            <xsl:call-template name="toc-entry-end" />
                        </para>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="para">
                    <xsl:attribute name="loc" select="'22'" />
                    <xsl:text>  </xsl:text>
                    <xsl:if test="@bold='on'">
                        <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction> 
                    </xsl:if>
                    
                    <xsl:sequence select="gpo:QuotedBlockNestingStart($node)" />
                    
                    <xsl:if test="parent::toc-quoted-entry">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                    <xsl:value-of select="$contents" />
                    <xsl:call-template name="toc-entry-end" />
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="xtoc-entry" mode="process">
        <xsl:variable name="node" select="." />
        <xsl:variable name="sectionStyleOverlapped">false</xsl:variable>
        <xsl:variable name="style">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive($node, $sectionStyleOverlapped)" />
        </xsl:variable>
        <xsl:variable name="contents">
            <xsl:apply-templates mode="process" />
        </xsl:variable>
        <xsl:text>
       </xsl:text> 
        <xsl:choose>
            <xsl:when test="@level='section'">
                <para loc="42">
                    <xsl:call-template name="toc-entry-start" />
                    <xsl:value-of select="normalize-space($contents)" />
                    <xsl:call-template name="toc-entry-end" />
                </para>
            </xsl:when>
            <xsl:when test="@level = 'subparagraph' or @level = 'clause' or @level = 'subclause' or @level = 'item' or @level = 'subitem'">
                <xsl:choose>
                    <xsl:when test="$style='tax'">
                        <para loc="44">
                            <xsl:call-template name="toc-entry-start" />
                            <xsl:value-of select="normalize-space($contents)" />
                            <xsl:call-template name="toc-entry-end" />
                        </para>
                    </xsl:when>
                    <xsl:otherwise>
                        <para loc="43">
                            <xsl:call-template name="toc-entry-start" />
                            <xsl:value-of select="normalize-space($contents)" />
                            <xsl:call-template name="toc-entry-end" />
                        </para>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="para">
                    <xsl:attribute name="loc" select="22" />
                    <xsl:call-template name="toc-entry-start" />
                    <xsl:text>  </xsl:text>
                    <xsl:value-of select="$contents" />
                    <xsl:call-template name="toc-entry-end" />
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toc-entry-start">
        <!--Issue #41 -->
        <xsl:call-template name="addQ-ProcessingInstructionForTOC" />
        <xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
            <xsl:call-template name="GetChangedForToc" />
        </xsl:if>
        <!--Issue #69-->
        <xsl:sequence select="gpo:QuotedBlockNestingStart(.)" />
        <!--added by DKL 1/6/05-->
        <xsl:if test="parent::toc-quoted-entry">
            <xsl:text>“</xsl:text>
        </xsl:if>
        <xsl:if test="@bold = 'on'">
            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="toc-entry-end">
       
       <!-- <xsl:choose>
            <xsl:when test="ancestor::quoted-block">
                <xsl:call-template name="calculateTOCQuotedBlockEnd"/>
            </xsl:when>
            <xsl:when test="not(ancestor::quoted-block)">
                <xsl:call-template name="addClosingCharacterForChildElements">
                    <xsl:with-param name="source">toc</xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise/>
        </xsl:choose>-->
        <!--Need more information on when this rule gets spawned
 
           <xsl:if test="following-sibling::toc-entry[1][@level = 'title']">
            <xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
        </xsl:if>-->	
        <xsl:if test="not(following-sibling::toc-entry)">
            <xsl:variable name="toInsertQ04" as="xs:string">
                <xsl:call-template name="insertQ4BillLangCommitteeReport" />
            </xsl:variable>
            <!--Issue #283-->
            <xsl:choose>
                <!--Issue #289-->
                <xsl:when test="@level='section' and @style='USC'" />
                <xsl:when test="@level='section' and @style='OLC'" />
                <xsl:when test="@level='item'" />
                <xsl:when test="@level='section' and $billstage='Reference-Change-Senate'" />
                <!-- issue #321 -->
                <xsl:when test="@level='part' and @style='OLC'" />
                <xsl:when test="@level='subchapter' or @level='division'" />
                <xsl:when test="not(//committee-report and ancestor::amendment-block) and                      ( ../../following::*[1][ local-name()!='section'  and local-name()!='chapter'  and   local-name()!='subchapter'                       and        local-name()!='subdivision'      and        local-name()!='division'                      and        local-name()!='title'    and        local-name()!='subtitle'    and   local-name()!='part'    and                            local-name()!='subpart'     ])">
                    <xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="$toInsertQ04='yes'">
                    <xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
                </xsl:when>	
                <xsl:otherwise />
            </xsl:choose>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="calculateTOCQuotedBlockEnd">
        <xsl:variable name="style" as="xs:string">
            <xsl:value-of select="gpo:GetNearestAncestorStyleRecursive(., true())" />
        </xsl:variable>
        <xsl:variable name="qb-id" as="xs:string?">
            <xsl:value-of select="ancestor::quoted-block/@id" />
        </xsl:variable>
        <xsl:variable name="textCount" as="xs:integer">
            <xsl:value-of select="count(ancestor::quoted-block/descendant::toc-entry)" />
        </xsl:variable>
        <xsl:variable name="currentCount" as="xs:integer">
            <xsl:value-of select="count(preceding::toc-entry[ancestor::quoted-block/@id = $qb-id]) + 1" />
        </xsl:variable>

        <!--BH:  Added a test for section because it was causing double ending quotes.-->
        <xsl:choose>
        <xsl:when test="not(following-sibling::toc-entry) and parent::toc/following-sibling::after-quoted-block[1]">
            <xsl:text>”</xsl:text>
            <!-- fixes issue #285 -->
            <xsl:choose>
            <xsl:when test="//bill[@bill-stage='Introduced-in-House'] and $style='USC'">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:when>
                <xsl:when test="//bill[@bill-stage='Introduced-in-House'] and $style='USC'">
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise />
            </xsl:choose>
            <xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
        </xsl:when>
        <xsl:when test="($textCount = $currentCount) and not(ancestor::section)">
            <xsl:text>”</xsl:text>
			<!-- fixes issue #285 -->
            <xsl:if test="//bill[@bill-stage='Introduced-in-House'] and $style='USC'">
                <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
            </xsl:if>
            <xsl:value-of select="ancestor::quoted-block/after-quoted-block" />
        </xsl:when>
            <xsl:otherwise />
        </xsl:choose>
    </xsl:template><doc xmlns="http://www.oxygenxml.com/ns/doc/xsl" xmlns:dc="http://purl.org/dc/elements/1.1">
        <desc />
        <param>changed: The value of the changed attribute of the current element</param>
        <param>vbattChangedForReported: The value of the vbattChangedForReported attribute of the current element</param>
        <param>reported-display-style: The value of the reported-display-style attribute of the current element</param>
        <return />
        <gpo:srcXSL>Named Template:  GetChangedForToc</gpo:srcXSL>
    </doc><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="GetChangedForToc" as="node()">
        <xsl:param name="changed" as="xs:string?" select="ancestor::toc/@changed" />
        <xsl:param name="vbattChangedForReported" as="xs:string?" select="ancestor::toc/@vbattChangedForReported" />
        <xsl:param name="reported-display-style" as="xs:string?" select="ancestor::toc/@reported-display-style" />
        <xsl:choose>
            <!--Issue #282-->
            <xsl:when test="$billstage='Enrolled-Bill' or $resstage='Enrolled-in-Senate'">6511</xsl:when>
            <xsl:when test="$changed='not-changed' or $vbattChangedForReported = 'not-changed'">6211</xsl:when>
            <xsl:when test="$changed='deleted'  and $reported-display-style='strikethrough'">6411</xsl:when>
            <xsl:when test="$changed='added' and $reported-display-style='italic'">6213</xsl:when>
            <!--Issue #188-->
            <xsl:when test="@style='USC' and @vbattChangedForReported='italic'">6213</xsl:when>
            <!--Issue 378-->
            <xsl:when test="@style='OLC' and @vbattChangedForReported='italic'">6213</xsl:when>
            <xsl:when test="contains($reported-display-style,'boldface-roman')">6212</xsl:when>
            <xsl:when test="contains($reported-display-style,'boldface-italic')">6214</xsl:when>
            <xsl:otherwise>6211</xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc" mode="process">
        
        <!-- not used anywhere -->
        <!-- <xsl:variable name="theCommitteeID" as="xs:string" select="//committee-report/@committee-id"/> -->
        <xsl:choose>
            <xsl:when test="//committee-report/@front-matter-toc = 'yes'">
                <!-- nothing -->
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="style" as="xs:string">
                    <xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
                </xsl:variable>
                
                <xsl:if test="$billstage = 'Enrolled-Bill' or $resstage = 'Enrolled-in-Senate'">
                    <para format="6511" />
                </xsl:if>
                
                <!-- SM:05/05/2005  preceding-sibling::toc was added so it may not produce a Q10-->
                <!--BH:  Moving this down to the first <toc-entry> level in order to put the processing instruction
			        inside a para
			        Issue #39 -->
                <!--<xsl:if
					test="
					not(preceding-sibling::toc
					or child::toc-entry[1]/@level = 'division'
					or child::toc-entry[1]/@level = 'title'
					or child::toc-entry[1]/@level = 'subtitle'
					or child::toc-entry[1]/@level = 'part'
					or child::toc-entry[1]/@level = 'subpart'
					or child::toc-entry[1]/@level = 'chapter'
					or child::toc-entry[1]/@level = 'subchapter'
					or parent::title
					or parent::subtitle
					or parent::part
					or parent::subpart
					or parent::chapter
					or parent::subchapter)">
					<xsl:choose>
						<xsl:when
							test="$amendtype = 'conference-report' and (//conference-report-form[@conference-report-style = 'draft'] or //conference-report-form[@conference-report-style = 'bill'])">
							
						    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="$amendtype = 'conference-report'">
							
						    <xsl:processing-instruction name="xpp">lp;&amp;104q</xsl:processing-instruction>
							
						</xsl:when>
						<xsl:when test="$docstage = 'Enrolled-Bill'">
						    <xsl:processing-instruction name="xpp">lp;&amp;04q</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="parent::*/text">
						    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
						</xsl:when>
						<xsl:when
							test="
							parent::subsection
							or parent::subsection
							or parent::paragraph
							or parent::subparagraph
							or parent::clause
							or parent::subclause
							or parent::item
							or parent::subitem
							">
						    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
						</xsl:when>
						<xsl:otherwise>
							<xsl:choose>
								<xsl:when test="child::toc-entry and ancestor::amendment-block">
								    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
								</xsl:when>
								<xsl:when test="parent::quoted-block and ../../text">
								    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
								</xsl:when>
							</xsl:choose>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:if>-->
                
                <!-- this is not good coding, will change later, but this will a Q10 needs to be inputted for the Rep-in-Senate-->
                <xsl:variable name="conferenceReportStyle" as="xs:string" select="gpo:GetConferenceReportStyle(.)" />
                
                <xsl:variable name="ChangedForReported" as="xs:string">
                    <xsl:call-template name="GetChangedForReported" />
                </xsl:variable>
                
                <xsl:choose>
                    <xsl:when test="$billstage = 'Enrolled-Bill' or //resolution/@resolution-stage = 'Enrolled-in-Senate'">
                        <para format="6511" />
                    </xsl:when>
                    
                    <xsl:when test="(ancestor::subsection[@changed = 'added'] and ancestor::subsection[@reported-display-style = 'italic']) and not(@changed != 'added')">
                        <para format="6213" /> 
                    </xsl:when>
                    <xsl:when test="$amendtype = 'conference-report'">
                        <xsl:choose>
                            <xsl:when test="$conferenceReportStyle = 'draft'">
                                <xsl:call-template name="displayTocFormatRoman" />
                            </xsl:when>
                            <xsl:when test="$conferenceReportStyle = 'bill'">
                                <xsl:call-template name="displayTocFormatItalic" />
                            </xsl:when>
                            <xsl:otherwise>
                                <para format="6613" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:when test="../@reported-display-style = 'strikethrough' or $ChangedForReported = 'strikethrough'">
                        <para format="6411" />
                    </xsl:when>
                    <xsl:when test="../@changed = 'not-changed' and (not(@changed) or @changed = 'not-changed')">
                        <para format="6211" />
                    </xsl:when>
                    <xsl:when test="../@reported-display-style = 'italic' or $ChangedForReported = 'italic'">
                        <para format="6213" />
                    </xsl:when>
                    <xsl:when test="contains(../@reported-display-style, 'boldface-roman') or contains($ChangedForReported, 'boldface-roman')">
                        <para format="6212" />
                    </xsl:when>
                    <xsl:when test="contains(../@reported-display-style, 'boldface-italic') or contains($ChangedForReported, 'boldface-italic')">
                        <para format="6214" />
                    </xsl:when>
                    <xsl:when test="parent::quoted-block and (../../@reported-display-style = 'strikethrough' or $ChangedForReported = 'strikethrough')">
                        
                        <para format="6411" />
                    </xsl:when>
                    <xsl:when test="//amendment-doc[@amend-type = 'engrossed-amendment'] and $ChangedForReported = 'italic'">
                        <para format="6313" />
                        
                    </xsl:when>
                    <xsl:when test="//amendment-doc[@amend-type = 'engrossed-amendment']">
                        <para format="6313" />
                    </xsl:when>
                    <xsl:when test="//amendment-doc/@amend-type = 'engrossed-amendment' or parent::quoted-block and (../../@reported-display-style = 'italic' or $ChangedForReported = 'italic') and not(../../@changed = 'not-changed')">
                        <para format="6213" />
                    </xsl:when>
                    <xsl:when test="$docstage = 'Enrolled-Bill'">
                        <xsl:variable name="currentFormat" as="item()">
                            <xsl:call-template name="LegisBodyWithChangedAttribute">
                                <xsl:with-param name="node" select="." />
                                <xsl:with-param name="docstage" select="$docstage" />
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:sequence select="$currentFormat" />
                    </xsl:when>
                    
                    <xsl:when test="contains($docstage, 'Reported') and ancestor::legis-body/@changed">
                        <xsl:variable name="currentFormat" as="item()">
                            <xsl:call-template name="LegisBodyWithChangedAttribute">
                                <xsl:with-param name="node" select="." />
                                <xsl:with-param name="docstage" select="$docstage" />
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:sequence select="$currentFormat" />
                    </xsl:when>
                    
                    <xsl:when test="../toc and $m_isCommitteeReport = 'Yes' and not(ancestor::amendment-body)">
                        <!-- TB 13Nov2007 - Commitee Report exception - was nessesary to make it here -->
                        <para format="6646" />
                    </xsl:when>
                    
                    <xsl:when test="../toc and $m_isCommitteeReport = 'Yes' and (ancestor::amendment-block) and not(//committee-report/@front-matter-toc = 'yes') and not(ancestor::ramseyer) and not(ancestor::cordon)">
                        <!-- TB 13Nov2007 - Commitee Report exception - was nessesary to make it here -->
                        <para format="6631" /> 
                        
                    </xsl:when>
                    <xsl:when test="../toc and $m_isCommitteeReport = 'Yes' and (ancestor::amendment-block) and not(//committee-report/@front-matter-toc = 'yes')">
                        <!-- TB 13Nov2007 - Commitee Report exception - was nessesary to make it here -->
                        <para format="6611" /><!--syesmin 9/9/2015  Refactor XSLT 2.0-->
                    </xsl:when>
                    <xsl:when test="@reported-display-style = 'italic'">
                        <para format="6213" /><!--syesmin 9/9/2015  Refactor XSLT 2.0-->
                        
                    </xsl:when>
                    <xsl:otherwise>
                        <para format="6211" /><!--syesmin 9/9/2015  Refactor XSLT 2.0-->
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:apply-templates mode="process" />
                <xsl:if test="//insert">
                    <para format="6201" />
                </xsl:if>
                <!--We need to put a Q04 here if this is a report.  We can only do that if there is no after-quoted-block following this node-->
                
                
                <xsl:if test="local-name(following::*[1]) = 'after-quoted-block'">
                    <xsl:if test="not(following::after-quoted-block/@display = 'no')">
                        <xsl:call-template name="QuotedBlockNestingEnd" />
                        <xsl:value-of select="following::*[1]" />
                        
                        <xsl:call-template name="addClosingCharacterForChildElements">
                            <xsl:with-param name="source">
                                <xsl:text>afterQuotedBlock</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:if>
                </xsl:if>
                
                <xsl:if test="(contains(/amendment-doc/@amend-type, 'report') or $billstage = 'Enrolled-Bill') or (//committee-report and ancestor-or-self::amendment-block)">
                    
                    <xsl:variable name="toInsertQ04" as="xs:string">
                        <xsl:call-template name="insertQ4BillLangCommitteeReport" />
                    </xsl:variable>
                    
                    <xsl:choose>
                        <xsl:when test="not(//committee-report and ancestor::amendment-block) and (../following::*[1][local-name() != 'section' and local-name() != 'chapter' and local-name() != 'subchapter' and local-name() != 'subdivision' and local-name() != 'division' and local-name() != 'title' and local-name() != 'subtitle' and local-name() != 'part' and local-name() != 'subpart'])">
                            
                            <xsl:processing-instruction name="xpp">lp;&amp;04q</xsl:processing-instruction>  
                        </xsl:when>
                        <xsl:when test="not(//committee-report and ancestor::amendment-block) and (../following::*[1][local-name() != 'section' and local-name() != 'chapter' and local-name() != 'subchapter' and local-name() != 'subdivision' and local-name() != 'division' and local-name() != 'title' and local-name() != 'subtitle' and local-name() != 'part' and local-name() != 'subpart'])">
                            
                            <xsl:processing-instruction name="xpp">lp;&amp;04q</xsl:processing-instruction>  
                        </xsl:when>
                        
                        <xsl:when test="$toInsertQ04 = 'yes'">
                            <xsl:processing-instruction name="xpp">lp;&amp;04q</xsl:processing-instruction>
                            
                        </xsl:when>
                        <xsl:otherwise />
                    </xsl:choose>
                    
                </xsl:if>
                
                <xsl:variable name="isLastSibling" as="xs:string">
                    <xsl:call-template name="iAmALastSibling">
                        <xsl:with-param name="source" as="xs:string" select="'toc'" />
                    </xsl:call-template>
                    
                </xsl:variable>
                <xsl:if test="not($isLastSibling = 'true')">
                    <xsl:call-template name="KeepParentsFormatOrSelf" />
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level='section'][not(ancestor::quoted-block)]" mode="process">
        <xsl:variable name="ChangedForReported" as="xs:string">
            <xsl:call-template name="GetChangedForReported" />
        </xsl:variable>
        
        <xsl:variable name="style" as="xs:string">
            <xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
        </xsl:variable>
        
        <xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
            <xsl:call-template name="GetChangedForToc" />
        </xsl:if>
        
        <xsl:variable name="contentItems">
            <xsl:apply-templates mode="process" />
        </xsl:variable>
        
        <!--<xsl:variable name="contentString" as="xs:string">
           <xsl:value-of select="$contentItems"/>
        </xsl:variable>-->
        
      <!--  <xsl:variable name="processedContents">
            <xsl:choose>				
                <xsl:when test="$style='tax'">
                    <xsl:call-template name="prepareProcessedContent">
                        <xsl:with-param name="notToTurnUpper">false</xsl:with-param>
                        <xsl:with-param name="origContent" select="$contentString"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="prepareProcessedContent">
                        <xsl:with-param name="notToTurnUpper">true</xsl:with-param>
                        <xsl:with-param name="origContent" select="$contentString"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>-->
        
        <xsl:variable name="processedContents" as="item()*">
            <xsl:choose>				
                <xsl:when test="$style='tax'">
                    <xsl:for-each select="$contentItems">
                        <xsl:choose>
                            <xsl:when test="text()">
                                <xsl:sequence select="gpo:TocEntry(., true())" />  
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:sequence select="." />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:for-each>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:for-each select="$contentItems/node()">
                        <xsl:choose>
                            <xsl:when test="self::text()">
                                <xsl:value-of select="gpo:TocEntry(., false())" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:sequence select="." />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:for-each>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <para>
            <xsl:choose>
                <xsl:when test="$style='tax' ">
                    <xsl:attribute name="loc" select="'44'" />				
                </xsl:when>
                <xsl:when test="ancestor::quoted-block">
                    <xsl:attribute name="loc" select="'42'" />				
                </xsl:when>
                <xsl:when test="$billstage = 'Enrolled-Bill'">
                    <xsl:attribute name="loc" select="'42'" />				
                </xsl:when>
                <xsl:otherwise>
                    <xsl:choose>
                        <xsl:when test="parent::toc-quoted-entry">
                            <xsl:attribute name="loc" select="'43'" />					
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="loc" select="'42'" />				
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:call-template name="addQ-ProcessingInstructionForTOC">
                <xsl:with-param name="docstage"><xsl:value-of select="$docstage" /></xsl:with-param>
            </xsl:call-template>
            <xsl:if test="@bold='on'">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:if>
            <xsl:if test="contains($ChangedForReported ,'brackets')">
                <xsl:text>❨</xsl:text>
            </xsl:if>
            <xsl:if test="contains($ChangedForReported ,'parentheses')">
                <xsl:text>【</xsl:text>
            </xsl:if>
            
            <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
            
            <xsl:if test="parent::toc-quoted-entry">
                <xsl:text>“</xsl:text>
            </xsl:if>	
            <!--Issue #293-->
            <xsl:choose>
                <xsl:when test="enum-in-header"><xsl:apply-templates mode="process" /></xsl:when>
                <xsl:otherwise><xsl:sequence select="$processedContents" /></xsl:otherwise>
            </xsl:choose>
            <xsl:call-template name="toc-entry-end" />
            <!--Issue #283 - Moved to toc-entry-end template-->
         <!--   <xsl:choose>
                <xsl:when test="ancestor::quoted-block and contains($ChangedForReported,'brackets') and not (following-sibling::toc-entry)">
                    <xsl:variable name="nextSiblingBracketed">
                        <xsl:call-template name="isNextSiblingBracketed"/>
                    </xsl:variable>
                    <xsl:if test="$nextSiblingBracketed != 'yes'">
                        <xsl:text>&#x2769;</xsl:text>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="ancestor::quoted-block and contains($ChangedForReported,'brackets') and  following-sibling::toc-entry and not(contains(following-sibling::toc-entry/@vbattChangedForReported,'brackets'))">
                    <xsl:text>&#x2769;</xsl:text>
                </xsl:when>
                <xsl:when test="ancestor::quoted-block and contains($ChangedForReported,'parentheses') and following-sibling::toc-entry and not(contains(following-sibling::toc-entry/@vbattChangedForReported,'parentheses')) ">
                    <xsl:text>&#x3010;</xsl:text>
                </xsl:when>
            </xsl:choose>
            <xsl:call-template name="toc-entry-end"/>-->
        </para>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level = 'section'][ancestor::quoted-block]" mode="process">
        <xsl:variable name="ChangedForReported" as="xs:string">
            <xsl:call-template name="GetChangedForReported" />
        </xsl:variable>
        <xsl:variable name="style" as="xs:string">
            <xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
        </xsl:variable>
        
        <xsl:if test="@changed              or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
            <xsl:call-template name="GetChangedForToc" />
        </xsl:if>
        
        <xsl:variable name="contentItems" as="item()*">
            <xsl:apply-templates mode="process" />
        </xsl:variable>
        
        <xsl:variable name="processedContents" as="item()*">
            <xsl:choose>				
                <xsl:when test="$style='tax'">
                    <xsl:for-each select="$contentItems">
                        <xsl:choose>
                            <xsl:when test="self::text()">
                                <xsl:sequence select="gpo:TocEntry(., true())" />  
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:sequence select="." />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:for-each>
                    
                   <!-- <xsl:call-template name="prepareProcessedContent">
                        <xsl:with-param name="notToTurnUpper">false</xsl:with-param>
                        <xsl:with-param name="origContent" select="$contentString"/>
                    </xsl:call-template>-->
                </xsl:when>
                <xsl:otherwise>
                    <xsl:for-each select="$contentItems">
                        <xsl:choose>
                            <xsl:when test="self::text()">
                                <xsl:sequence select="gpo:TocEntry(., false())" />  
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:sequence select="." />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:for-each>
                    <xsl:if test="local-name(following::*[1]) = 'after-quoted-block'">
                        <xsl:if test="not(following::after-quoted-block/@display = 'no')">
                            <xsl:call-template name="QuotedBlockNestingEnd" />
                            
                            <xsl:value-of select="following::*[1]" />
                            
                            <xsl:call-template name="addClosingCharacterForChildElements">
                                <xsl:with-param name="source">
                                    <xsl:text>afterQuotedBlock</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:if>
                    </xsl:if>
                   <!-- <xsl:call-template name="prepareProcessedContent">
                        <xsl:with-param name="notToTurnUpper">true</xsl:with-param>
                        <xsl:with-param name="origContent" select="$contentString"/>
                    </xsl:call-template>-->
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:variable name="format">
            <xsl:call-template name="GetChangedForToc" />
           <!-- <xsl:choose>
                <xsl:when test="@vbattChangedForReported = 'not-changed'">6211</xsl:when>
                <xsl:otherwise>6213</xsl:otherwise>
            </xsl:choose>-->
        </xsl:variable>
        <para loc="42" format="{$format}">
            <!--Issue #200 add Q10 PI-->
            <xsl:call-template name="addQ-ProcessingInstructionForTOC">
                <xsl:with-param name="docstage"><xsl:value-of select="$docstage" /></xsl:with-param>
            </xsl:call-template>
            <!--<xsl:if test="not(preceding-sibling::toc-entry)">
                <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
            </xsl:if>-->
            <xsl:if test="@bold = 'on'">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:if>
            <xsl:if test="contains($ChangedForReported, 'brackets')">
                <xsl:text>❨</xsl:text>
            </xsl:if>
            <xsl:if test="contains($ChangedForReported, 'parentheses')">
                <xsl:text>【</xsl:text>
            </xsl:if>
            <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />   
            <xsl:if test="parent::toc-quoted-entry">
                <xsl:text>“</xsl:text>
            </xsl:if>
            
            <xsl:choose>
                <xsl:when test="enum-in-header"><xsl:apply-templates mode="process" /></xsl:when>
                <xsl:otherwise><xsl:sequence select="$processedContents" /></xsl:otherwise>
            </xsl:choose>
            <!--Issue #283 - Moved to toc-entry-end template-->    
            <xsl:call-template name="toc-entry-end" />
        </para>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level = 'division']" mode="process">
		
		<xsl:sequence select="gpo:outputComment('toc-entry[@level = division]')" />
		
		<xsl:variable name="style" as="xs:string" select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		
		<xsl:variable name="ChangedForReported" as="xs:string">
			<xsl:call-template name="GetChangedForReported" />
		</xsl:variable>
		<xsl:variable name="contents" as="xs:string">
			<xsl:apply-templates mode="process" />
		</xsl:variable>

		<xsl:if test="@changed     or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
			<!--Issue #118 - the paramaters were not being passed to the GetChangedForToc template so the value 
			    was always 6211-->
		    <xsl:call-template name="GetChangedForToc">
			    <xsl:with-param name="changed" select="@changed" />
			    <xsl:with-param name="vbattChangedForReported" select="@vbattChangedForReported" />
			    <xsl:with-param name="reported-display-style" select="@reported-display-style" />
			</xsl:call-template>
		</xsl:if>
	
		<para loc="74">
			<xsl:if test="@bold = 'on'">
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
			</xsl:if>
			<xsl:if test="contains($ChangedForReported, 'brackets')">
			    <xsl:text>❨</xsl:text>
			</xsl:if>
			<xsl:if test="contains($ChangedForReported, 'parentheses')">
			    <xsl:text>【</xsl:text>
			</xsl:if>	
			<xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />		
			<xsl:if test="parent::toc-quoted-entry">
			    <xsl:text>“</xsl:text>
			</xsl:if>		
			<!--<xsl:value-of select="gpo:escapeWithBelKandBelT4(gpo:TocEntry(string($contents), true()), '\([0-9]+\)')"/>-->
		    <xsl:sequence select="gpo:TocEntry($contents, true())" />
			<xsl:call-template name="toc-entry-end" />
		</para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level = 'subdivision']" mode="process">
		
		<xsl:variable name="style" as="xs:string" select="gpo:GetNearestAncestorStyleRecursive(., true())" />

		<xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
			<xsl:call-template name="GetChangedForToc" />
		</xsl:if>
		<xsl:variable name="ChangedForReported" as="xs:string">
			<xsl:call-template name="GetChangedForReported" />
		</xsl:variable>
		<xsl:variable name="contents" as="xs:string">
			<xsl:variable name="text" as="xs:string">
				<xsl:apply-templates mode="process" />
			</xsl:variable>
			<xsl:value-of select="gpo:capICHeader(string($text))" />
		</xsl:variable>
		<para loc="74">
			<xsl:if test="@bold = 'on'">
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				
			</xsl:if>
			<xsl:if test="contains($ChangedForReported, 'brackets')">
				<xsl:text>❨</xsl:text>
				
			</xsl:if>
			<xsl:if test="contains($ChangedForReported, 'parentheses')">
				<xsl:text>【</xsl:text>
				
			</xsl:if>
		
			<xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
	
			<xsl:if test="parent::toc-quoted-entry">
				<xsl:text>“</xsl:text>
			</xsl:if>
			<xsl:value-of select="$contents" />
			<xsl:call-template name="toc-entry-end" />
		</para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="displayTocFormatRoman">
		<xsl:choose>
			<xsl:when test="ancestor::amendment-block/@line-numbers = 'off'">
				<para format="6311" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
			</xsl:when>
			<xsl:otherwise>
				<para format="6211" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
			</xsl:otherwise>
		</xsl:choose>
		
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="displayTocFormatItalic" as="item()">
		<xsl:choose>
			<xsl:when test="ancestor::amendment-block/@line-numbers = 'off'">
				<para format="6313" />
			</xsl:when>
			<xsl:otherwise>
				<para format="6213" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level = 'title']" mode="process">
		<xsl:variable name="style" as="xs:string" select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		
	
		<xsl:variable name="ChangedForReported" as="xs:string">
			<xsl:call-template name="GetChangedForReported" />
		</xsl:variable>
		
		<xsl:variable name="contents" as="item()+">
			<xsl:choose>
				<xsl:when test="not($style = 'tax' or child::enum-in-header or child::inline-comment/enum-in-header)">
					<xsl:sequence select="upper-case(string(.))" />
				</xsl:when>
				<xsl:when test="not($style = 'tax' or child::inline-comment/enum-in-header)">
					<xsl:apply-templates mode="process" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="text" as="xs:string">
						<xsl:apply-templates mode="process" />
					</xsl:variable>
					<xsl:value-of select="string($text)" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
	    <xsl:element name="para">
		<xsl:choose>
			<xsl:when test="$style = 'tax'">
				<xsl:attribute name="qcode" select="'10'" />
				<xsl:attribute name="loc" select="'44'" />
				<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="loc" select="'74'" />
			</xsl:otherwise>
		</xsl:choose>
	        <xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
	          <xsl:call-template name="GetChangedForToc" />
	        </xsl:if>
		<xsl:if test="@bold = 'on'">
			<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
		</xsl:if>
		<xsl:if test="contains($ChangedForReported, 'brackets')">
			<xsl:text>❨</xsl:text>
			
		</xsl:if>
		<xsl:if test="contains($ChangedForReported, 'parentheses')">
			<xsl:text>【</xsl:text>
			
		</xsl:if>
		<xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />

		<xsl:if test="parent::toc-quoted-entry">
			<xsl:text>“</xsl:text>
		</xsl:if>
		<xsl:choose>
			<xsl:when test="$style = 'tax'">
				
				<!-- 10/27/2015 mharcourt XSLT 2.0 refactoring. Removed BEL coding from upcoming call to  
					gpo:rawRegexReplace and output it subsequent to xls:value-of command. -->
				<xsl:value-of select="gpo:rawRegexReplace(gpo:capICHeader(string($contents)), '([A-X]+[.])', '$1')" />
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="@bold = 'on'">
				<!-- 10/27/2015 mharcourt XSLT 2.0 refactoring. Removed BEL coding from upcoming call to  
					gpo:rawRegexReplace and output it prior and subsequent to xls:value-of command. -->
				<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
				<xsl:value-of select="gpo:rawRegexReplace(string(gpo:escapeWithBelKandBelT4(string($contents), '\([0-9]+\)')), '((\d+)(\s*)?)', '$1')" /><!--<xsl:value-of         
						select="gpo:rawRegexReplace(string(gpo:escapeWithBelKandBelT4(string($contents), '\([0-9]+\)')), '((\d+)(\s*)?)', '&lt;BEL>G2&lt;BEL>T2$1&lt;BEL>G2&lt;BEL>T1')"
						/>-->
				<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>				
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="gpo:escapeWithBelKandBelT4(gpo:TocEntry($contents[1], true()), '\([0-9]+\)')" />
			</xsl:otherwise>
		</xsl:choose>
		<xsl:call-template name="toc-entry-end" />
	    </xsl:element>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level = 'subtitle']" mode="process">
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>

	
		
		<xsl:variable name="ChangedForReported" as="xs:string">
			<xsl:call-template name="GetChangedForReported" />
		</xsl:variable>
			
		<xsl:variable name="contents" as="item()*">
		<!--	<xsl:variable name="text" as="item()*">
				<xsl:apply-templates mode="process"/>
			</xsl:variable>-->
			<xsl:value-of select="gpo:capICHeader(.)" />
		</xsl:variable>
	    <xsl:element name="para">
		<xsl:choose>
			<xsl:when test="$style = 'education' or $style = 'OLC' or $style = 'traditional' or $style = 'traditional-inline' or starts-with($style, 'archaic')">
				<xsl:attribute name="loc" select="'74'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
				<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$style = 'tax'">
				<xsl:attribute name="loc" select="'44'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
				<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
			</xsl:when>
			
			<!-- SM 09/18/06 @bold='on' must reside outside of the Choose condtion-->
			<xsl:otherwise>
				<xsl:attribute name="loc" select="'74'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
				<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:otherwise>
		</xsl:choose>
	        <xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
	            <xsl:call-template name="GetChangedForToc" />
	        </xsl:if>	
		<xsl:if test="@bold = 'on'">
			<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
			
		</xsl:if>
		<xsl:if test="contains($ChangedForReported, 'brackets')">
			<xsl:text>❨</xsl:text>
			
		</xsl:if>
		<xsl:if test="contains($ChangedForReported, 'parentheses')">
			<xsl:text>【</xsl:text>
			
		</xsl:if>
		<xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
		<xsl:if test="parent::toc-quoted-entry">
			<xsl:text>“</xsl:text>
		</xsl:if>
		
		<!--needs to blow in a T3-->
		<!-- NB 10/26/2008 - added the underscores to the match to allow for times when the enum in the toc-entry is a series of underscores -->
		<xsl:choose>
			<xsl:when test="$style = 'tax'">
				<xsl:value-of select="gpo:rawRegexReplace(string($contents), '([A-J]+[.]|_+\s)', '$1&lt;BEL&gt;K ')" />
				<!-- 10/27/2015 mharcourt XSLT 2.0 refactoring. Removed BEL coding from upcoming call to  
					gpo:rawRegexReplace and output it subsequent to xls:value-of command. -->
				<xsl:value-of select="gpo:rawRegexReplace(string($contents), '([A-J]+[.]|_+\s)', '$1 ')" /><!--<xsl:value-of         
						select="gpo:rawRegexReplace(string($contents), '([A-J]+[.]|_+\s)', '$1&lt;BEL>K ')"
						/>-->
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>
			
			<xsl:otherwise>
				<xsl:value-of select="string($contents)" />
			</xsl:otherwise>
			
		</xsl:choose>
		<xsl:call-template name="toc-entry-end" />
	    </xsl:element>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level = 'chapter']" mode="process">
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>

	<xsl:element name="para">
		<xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
			<xsl:call-template name="GetChangedForToc" />
		</xsl:if>
		<xsl:variable name="ChangedForReported" as="xs:string">
			<xsl:call-template name="GetChangedForReported" />
		</xsl:variable>
	    
	    <xsl:variable name="text" as="xs:string?">
	        <xsl:value-of select="normalize-space(.)" />
	    </xsl:variable>
	    
		<xsl:variable name="contents" as="xs:string">
			<xsl:choose>
				<xsl:when test="$style = 'tax'">
					<xsl:value-of select="string($text)" />
				</xsl:when>
				<xsl:otherwise>
    		      <xsl:value-of select="gpo:capICHeader(.)" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:choose>
			<xsl:when test="$style = 'tax' and ../../../part/toc">
				<xsl:attribute name="loc" select="'44'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
			</xsl:when>
			<xsl:when test="$style = 'tax'">
				<xsl:if test="not(preceding-sibling::toc-entry)">
					<xsl:choose>
						<xsl:when test="$docstage = 'Enrolled-Bill'">
							<xsl:attribute name="qcode" select="'04'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
						</xsl:when>
						<xsl:otherwise>
							<xsl:attribute name="qcode" select="'10'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
						</xsl:otherwise>
					</xsl:choose>
					
					
				</xsl:if>
				<xsl:attribute name="loc" select="'44'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
				<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="@bold = 'on'">
				<xsl:attribute name="loc" select="'74'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
				<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
				<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$style = 'OLC' or $style = 'USC' or $style = 'traditional' or $style = 'traditional-inline' or starts-with($style, 'archaic')">
				<xsl:attribute name="loc" select="'74'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="loc" select="'74'" /><!--syesmin 9/10/2015 Refactor XSLT 2.0-->
				<xsl:processing-instruction name="xpp">fv;5</xsl:processing-instruction>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="contains($ChangedForReported, 'brackets')">
			<xsl:text>❨</xsl:text>
		</xsl:if>
		<xsl:if test="contains($ChangedForReported, 'parentheses')">
			<xsl:text>【</xsl:text>
		</xsl:if>
		<xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />

		<xsl:if test="parent::toc-quoted-entry">
			<xsl:text>“</xsl:text>
		</xsl:if>
		<xsl:choose>
			<xsl:when test="@bold = 'on'">
				<xsl:value-of select="string($contents)" />
			</xsl:when>
			<xsl:when test="$style = 'tax' and ../../../chapter/toc">
				<!-- 10/27/2015 mharcourt XSLT 2.0 refactoring. Removed BEL coding from upcoming calls to  
					gpo:escapeWithBelKandBelT4 and rawRegexReplace. Output PIs prior and 
					subsequent to revised xls:value-of command. -->
				<xsl:variable name="text" as="xs:string" select="gpo:rawRegexReplace(gpo:escapeWithBelKandBelT4(string($contents), '\([0-9]+\)'), '([0-9]+[.])', '$1')" /><!--<xsl:value-of         
						select="gpo:rawRegexReplace(gpo:escapeWithBelKandBelT4(string($contents), '\([0-9]+\)'), '([0-9]+[.])', '&lt;BEL>T1$1')">-->
				<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
				<xsl:value-of select="gpo:rawRegexReplace(string($text), '([A-Z]\. )', '$1')" /><!--<xsl:value-of
						select="gpo:rawRegexReplace(string($text), '([A-Z]\. )', '$1&lt;BEL>T1')"/>-->
				<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
			</xsl:when>
			<xsl:when test="$style = 'tax'">
				<!-- SM 07/06/06 To take care of mdash-->
				<!-- NB 10/26/2008 - added the underscores to the match to allow for times when the enum in the toc-entry is a series of underscores -->
				<!-- 10/27/2015 mharcourt XSLT 2.0 refactoring. Removed BEL coding from upcoming calls to  
					rawRegexReplace and output PI subsequent to revised xls:value-of command. -->
				<xsl:value-of select="gpo:rawRegexReplace(gpo:escapeWithBelKandBelT4(string($contents), '\([0-9]+\)'), '([1-9|_]+[.,—])', '$1')" /><!--<xsl:value-of select="gpo:rawRegexReplace(gpo:escapeWithBelKandBelT4(string($contents), '\([0-9]+\)'), '([1-9|_]+[.,—])', '$1&lt;BEL>K')"/>-->
				<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>
			</xsl:when>
			<xsl:otherwise>
				<!-- 10/27/2015 mharcourt XSLT 2.0 refactoring. Removed BEL coding from upcoming calls to  
					rawRegexReplace and output PI subsequent to revised xls:value-of command. -->
				<xsl:value-of select="gpo:rawRegexReplace(gpo:escapeWithBelKandBelT4(string($contents), '\([0-9]+\)'), '([1-9]+[.])', '$1')" /><!--<xsl:value-of select="gpo:rawRegexReplace(gpo:escapeWithBelKandBelT4(string($contents), '\([0-9]+\)'), '([1-9]+[.])', '$1&lt;BEL>K')"/>-->
			    <!--Issue #41 -->
				<!--<xsl:processing-instruction name="xpp">rs-font</xsl:processing-instruction>-->
			</xsl:otherwise>
		</xsl:choose>
		<xsl:call-template name="toc-entry-end" />
	</xsl:element>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level='subchapter'] | toc-entry[@level='subpart']" mode="process">
		<xsl:variable name="style" as="xs:string">
			<xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
		</xsl:variable>	   
		<xsl:variable name="ChangedForReported" as="xs:string">
			<xsl:call-template name="GetChangedForReported" />
		</xsl:variable>
        <xsl:variable name="text" as="item()*">
            <xsl:apply-templates mode="process" />
        </xsl:variable>
	    <xsl:variable name="contents" as="xs:string">
	        <xsl:choose>
	            <xsl:when test="$style = 'tax' or $style = 'OLC'">
	                <xsl:value-of select="$text" />
	            </xsl:when>
	            <xsl:otherwise>
	                <xsl:value-of select="gpo:capICHeader(string($text))" />
	            </xsl:otherwise>
	        </xsl:choose>
	    </xsl:variable>
	    <xsl:variable name="BellICode">
	        <xsl:choose>
	            <xsl:when test="$style = 'tax' and @level = 'subpart'">76</xsl:when>
	            <xsl:when test="$style = 'tax'">74</xsl:when>
	            <xsl:when test="$style = 'OLC'">
	                <xsl:choose>
	                    <xsl:when test="contains(string($contents), '__')">74</xsl:when>
	                    <xsl:when test="@bold = 'on'">44</xsl:when>
	                    <xsl:otherwise>74</xsl:otherwise>
	                </xsl:choose>
	            </xsl:when>
	            <xsl:when test="starts-with($style, 'traditional') or starts-with($style, 'archaic')">
	                <xsl:choose>
	                    <xsl:when test="@bold = 'on'">74</xsl:when>
	                    <xsl:otherwise>74</xsl:otherwise>
	                </xsl:choose>
	            </xsl:when>
	            <!-- Based on Kathleen instruction archaic and  traditional should be the same.-->
	            <xsl:otherwise>
	                <xsl:choose>
	                    <xsl:when test="contains(string($contents), '__')">74</xsl:when>
	                    <xsl:when test="@bold = 'on'">74</xsl:when>
	                    <xsl:otherwise>74</xsl:otherwise>
	                </xsl:choose>
	            </xsl:otherwise>
	        </xsl:choose>
	    </xsl:variable>
	    <xsl:variable name="UsingI74" as="xs:string">
	        <xsl:choose>
	            <xsl:when test="$BellICode='74' and not($style = 'tax' and @level = 'subpart')">yes</xsl:when>
	            <xsl:otherwise>No</xsl:otherwise>
	        </xsl:choose>
	    </xsl:variable>
        <xsl:call-template name="toc-entry-end" />
	    <para>
		<!--<xsl:variable name="BellICode" as="item()+">-->
			<xsl:choose>
				<xsl:when test="$style = 'tax' and @level = 'subpart'">
					<xsl:attribute name="loc" select="$BellICode" />
				</xsl:when>
				<xsl:when test="$style = 'tax'">
				    <xsl:attribute name="loc" select="$BellICode" />
					<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
				</xsl:when>
				<xsl:when test="$style = 'OLC'">
					<xsl:choose>
						<xsl:when test="contains(string($contents), '__')">
						    <xsl:attribute name="loc" select="$BellICode" />
							<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="@bold = 'on'">
						    <xsl:attribute name="loc" select="$BellICode" />
							<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
							<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						</xsl:when>
						<xsl:otherwise>
							<xsl:attribute name="loc" select="$BellICode" />
							<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:when test="starts-with($style, 'traditional') or starts-with($style, 'archaic')">
					<xsl:choose>
						<xsl:when test="@bold = 'on'">
						    <xsl:attribute name="loc" select="$BellICode" />
							<xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
						</xsl:when>
						<xsl:otherwise>
						    <xsl:attribute name="loc" select="$BellICode" />
							<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<!-- Based on Kathleen instruction archaic and  traditional should be the same.-->
				<xsl:otherwise>
					<xsl:choose>
						<xsl:when test="contains(string($contents), '__')">
						    <xsl:attribute name="loc" select="$BellICode" />
							<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
						</xsl:when>
						<xsl:when test="@bold = 'on'">
						    <xsl:attribute name="loc" select="$BellICode" />
							<xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
							<xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
						</xsl:when>
						<xsl:otherwise>
						    <xsl:attribute name="loc" select="$BellICode" />
							<xsl:processing-instruction name="xpp">fv;4</xsl:processing-instruction>
						    <!-- issue #286 (missing space before quote) -->
						    <xsl:text> </xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose><!--
		<xsl:value-of select="gpo:QuotedBlockNestingStart(.)"/>-->
	        <xsl:if test="ancestor::quoted-block">“</xsl:if>
		<xsl:if test="parent::toc-quoted-entry">
			<xsl:text>“</xsl:text>
		</xsl:if>
		<xsl:if test="contains($ChangedForReported, 'brackets')">
			<xsl:text>❨</xsl:text>
		</xsl:if>
		<xsl:if test="contains($ChangedForReported, 'parentheses')">
			<xsl:text>【</xsl:text>
		</xsl:if>
		<xsl:choose>
			<xsl:when test="@bold = 'on'">
				<!-- NB 11/16/2006 - Added a test to lowercase whenever a I74 is used -->
				<xsl:choose>
					<xsl:when test="$UsingI74 = 'Yes'">
						<xsl:sequence select="lower-case($contents)" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$contents" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="contains(string($contents), '__') and      ($style = 'OLC' or      not($style = 'OLC' or $style = 'tax' or starts-with($style, 'archaic') or      starts-with($style, 'traditional')))">
				<xsl:sequence select="lower-case($contents)" />
			</xsl:when>
			<xsl:when test="$style = 'tax'">
				<!-- SM 07/06/06 To take care of mdash-->
				<!-- NB 10/26/2008 - added the underscores to the match to allow for times when the enum in the toc-entry is a series of underscores -->
				<xsl:value-of select="gpo:rawRegexReplace(string($contents), '([A-X]+[.,—]|_+\s)', '$1&lt;BEL&gt;K')" />
			</xsl:when>
			<xsl:otherwise>
				<!-- NB 11/15/2006 - Added a test to lowercase whenever a I74 is used -->
				<xsl:choose>
					<xsl:when test="$style = 'USC' or $style = 'OLC'">
						<xsl:call-template name="lowerCaseExceptEnumInHeader">
							<xsl:with-param name="aHeaderText" select="$contents" />
						</xsl:call-template>
					</xsl:when>
					<xsl:when test="$UsingI74 = 'Yes'">
						<xsl:sequence select="lower-case($contents)" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$contents" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:call-template name="toc-entry-end" />
	    </para>
	</xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level='part']" mode="process">
        <xsl:variable name="style" as="xs:string">
            <xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
        </xsl:variable>
        
        
        <xsl:variable name="ChangedForReported" as="xs:string">
            <xsl:call-template name="GetChangedForReported" />
        </xsl:variable>
        
        <xsl:variable name="contents" as="item()*">
            <xsl:variable name="text">
                <xsl:apply-templates mode="process" />
            </xsl:variable>
            
            <xsl:choose>
                <xsl:when test="@bold = 'on'">
                    <xsl:processing-instruction name="xpp">ff;1</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
                    <xsl:value-of select="gpo:rawRegexReplace(gpo:capICHeader(string($text)), '((\d+)(\[(.*)\])*)', '$1')" />
                    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="string($text)" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:element name="para">
            <xsl:choose>
                <xsl:when test="$style = 'tax'">
                    <xsl:attribute name="loc" select="'44'" />
                    
                    <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
                    
                    <xsl:if test="parent::toc-quoted-entry">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="@bold = 'on'">
                    <xsl:attribute name="loc" select="'74'" />
                    <xsl:processing-instruction name="xpp">ff;2</xsl:processing-instruction>
                    <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                    <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
                </xsl:when>
                <xsl:when test="$style = 'OLC'">
                    <!-- fixes issue #116; typo from original code (locator was 44, should've been 74 -->
                    <xsl:attribute name="loc" select="'74'" />
                    <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
                    
                    <xsl:if test="parent::toc-quoted-entry">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="starts-with($style, 'traditional')">
                    <xsl:attribute name="loc" select="'74'" />
                    <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
                    
                    <xsl:if test="parent::toc-quoted-entry">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="starts-with($style, 'archaic')">
                    <xsl:attribute name="loc" select="'74'" />
                    
                    <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
                    
                    <xsl:if test="parent::toc-quoted-entry">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                </xsl:when>
                <xsl:otherwise>
                    <!-- fixes issue #116; typo from original code (locator was 44, should've been 74 -->
                    <xsl:attribute name="loc" select="'74'" />
                    <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
                    
                    <xsl:if test="parent::toc-quoted-entry">
                        <xsl:text>“</xsl:text>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
                <xsl:call-template name="GetChangedForToc" />
            </xsl:if>
            <!-- TB Nov2012 Fixing opening bracket on big title toc -->
            <xsl:if test="contains($ChangedForReported, 'brackets')">
                <xsl:text>❨</xsl:text>
                
            </xsl:if>
            <xsl:if test="contains($ChangedForReported, 'parentheses')">
                <xsl:text>【</xsl:text>
                
            </xsl:if>
            <xsl:choose>
                <xsl:when test="$style = 'tax'">
                    <xsl:value-of select="string($contents)" />
                </xsl:when>
                <xsl:otherwise>
                    <!-- fixes issue #274 -->
                    <!-- capICHeader expects intput in certain format so the input string needs to be
                        normalized before it is passed to capICHeader -->
                    <xsl:value-of select="gpo:capICHeader(normalize-space($contents))" />
                </xsl:otherwise>
            </xsl:choose>
            
            <xsl:call-template name="toc-entry-end" />

        </xsl:element>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level = 'subsection']" mode="process">
        <xsl:variable name="style" as="xs:string">
            <xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
        </xsl:variable>
        
        <xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
            <xsl:call-template name="GetChangedForToc" />
        </xsl:if>
        
        <xsl:variable name="contents" as="xs:string">
            <xsl:apply-templates mode="process" />
        </xsl:variable>
        
        <xsl:element name="para">
            <xsl:choose>
                <xsl:when test="$style = 'tax'">
                    <xsl:attribute name="loc" select="'44'" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="loc" select="'43'" />
                </xsl:otherwise>
            </xsl:choose>
            <xsl:call-template name="createTOC-Entry-Q10" />
            <xsl:if test="@bold = 'on'">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
            </xsl:if>
            
            <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
            
            <xsl:if test="parent::toc-quoted-entry">
                <xsl:text>“</xsl:text>
            </xsl:if>
            <xsl:sequence select="$contents" />
            
            <xsl:call-template name="toc-entry-end" />
        </xsl:element>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-entry[@level = 'paragraph']" mode="process">
        <xsl:variable name="style" as="xs:string">
            <xsl:sequence select="gpo:GetNearestAncestorStyleRecursive(., true())" />
        </xsl:variable>
        
        <xsl:if test="@changed or (not(@changed) and preceding-sibling::toc-entry[1]/@changed and preceding-sibling::toc-entry[1]/@changed != 'not-changed')">
            <xsl:call-template name="GetChangedForToc" />
        </xsl:if>
        
        <xsl:variable name="contents" as="xs:string">
            <xsl:apply-templates mode="process" />
        </xsl:variable>
        
        <xsl:element name="para">
            <xsl:choose>
                <xsl:when test="$style = 'tax'">
                    <xsl:attribute name="loc" select="'44'" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="loc" select="'43'" />
                </xsl:otherwise>
            </xsl:choose>
            <xsl:call-template name="createTOC-Entry-Q10" />
            <xsl:if test="@bold = 'on'">
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction><!--syesmin 9/15/2015  Refactor XSLT 2.0-->
            </xsl:if>
            <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
            
            <xsl:if test="parent::toc-quoted-entry">
                <xsl:text>“</xsl:text>
            </xsl:if>
            <xsl:sequence select="$contents" />
            
            <xsl:call-template name="toc-entry-end" />
        </xsl:element>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="toc-enum" mode="process">
        
        <xsl:variable name="targetData" as="xs:string?" select="string(../target[1]/text())" />
        <xsl:choose>
            <xsl:when test="//committee-report/@front-matter-toc = 'yes'">
                <!-- nothing -->
            </xsl:when>
            <xsl:when test="$targetData = 'Sec.'                  and not(parent::multi-column-toc-entry/preceding-sibling::multi-column-toc-entry)                  and (parent::multi-column-toc-entry/following-sibling::multi-column-toc-entry)">
                <para loc="11" />
            </xsl:when>
            <!--#Issue 115:  Suppress outputting singleton <para>.  Moved logic to "multi-column-toc-entry"-->
            <xsl:when test="parent::multi-column-toc-entry">
             <!--   <xsl:apply-templates/>
                <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction>
           --> </xsl:when>
            <xsl:otherwise>
                <para loc="60" />
            </xsl:otherwise>
        </xsl:choose>
        
        <xsl:if test="@bold = 'on' or parent::node()/@bold = 'on'">
            <xsl:processing-instruction name="xpp">fv;2</xsl:processing-instruction> 
        </xsl:if>
        
        <xsl:if test="ancestor::quoted-block">
            <xsl:value-of select="gpo:QuotedBlockNestingStart(.)" />
        </xsl:if>
        <xsl:apply-templates mode="process" />
        <xsl:text> </xsl:text>
        
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="addQ-ProcessingInstructionForTOC">
        <xsl:param name="docstage" />
        <xsl:variable name="count" select="count(preceding-sibling::toc-entry)" as="xs:integer" />
        
        <!--Need more information on when this rule gets spawned
            <xsl:if test="following-sibling::toc-entry[1][@level='title'] and $count != 0">
            <xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
        </xsl:if>-->
     
        <xsl:if test="$count = 0">
            <xsl:choose>
                <!--Issue #255-->
                <xsl:when test="../preceding-sibling::*[1][name() = 'toc']" />
                <xsl:when test="$amendtype = 'conference-report' and (//conference-report-form[@conference-report-style = 'draft'] or //conference-report-form[@conference-report-style = 'bill'])">
                    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="$amendtype = 'conference-report'">
                    
                    <xsl:processing-instruction name="xpp">lp;&amp;104q</xsl:processing-instruction>
                    
                </xsl:when>
                <xsl:when test="parent::toc-quoted-entry" />
                <xsl:when test="parent::toc[parent::chapter]" />
                <!--Issue #223-->
                <xsl:when test="$docstage = 'Introduced-in-Senate' or $docstage = 'Introduced-in-House'">
                    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                </xsl:when>
                <!--Issue #229-->
                <xsl:when test="$docstage = 'Referred-in-House'">
                    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                </xsl:when>
                <!--Issue #292-->
                <xsl:when test="$docstage = 'Engrossed-in-House' and ../parent::quoted-block and ../../../text">
                 <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                </xsl:when>
                <!--Issue #302-->
                <xsl:when test="$docstage = 'Placed-on-Calendar-Senate' or $docstage = 'Introduced-in-House' or                      $docstage = 'Reported-in-House'">
                    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="$docstage = 'Enrolled-Bill'">
                    <xsl:processing-instruction name="xpp">lp;&amp;4q</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="parent::*/text">
                    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                </xsl:when>
                <xsl:when test="                     ../parent::section                     or ../parent::subsection                     or ../parent::paragraph                     or ../parent::subparagraph                     or ../parent::clause                     or ../parent::subclause                     or ../parent::item                     or ../parent::subitem                     ">
                    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:choose>
                        <xsl:when test="not(preceding-sibling::toc-entry) and ancestor::amendment-block">
                            <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="not(preceding-sibling::toc-entry) and ../parent::quoted-block and ../../../text">
                            <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                        </xsl:when>
                        <!--Issue #334-->
                        <xsl:when test="not(following-sibling::toc-entry)">
                            <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                        </xsl:when>
                        <xsl:when test="parent::quoted-block and ../../text">
                            <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                        </xsl:when>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" name="createTOC-Entry-Q10">
        <xsl:choose>
            <xsl:when test="preceding-sibling::toc-entry | ../preceding-sibling::toc-quoted-entry">
                
            </xsl:when>
            <!--          <xsl:when test="preceding-sibling::toc-quoted-entry"/>-->
            <!--<xsl:when test="ancestor::quoted-block"/>-->
            <xsl:otherwise>
                <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:template><xsl:template xmlns:dc="http://purl.org/dc/elements/1.1" match="multi-column-toc-entry" as="item()*" mode="process">
   <!--BH 2016-08-07 -->  <!-- Reworked this template into 3 separate components:
        1.  Process Format.
        2.  Process para for locator.
        3.  Process target.
        The logic is the same but the code is cleaner.  The locator information was getting lost because of structure
        of the xsl:if and xsl:when.
        -->
        <xsl:variable name="ChangedForReported" as="xs:string">
            <xsl:call-template name="GetChangedForReported" />
        </xsl:variable>
        
        <xsl:choose>
            <!--we do not output the Q10 or the S6211 if the xml file is a 'report'-->
            <xsl:when test="not(contains(/amendment-doc/@amend-type, 'report'))">
                <xsl:choose>
                    <xsl:when test="//committee-report//@front-matter-toc = 'yes'">
                        <xsl:apply-templates mode="process" />
                    </xsl:when>
                    <xsl:when test="../toc/@reported-display-style = 'strikethrough' or $ChangedForReported = 'strikethrough'">
                        <para format="6411" />
                            <xsl:apply-templates mode="process" />
                    </xsl:when>
                    <xsl:when test="../toc/@reported-display-style = 'italic' or $ChangedForReported = 'italic'">
                        <para format="6213" />
                    </xsl:when>
                    <xsl:when test="$billstage = 'Enrolled-Bill' or $resstage = 'Enrolled-in-Senate'">
                        <para format="6511" />
                    </xsl:when>
                    <xsl:when test="parent::toc and $m_isCommitteeReport = 'Yes' and not(ancestor::amendment-body)">
                        <!-- TB 13Nov2007 - Commitee Report exception - was nessesary to make it here -->
                        <para format="6646" />
                    </xsl:when>
                    <xsl:when test="parent::toc and $m_isCommitteeReport = 'Yes' and (ancestor::amendment-block or ancestor::amendment-body)">
                        <para format="6631" />
                    </xsl:when>
                    <xsl:otherwise>
                      
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise />
        </xsl:choose>

                                <para format="6211" loc="60">
                                    <xsl:processing-instruction name="xpp">lp;&amp;10q</xsl:processing-instruction>
                                    <xsl:apply-templates select="* except target" mode="process" />
                                </para>
                        
                        <xsl:if test="target">
                            <para format="6211" loc="52">
                                <xsl:apply-templates select="target" mode="process" />
                                <xsl:if test="parent::toc[following-sibling::after-quoted-block[1]]">
                                    <xsl:text>”</xsl:text>
                                    <xsl:choose>
                                        <xsl:when test="@level='chapter'">
                                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                                        </xsl:when>
                                        <xsl:when test="@level='part'">
                                            <xsl:processing-instruction name="xpp">fv;1</xsl:processing-instruction>
                                        </xsl:when>
                                        <xsl:otherwise />
                                    </xsl:choose>
                                    <xsl:value-of select="../../after-quoted-block" />
                                </xsl:if>
                            </para>
                        </xsl:if>
                   
        
    </xsl:template><xsl:preserve-space xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" elements="*" /><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" match="bill" mode="process">
		<bill>
		<!--
		<LOCDocument doctype="bill">-->
			<xsl:copy-of select="@*" />
			<xsl:variable name="stage" as="xs:string?">
				<xsl:call-template name="ConvStage">
					<xsl:with-param name="CStage" select="$billstage" />
				</xsl:call-template>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="$billstage = 'Enrolled-Bill'">
					<para format="6655" />
				</xsl:when>
				<xsl:otherwise>
					<para format="6652" />
				</xsl:otherwise>
			</xsl:choose>

			<xsl:if test="(($lc-docstage = 'engrossed-in-senate' or $lc-docstage = 'engrossed-amendment-senate') and $bill-public-print = 'yes') or $billstage = 'Printed-as-Passed'">
				<xsl:if test="//form/action[position() = last()]/action-date and not(//form/action[position() = last()]/action-date/@display = 'no') and not(//form/action[position() = last()]/@display = 'no')">
					<para loc="51">
						<xsl:value-of select="//form/action[position() = last()]/action-date" />
					</para>
				</xsl:if>
				<xsl:if test="//form/action[position() = last()]/action-desc and not(//form/action[position() = last()]/action-desc/@display = 'no') and not(//form/action[position() = last()]/@display = 'no')">
					<para loc="51">
						<xsl:processing-instruction name="xpp">lp;&amp;12q</xsl:processing-instruction>
						<xsl:value-of select="//form/action[position() = last()]/action-desc" />
					</para>
				</xsl:if>
			</xsl:if>
			<xsl:if test="contains($billstage, 'Engrossed') or $billstage = 'Printed-as-Passed'">
				<!-- TA: the template for processing official-title returns item()*. The variable below should be  string
				so that it is passed correctly to the officialTitleSpace template
				-->
				<xsl:variable name="officialtitle" as="xs:string?">
					<xsl:value-of select="/bill/form/official-title" />
				</xsl:variable>
				<xsl:choose>
					<xsl:when test="not(/bill/legis-body/pagebreak) and /bill/legis-body/section[1][@section-type = 'undesignated-section']/text[1][@display-inline = 'yes-display-inline']">
						<xsl:variable name="eclauseType" as="xs:string" select="'no'" />
						<xsl:variable name="DocType" as="xs:string" select="'un-sec'" />

						<xsl:call-template name="officialTitleSpace">
							<xsl:with-param name="officalTitle" select="$officialtitle" />
							<xsl:with-param name="EclauseType" select="$eclauseType" />
							<xsl:with-param name="DocType" select="$DocType" />
						</xsl:call-template>
					</xsl:when>
					<xsl:when test="($billstage = 'Engrossed-in-Senate' and //bill/@public-print = 'yes')">
						<xsl:variable name="eclauseType" as="xs:string" select="'yesPP'" />
						<xsl:variable name="DocType" as="xs:string?" select="$billtype" />
						<xsl:call-template name="officialTitleSpace">
							<xsl:with-param name="officalTitle" select="$officialtitle" />
							<xsl:with-param name="EclauseType" select="$eclauseType" />
							<xsl:with-param name="DocType" select="$DocType" />
						</xsl:call-template>
					</xsl:when>
					<xsl:when test="$billstage = 'Printed-as-Passed'">
						<xsl:variable name="eclauseType" as="xs:string" select="'yesPAP'" />
						<xsl:variable name="DocType" as="xs:string?" select="$billtype" />
						<xsl:call-template name="officialTitleSpace">
							<xsl:with-param name="officalTitle" select="$officialtitle" />
							<xsl:with-param name="EclauseType" select="$eclauseType" />
							<xsl:with-param name="DocType" select="$DocType" />
						</xsl:call-template>
					</xsl:when>
					<xsl:when test="not(/bill/legis-body/pagebreak)">
						<xsl:variable name="eclauseType" as="xs:string" select="'no'" />
						<xsl:variable name="DocType" as="xs:string?" select="$billtype" />
						<xsl:call-template name="officialTitleSpace">
							<xsl:with-param name="officalTitle" select="$officialtitle" />
							<xsl:with-param name="EclauseType" select="$eclauseType" />
							<xsl:with-param name="DocType" select="$DocType" />
						</xsl:call-template>
					</xsl:when>
					<xsl:when test="(/bill/legis-body/pagebreak)">
						<xsl:variable name="eclauseType" as="xs:string" select="'yes'" />
						<xsl:variable name="DocType" as="xs:string?" select="$billtype" />
						<xsl:call-template name="officialTitleSpace">
							<xsl:with-param name="officalTitle" select="$officialtitle" />
							<xsl:with-param name="EclauseType" select="$eclauseType" />
							<xsl:with-param name="DocType" select="$DocType" />
						</xsl:call-template>
					</xsl:when>
				</xsl:choose>
			</xsl:if>
			<xsl:if test="not($billstage = 'Enrolled-Bill')">
				<xsl:if test="not($billstage = 'Pre-Introduction')">
					<xsl:if test="/bill/pre-form">
						<xsl:call-template name="HidePart" />
					</xsl:if>
				</xsl:if>
				<!-- if the result of the template toOutputI90Line is anything other than true, we do not output the I90 lines -->
				<xsl:variable name="toOutput90" as="xs:string">
					<xsl:call-template name="toOutputI90Line" />
				</xsl:variable>
				<xsl:if test="$toOutput90 = 'true'">
					<para loc="59" />
						
					<xsl:call-template name="displayI90ForAll" />
			
				</xsl:if>
				<xsl:if test="not($billstage = 'Received-in-Senate' or $billstage = 'Referred-in-Senate' or $billstage = 'Engrossed-in-Senate' or $billstage = 'Engrossed-in-House' or $billstage = 'Engrossed-House')">
					<xsl:if test="not(//pre-form)">
						<para loc="39" />
						<para loc="46" />
						<xsl:if test="not(/bill/form/calendar)">
							<para loc="40" />
						</xsl:if>

					</xsl:if>
				</xsl:if>
			</xsl:if>
			<xsl:apply-templates mode="process" />
			<!--Issue #57 - call endorsement processing -->
			<!--Issue #126 - call endorsement when no @display attribute is present-->
			<xsl:if test="descendant::endorsement[@display='yes' or not(@display)]">
				<xsl:call-template name="printEndorsement" />
			</xsl:if>
			<!-- add AllMark PI, if needed -->
			<xsl:if test="$needsAllMark = 'yes'">
				<xsl:processing-instruction name="xpp">AllMark</xsl:processing-instruction>
			</xsl:if>
		</bill>
	</xsl:template><xsl:template xmlns:doc="http://xsltsl.org/xsl/documentation/1.0" xmlns:dc="http://purl.org/dc/elements/1.1" name="PrintStarAndI90Line">
		<xsl:if test="/bill/@stage-count &gt; 1">
			<xsl:value-of select="/bill/@stage-count" />
		</xsl:if>
		<xsl:call-template name="createSlugLine" />
		<xsl:choose>
			<xsl:when test="$bill-star-print and not($bill-star-print = 'no-star-print')">
				<xsl:variable name="starCount" as="xs:string" select="gpo:starPrint($bill-star-print)" />
				<xsl:value-of select="$starCount" />
				<xsl:variable name="starString" as="xs:string" select="gpo:getStarString(xs:integer($starCount))" />
				<xsl:text>S</xsl:text>
			</xsl:when>
			<!--Issue #118 - the upconversion doesn't contain the emspace which is the default-->
			<xsl:when test="/resolution" />
			<xsl:otherwise>
				<!-- issue #42 -->
				<xsl:text> </xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template> 
     
    <xsl:strip-space elements="para" /><xsl:template match="processing-instruction('xml-stylesheet')" mode="postprocess" /><xsl:template match="LOCDocument|bill|amendment-doc" mode="postprocess">
        <xsl:element name="{local-name()}">
            <!-- issue #279, #301 -->
            <xsl:copy-of select="@* except (@vbattChangedForReported)" />
            <xsl:apply-templates mode="postprocess" />
        </xsl:element>
    </xsl:template><xsl:template match="para[@loc][@format != ''][. != '']" mode="postprocess">
        <xsl:variable name="text">
            <xsl:value-of select="translate(normalize-space(.), '   ', '')" />
        </xsl:variable>
        <xsl:variable name="loc">
            <xsl:value-of select="translate(@loc, '  ', '')" />
        </xsl:variable>
        <xsl:variable name="output">
            <xsl:analyze-string select="$text" regex="^[\S*]$">
                <xsl:matching-substring>
                    <xsl:value-of select="regex-group(1)" />
                </xsl:matching-substring>
                <xsl:non-matching-substring>no</xsl:non-matching-substring>
            </xsl:analyze-string>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="translate($text, ' ', '') = ''" />
            <xsl:otherwise>
                <para>
                    <xsl:attribute name="format">
                        <xsl:choose>
                            <xsl:when test="@format != ''"><xsl:value-of select="@format" /></xsl:when>
                            <xsl:when test="child::para/@format"><xsl:value-of select="child::para/@format" /></xsl:when>
                            <xsl:otherwise> <xsl:value-of select="preceding-sibling::para[@format][1]/@format" /></xsl:otherwise>
                        </xsl:choose>
                    </xsl:attribute>
                    <xsl:attribute name="loc">
                        <xsl:value-of select="$loc" />
                    </xsl:attribute>
                    <xsl:apply-templates mode="postprocess" /></para>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template match="para[. = '']" mode="postprocess" /><xsl:template match="para[@loc = '44' or @loc = '48'][. = '']" mode="postprocess" priority="24">
        <xsl:choose>
            <xsl:when test="@format">
                <para><xsl:copy-of select="@*" />
                </para>
            </xsl:when>
            <xsl:otherwise>
                <para>
                    <xsl:attribute name="format">
                        <xsl:value-of select="preceding-sibling::para[@format][1]/@format" />
                    </xsl:attribute>
                    <xsl:copy-of select="@*" />
                </para>
            </xsl:otherwise>
        </xsl:choose>

    </xsl:template><xsl:template match="para[@loc = '20' and @format = '6999']" mode="postprocess" priority="24">
        <para>
            <xsl:copy-of select="@*" />
        </para>
    </xsl:template><xsl:template match="para[@loc][not(@format)][text() != '']" mode="postprocess">
        <xsl:variable name="text">
            <xsl:value-of select="translate(normalize-space(.), '   ', '')" />
        </xsl:variable>
        <xsl:variable name="output">
            <xsl:analyze-string select="$text" regex="[(\s)*]">
                <xsl:matching-substring>
                    <xsl:value-of select="regex-group(1)" />
                    <xsl:text> </xsl:text>
                </xsl:matching-substring>
                <xsl:non-matching-substring>no</xsl:non-matching-substring>
            </xsl:analyze-string>
        </xsl:variable>
        <xsl:choose>
            <!--Added rule to retain beginning paragraphs with spaces.-->
            <xsl:when test="@loc = '20' and . != ''">
                <xsl:call-template name="createParaContent" />
            </xsl:when>
            <xsl:when test=". = ' '">
                <xsl:call-template name="createParaContent" />
            </xsl:when>
            <xsl:when test="translate($text, ' ', '') = ''" />
            <xsl:otherwise>
                <xsl:call-template name="createParaContent" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template name="createParaContent">
        <xsl:variable name="format">
            <xsl:choose>
                <xsl:when test="child::para/@format"><xsl:value-of select="child::para/@format" /></xsl:when>
                <xsl:otherwise> <xsl:value-of select="preceding-sibling::para[@format][1]/@format" /></xsl:otherwise>
            </xsl:choose>   
        </xsl:variable>
        <para>
            <xsl:attribute name="format">
                <xsl:value-of select="$format" />    
            </xsl:attribute>
            <xsl:attribute name="loc">
                <xsl:value-of select="translate(@loc, '  ', '')" />
            </xsl:attribute>
            <!--Issue #205 - Fixed when qcodes are included in format paras. -->
            <xsl:choose>
                <xsl:when test="preceding-sibling::para[1][not(@qcode)]" />
                <xsl:otherwise>
                    <xsl:if test="preceding-sibling::para[@qcode][1]">
                    <xsl:processing-instruction name="xpp">lp;&amp;<xsl:value-of select="preceding-sibling::para[@qcode][1]/@qcode" />q</xsl:processing-instruction>
                </xsl:if></xsl:otherwise>
            </xsl:choose>
            
            <xsl:choose>
                <xsl:when test="processing-instruction()">
                    <xsl:apply-templates mode="postprocess" />
                </xsl:when>
                <!--Issue #524 - keep trailing space-->
                <xsl:when test="@loc='04' and starts-with(., 'Begun')"><xsl:value-of select="." /></xsl:when>
                <xsl:otherwise><xsl:value-of select="normalize-space(.)" /></xsl:otherwise>
            </xsl:choose>
        </para>
    </xsl:template><xsl:template match="para[@format][not(@loc)][text() != '']" mode="postprocess">
        <xsl:variable name="text">
            <xsl:value-of select="translate(normalize-space(.), '   ', '')" />
        </xsl:variable>
        <xsl:variable name="output">
            <xsl:analyze-string select="$text" regex="^[\S*]$">
                <xsl:matching-substring>
                    <xsl:value-of select="regex-group(1)" />
                </xsl:matching-substring>
                <xsl:non-matching-substring>no</xsl:non-matching-substring>
            </xsl:analyze-string>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="translate($text, ' ', '') = ''" />
            <xsl:when test="$text = ' '" />
            <xsl:otherwise>
                <para>
                    <xsl:attribute name="format">
                        <xsl:choose>
                            <xsl:when test="child::para/@format"><xsl:value-of select="child::para/@format" /></xsl:when>
                            <xsl:otherwise> <xsl:value-of select="preceding-sibling::para[@format][1]/@format" /></xsl:otherwise>
                        </xsl:choose>
                    </xsl:attribute>
                    <xsl:if test="child::para[@loc]">
                        <xsl:attribute name="loc">
                            <xsl:value-of select="translate(para[last()]/@loc, '  ', '')" />
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:apply-templates mode="postprocess" />
                </para>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template><xsl:template match="bill/text()" mode="postprocess" /><xsl:template match="text()" mode="postprocess">
        <xsl:variable name="string">
            <xsl:choose>
                <!--Issue #507-->
                <xsl:when test="ancestor::entry and $processTables = true()">
                    <xsl:value-of select="normalize-space(.)" />
                </xsl:when>
                <xsl:when test="not(.[parent::para])" />
                <xsl:when test="ends-with(., ' ') and contains(following-sibling::processing-instruction()[1], 'rs-font')">
                    <xsl:choose>
                        <xsl:when test="starts-with(., ' ')"><xsl:text> </xsl:text><xsl:value-of select="normalize-space(.)" /></xsl:when>
                        <xsl:otherwise><xsl:value-of select="normalize-space(.)" /></xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="starts-with(., ' ')"><xsl:text> </xsl:text> <xsl:value-of select="normalize-space(.)" /></xsl:when>
                <!-- issue #361 -->
                <xsl:when test="starts-with(., '&#xA;')"><xsl:text> </xsl:text> <xsl:value-of select="normalize-space(.)" /></xsl:when>
                <xsl:otherwise> <xsl:value-of select="normalize-space(.)" /></xsl:otherwise>
            </xsl:choose>  
        </xsl:variable>
        <xsl:value-of select="replace($string, ' ,', ',')" />
    </xsl:template><xsl:template match="comment()" mode="postprocess" /><xsl:template match="processing-instruction()" mode="postprocess">
        <!--Issue #257-->
        <xsl:choose>
            <xsl:when test="parent::bill and contains(., 'fv')" />
            <xsl:when test="parent::bill and contains(., 'rs-font')" />
            <xsl:when test="parent::bill and contains(., 'q')" />
            <xsl:otherwise> <xsl:if test="ends-with(preceding-sibling::text()[1], ' ')">
                <xsl:text> </xsl:text>
            </xsl:if>
                <xsl:copy />
            </xsl:otherwise>
        </xsl:choose>  
    </xsl:template><xsl:template name="suppressTableAtts">
        <xsl:copy-of select="@* except (@style | @vbattChangedForReported)" />
    </xsl:template><xsl:template match="table" mode="postprocess">
        <table>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </table>
    </xsl:template><xsl:template match="tgroup" mode="postprocess">
        <tgroup>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </tgroup>
    </xsl:template><xsl:template match="thead" mode="postprocess">
        <thead>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </thead>
    </xsl:template><xsl:template match="colspec" mode="postprocess">
        <colspec>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </colspec>
    </xsl:template><xsl:template match="tbody" mode="postprocess">
        <tbody>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </tbody>
    </xsl:template><xsl:template match="row" mode="postprocess">
        <row>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </row>
    </xsl:template><xsl:template match="entry" mode="postprocess">
        <entry>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </entry>
    </xsl:template><xsl:template match="tfoot" mode="postprocess">
        <tfoot>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </tfoot>
    </xsl:template><xsl:template match="ttitle" mode="postprocess">
        <ttitle>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </ttitle>
    </xsl:template><xsl:template match="tdesc" mode="postprocess">
        <tdesc>
            <xsl:call-template name="suppressTableAtts" />
            <xsl:apply-templates mode="postprocess" />
        </tdesc>
    </xsl:template>
    
    <xsl:template match="LOCDocument|bill|amendment-doc" mode="cleanup">
        <xsl:element name="{local-name()}">
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="cleanup" />
        </xsl:element>
    </xsl:template><xsl:template match="text()" mode="cleanup">
        <!-- replace staright apostrophe with curly apostrophe -->
        <xsl:value-of select="replace(., &quot;'&quot;, &quot;’&quot;)" />
    </xsl:template><xsl:template match="*" mode="cleanup">
        <xsl:element name="{local-name(.)}">
            <xsl:copy-of select="@*" />
            <xsl:apply-templates mode="cleanup" />
        </xsl:element>
    </xsl:template><xsl:template match="processing-instruction()" mode="cleanup">
        <xsl:copy />
    </xsl:template>



 
    <xsl:template match="/">
        
        
        <!--Stage 0: modUtil -->
        <xsl:variable name="stg0-result">
            <xsl:apply-templates select="/" mode="modeUtil" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of0" select="concat($uriBase, '.S0.XML')" />
            <xsl:result-document href="{$of0}">
                <xsl:copy-of select="$stg0-result" />
            </xsl:result-document>
        </xsl:if>
        
        
        <!--Stage 1: setIndent -->
        <xsl:variable name="stg1-result">
            <xsl:apply-templates select="$stg0-result" mode="setIndentAttr" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of1" select="concat($uriBase, '.S1.XML')" />
            <xsl:result-document href="{$of1}">
                <xsl:copy-of select="$stg1-result" />
            </xsl:result-document>
        </xsl:if>
        


        <!--Stage 2: setStageAttr -->
        <xsl:variable name="stg2-result">
            <xsl:apply-templates select="$stg1-result" mode="setStageAttr" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of2" select="concat($uriBase, '.S2.XML')" />
            <xsl:result-document href="{$of2}">
                <xsl:copy-of select="$stg2-result" />
            </xsl:result-document>
        </xsl:if>

        <!-- Stage 3: setCommitteeAddedDeletedDisplayStyleAttr -->
        <xsl:variable name="stg3-result">
            <xsl:apply-templates select="$stg2-result" mode="setCommitteeAddedDeletedDisplayStyleAttr" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of3" select="concat($uriBase, '.S3.XML')" />
            <xsl:result-document href="{$of3}">
                <xsl:copy-of select="$stg3-result" />
            </xsl:result-document>
        </xsl:if>

        <!--Stage 4: setVbattParentFormatAttr -->
        <xsl:variable name="stg4-result">
            <xsl:apply-templates select="$stg3-result" mode="setVbattParentFormatAttr" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of4" select="concat($uriBase, '.S4.XML')" />
            <xsl:result-document href="{$of4}">
                <xsl:copy-of select="$stg4-result" />
            </xsl:result-document>
        </xsl:if>

        <!--Stage 5: setChangedForReportedAttr -->
        <xsl:variable name="stg5-result">
            <xsl:apply-templates select="$stg4-result" mode="setChangedForReportedAttr" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of5" select="concat($uriBase, '.S5.XML')" />
            <xsl:result-document href="{$of5}">
                <xsl:copy-of select="$stg5-result" />
            </xsl:result-document>
        </xsl:if>

        <!--Stage 6: setStyleAttr -->
        <xsl:variable name="stg6-result">
            <xsl:apply-templates select="$stg5-result" mode="setStyleAttr" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of6" select="concat($uriBase, '.S6.XML')" />
            <xsl:result-document href="{$of6}">
                <xsl:copy-of select="$stg6-result" />
            </xsl:result-document>
        </xsl:if>

        <!--Stage 7: populateElementAttr -->
        <xsl:variable name="stg7-result">
            <xsl:apply-templates select="$stg6-result" mode="populateElementAttr" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of7" select="concat($uriBase, '.S7.XML')" />
            <xsl:result-document href="{$of7}">
                <xsl:copy-of select="$stg7-result" />
            </xsl:result-document>
        </xsl:if>

        <!--Stage 8: calsTables -->
        <xsl:variable name="stg8-result">
            <xsl:apply-templates select="$stg7-result" mode="calsTables" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of8" select="concat($uriBase, '.S8.XML')" />
            <xsl:result-document href="{$of8}">
                <xsl:copy-of select="$stg8-result" />
            </xsl:result-document>
        </xsl:if>   
         
        <!--Stage 9: process -->
        <xsl:variable name="stg9-result">
            <xsl:apply-templates select="$stg8-result" mode="process" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of9" select="concat($uriBase, '.S9.XML')" />
            <xsl:result-document href="{$of9}">
                <xsl:copy-of select="$stg9-result" />
            </xsl:result-document>
        </xsl:if>


        <!--Stage 10: postprocess -->
        <xsl:variable name="stg10-result">
            <xsl:apply-templates select="$stg9-result" mode="postprocess" />
        </xsl:variable>
        <xsl:if test="$debugState != 0">
            <xsl:variable name="of10" select="concat($uriBase, '.S10.XML')" />
            <xsl:result-document href="{$of10}">
                <xsl:copy-of select="$stg10-result" />
            </xsl:result-document>
        </xsl:if>
        
        <xsl:apply-templates select="$stg10-result" mode="cleanup" />


    </xsl:template>

</xsl:stylesheet>